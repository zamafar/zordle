{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define(t) : (e.prettierPlugins = e.prettierPlugins || {}, e.prettierPlugins.angular = t());\n}(this, function () {\n  \"use strict\";\n\n  var e = function (e) {\n    return e.length > 0 ? e[e.length - 1] : null;\n  };\n\n  var t = {\n    locStart: function e(t, n) {\n      return !(n = n || {}).ignoreDecorators && t.declaration && t.declaration.decorators && t.declaration.decorators.length > 0 ? e(t.declaration.decorators[0]) : !n.ignoreDecorators && t.decorators && t.decorators.length > 0 ? e(t.decorators[0]) : t.__location ? t.__location.startOffset : t.range ? t.range[0] : \"number\" == typeof t.start ? t.start : t.loc ? t.loc.start : null;\n    },\n    locEnd: function t(n) {\n      var i = n.nodes && e(n.nodes);\n      if (i && n.source && !n.source.end && (n = i), n.__location) return n.__location.endOffset;\n      var r = n.range ? n.range[1] : \"number\" == typeof n.end ? n.end : null;\n      return n.typeAnnotation ? Math.max(r, t(n.typeAnnotation)) : n.loc && !r ? n.loc.end : r;\n    }\n  };\n\n  function n(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n  }\n\n  function i(e, t) {\n    return e(t = {\n      exports: {}\n    }, t.exports), t.exports;\n  }\n\n  function r(e) {\n    return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  function s(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function a(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n    }\n  }\n\n  function o(e, t, n) {\n    return t && a(e.prototype, t), n && a(e, n), e;\n  }\n\n  function u(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    }), t && c(e, t);\n  }\n\n  function l(e) {\n    return (l = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function c(e, t) {\n    return (c = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function h(e, t) {\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? function (e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    }(e) : t;\n  }\n\n  function p(e, t) {\n    return v(e) || function (e, t) {\n      var n = [],\n          i = !0,\n          r = !1,\n          s = void 0;\n\n      try {\n        for (var a, o = e[Symbol.iterator](); !(i = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); i = !0);\n      } catch (e) {\n        r = !0, s = e;\n      } finally {\n        try {\n          i || null == o.return || o.return();\n        } finally {\n          if (r) throw s;\n        }\n      }\n\n      return n;\n    }(e, t) || f();\n  }\n\n  function v(e) {\n    if (Array.isArray(e)) return e;\n  }\n\n  function f() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n  }\n\n  var d = i(function (e, t) {\n    var n = \"\\n\",\n        i = \"\\r\",\n        r = function () {\n      function e(e) {\n        this.string = e;\n\n        for (var t = [0], r = 0; r < e.length;) switch (e[r]) {\n          case n:\n            r += n.length, t.push(r);\n            break;\n\n          case i:\n            e[r += i.length] === n && (r += n.length), t.push(r);\n            break;\n\n          default:\n            r++;\n        }\n\n        this.offsets = t;\n      }\n\n      return e.prototype.locationForIndex = function (e) {\n        if (e < 0 || e > this.string.length) return null;\n\n        for (var t = 0, n = this.offsets; n[t + 1] <= e;) t++;\n\n        return {\n          line: t,\n          column: e - n[t]\n        };\n      }, e.prototype.indexForLocation = function (e) {\n        var t = e.line,\n            n = e.column;\n        return t < 0 || t >= this.offsets.length ? null : n < 0 || n > this.lengthOfLine(t) ? null : this.offsets[t] + n;\n      }, e.prototype.lengthOfLine = function (e) {\n        var t = this.offsets[e];\n        return (e === this.offsets.length - 1 ? this.string.length : this.offsets[e + 1]) - t;\n      }, e;\n    }();\n\n    t.__esModule = !0, t.default = r;\n  });\n  n(d);\n  var y = i(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n\n    t.Context = function e(t) {\n      s(this, e), this.text = t, this.locator = new n(this.text);\n    };\n\n    var n = function () {\n      function e(t) {\n        s(this, e), this._lineAndColumn = new d.default(t);\n      }\n\n      return o(e, [{\n        key: \"locationForIndex\",\n        value: function (e) {\n          var t = this._lineAndColumn.locationForIndex(e);\n\n          return {\n            line: t.line + 1,\n            column: t.column\n          };\n        }\n      }]), e;\n    }();\n  });\n  n(y);\n\n  var x = function e(t, n, i, r) {\n    s(this, e), this.input = n, this.errLocation = i, this.ctxLocation = r, this.message = \"Parser Error: \".concat(t, \" \").concat(i, \" [\").concat(n, \"] in \").concat(r);\n  },\n      g = function e(t, n) {\n    s(this, e), this.start = t, this.end = n;\n  },\n      k = function () {\n    function e(t) {\n      s(this, e), this.span = t;\n    }\n\n    return o(e, [{\n      key: \"visit\",\n      value: function (e) {\n        arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n        return null;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"AST\";\n      }\n    }]), e;\n  }(),\n      m = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).prefix = n, a.uninterpretedExpression = i, a.location = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitQuote(this, t);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"Quote\";\n      }\n    }]), t;\n  }(),\n      w = function (e) {\n    function t() {\n      return s(this, t), h(this, l(t).apply(this, arguments));\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        arguments.length > 1 && void 0 !== arguments[1] && arguments[1];\n      }\n    }]), t;\n  }(),\n      C = function (e) {\n    function t() {\n      return s(this, t), h(this, l(t).apply(this, arguments));\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitImplicitReceiver(this, t);\n      }\n    }]), t;\n  }(),\n      P = function (e) {\n    function t(e, n) {\n      var i;\n      return s(this, t), (i = h(this, l(t).call(this, e))).expressions = n, i;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitChain(this, t);\n      }\n    }]), t;\n  }(),\n      b = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).condition = n, a.trueExp = i, a.falseExp = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitConditional(this, t);\n      }\n    }]), t;\n  }(),\n      E = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).receiver = n, r.name = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPropertyRead(this, t);\n      }\n    }]), t;\n  }(),\n      A = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).receiver = n, a.name = i, a.value = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPropertyWrite(this, t);\n      }\n    }]), t;\n  }(),\n      S = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).receiver = n, r.name = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitSafePropertyRead(this, t);\n      }\n    }]), t;\n  }(),\n      N = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).obj = n, r.key = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitKeyedRead(this, t);\n      }\n    }]), t;\n  }(),\n      O = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).obj = n, a.key = i, a.value = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitKeyedWrite(this, t);\n      }\n    }]), t;\n  }(),\n      I = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).exp = n, a.name = i, a.args = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPipe(this, t);\n      }\n    }]), t;\n  }(),\n      L = function (e) {\n    function t(e, n) {\n      var i;\n      return s(this, t), (i = h(this, l(t).call(this, e))).value = n, i;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralPrimitive(this, t);\n      }\n    }]), t;\n  }(),\n      M = function (e) {\n    function t(e, n) {\n      var i;\n      return s(this, t), (i = h(this, l(t).call(this, e))).expressions = n, i;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralArray(this, t);\n      }\n    }]), t;\n  }(),\n      _ = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).keys = n, r.values = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralMap(this, t);\n      }\n    }]), t;\n  }(),\n      K = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).strings = n, r.expressions = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitInterpolation(this, t);\n      }\n    }]), t;\n  }(),\n      T = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).operation = n, a.left = i, a.right = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitBinary(this, t);\n      }\n    }]), t;\n  }(),\n      B = function (e) {\n    function t(e, n) {\n      var i;\n      return s(this, t), (i = h(this, l(t).call(this, e))).expression = n, i;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPrefixNot(this, t);\n      }\n    }]), t;\n  }(),\n      R = function (e) {\n    function t(e, n) {\n      var i;\n      return s(this, t), (i = h(this, l(t).call(this, e))).expression = n, i;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitNonNullAssert(this, t);\n      }\n    }]), t;\n  }(),\n      j = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).receiver = n, a.name = i, a.args = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitMethodCall(this, t);\n      }\n    }]), t;\n  }(),\n      F = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, e))).receiver = n, a.name = i, a.args = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitSafeMethodCall(this, t);\n      }\n    }]), t;\n  }(),\n      V = function (e) {\n    function t(e, n, i) {\n      var r;\n      return s(this, t), (r = h(this, l(t).call(this, e))).target = n, r.args = i, r;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitFunctionCall(this, t);\n      }\n    }]), t;\n  }(),\n      G = function (e) {\n    function t(e, n, i, r) {\n      var a;\n      return s(this, t), (a = h(this, l(t).call(this, new g(0, null == n ? 0 : n.length)))).ast = e, a.source = n, a.location = i, a.errors = r, a;\n    }\n\n    return u(t, k), o(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return this.ast.visit(e, t);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"\".concat(this.source, \" in \").concat(this.location);\n      }\n    }]), t;\n  }(),\n      W = function e(t, n, i, r, a) {\n    s(this, e), this.span = t, this.key = n, this.keyIsVar = i, this.name = r, this.expression = a;\n  },\n      U = function () {\n    function e() {\n      s(this, e);\n    }\n\n    return o(e, [{\n      key: \"visitBinary\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {}\n    }]), e;\n  }(),\n      Q = function () {\n    function e() {\n      s(this, e);\n    }\n\n    return o(e, [{\n      key: \"visitBinary\",\n      value: function (e, t) {\n        return e.left.visit(this), e.right.visit(this), null;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        return e.condition.visit(this), e.trueExp.visit(this), e.falseExp.visit(this), null;\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        return e.exp.visit(this), this.visitAll(e.args, t), null;\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        return e.target.visit(this), this.visitAll(e.args, t), null;\n      }\n    }, {\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return null;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        return e.obj.visit(this), e.key.visit(this), null;\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        return e.obj.visit(this), e.key.visit(this), e.value.visit(this), null;\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        return this.visitAll(e.values, t);\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return null;\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        return e.receiver.visit(this), this.visitAll(e.args, t);\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        return e.expression.visit(this), null;\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        return e.expression.visit(this), null;\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        return e.receiver.visit(this), null;\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        return e.receiver.visit(this), e.value.visit(this), null;\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        return e.receiver.visit(this), null;\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        return e.receiver.visit(this), this.visitAll(e.args, t);\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e, t) {\n        var n = this;\n        return e.forEach(function (e) {\n          return e.visit(n, t);\n        }), null;\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return null;\n      }\n    }]), e;\n  }(),\n      z = function () {\n    function e() {\n      s(this, e);\n    }\n\n    return o(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        return new K(e.span, e.strings, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return new L(e.span, e.value);\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        return new E(e.span, e.receiver.visit(this), e.name);\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        return new A(e.span, e.receiver.visit(this), e.name, e.value.visit(this));\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        return new S(e.span, e.receiver.visit(this), e.name);\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        return new j(e.span, e.receiver.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        return new F(e.span, e.receiver.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        return new V(e.span, e.target.visit(this), this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        return new M(e.span, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        return new _(e.span, e.keys, this.visitAll(e.values));\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {\n        return new T(e.span, e.operation, e.left.visit(this), e.right.visit(this));\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        return new B(e.span, e.expression.visit(this));\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        return new R(e.span, e.expression.visit(this));\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        return new b(e.span, e.condition.visit(this), e.trueExp.visit(this), e.falseExp.visit(this));\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        return new I(e.span, e.exp.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        return new N(e.span, e.obj.visit(this), e.key.visit(this));\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        return new O(e.span, e.obj.visit(this), e.key.visit(this), e.value.visit(this));\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        for (var t = new Array(e.length), n = 0; n < e.length; ++n) t[n] = e[n].visit(this);\n\n        return t;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        return new P(e.span, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return new m(e.span, e.prefix, e.uninterpretedExpression, e.location);\n      }\n    }]), e;\n  }(),\n      $ = function () {\n    function e() {\n      s(this, e);\n    }\n\n    return o(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new K(e.span, e.strings, n) : e;\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this);\n        return n !== e.receiver ? new E(e.span, n, e.name) : e;\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this),\n            i = e.value.visit(this);\n        return n !== e.receiver || i !== e.value ? new A(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this);\n        return n !== e.receiver ? new S(e.span, n, e.name) : e;\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this);\n        return n !== e.receiver ? new j(e.span, n, e.name, this.visitAll(e.args)) : e;\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.receiver || i !== e.args ? new F(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        var n = e.target && e.target.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.target || i !== e.args ? new V(e.span, n, i) : e;\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new M(e.span, n) : e;\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        var n = this.visitAll(e.values);\n        return n !== e.values ? new _(e.span, e.keys, n) : e;\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {\n        var n = e.left.visit(this),\n            i = e.right.visit(this);\n        return n !== e.left || i !== e.right ? new T(e.span, e.operation, n, i) : e;\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        var n = e.expression.visit(this);\n        return n !== e.expression ? new B(e.span, n) : e;\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        var n = e.expression.visit(this);\n        return n !== e.expression ? new R(e.span, n) : e;\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        var n = e.condition.visit(this),\n            i = e.trueExp.visit(this),\n            r = e.falseExp.visit(this);\n        return n !== e.condition || i !== e.trueExp || r != r ? new b(e.span, n, i, r) : e;\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        var n = e.exp.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.exp || i !== e.args ? new I(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        var n = e.obj.visit(this),\n            i = e.key.visit(this);\n        return n !== e.obj || i !== e.key ? new N(e.span, n, i) : e;\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        var n = e.obj.visit(this),\n            i = e.key.visit(this),\n            r = e.value.visit(this);\n        return n !== e.obj || i !== e.key || r !== e.value ? new O(e.span, n, i, r) : e;\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        for (var t = new Array(e.length), n = !1, i = 0; i < e.length; ++i) {\n          var r = e[i],\n              s = r.visit(this);\n          t[i] = s, n = n || s !== r;\n        }\n\n        return n ? t : e;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new P(e.span, n) : e;\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return e;\n      }\n    }]), e;\n  }();\n\n  var q;\n  !function (e) {\n    e[e.DEFAULT = 0] = \"DEFAULT\", e[e.LITERAL_ATTR = 1] = \"LITERAL_ATTR\", e[e.ANIMATION = 2] = \"ANIMATION\";\n  }(q || (q = {}));\n  var D,\n      H = Object.freeze({\n    ParserError: x,\n    ParseSpan: g,\n    AST: k,\n    Quote: m,\n    EmptyExpr: w,\n    ImplicitReceiver: C,\n    Chain: P,\n    Conditional: b,\n    PropertyRead: E,\n    PropertyWrite: A,\n    SafePropertyRead: S,\n    KeyedRead: N,\n    KeyedWrite: O,\n    BindingPipe: I,\n    LiteralPrimitive: L,\n    LiteralArray: M,\n    LiteralMap: _,\n    Interpolation: K,\n    Binary: T,\n    PrefixNot: B,\n    NonNullAssert: R,\n    MethodCall: j,\n    SafeMethodCall: F,\n    FunctionCall: V,\n    ASTWithSource: G,\n    TemplateBinding: W,\n    NullAstVisitor: U,\n    RecursiveAstVisitor: Q,\n    AstTransformer: z,\n    AstMemoryEfficientTransformer: $,\n    visitAstChildren: function (e, t, n) {\n      function i(e) {\n        t.visit && t.visit(e, n) || e.visit(t, n);\n      }\n\n      function r(e) {\n        e.forEach(i);\n      }\n\n      e.visit({\n        visitBinary: function (e) {\n          i(e.left), i(e.right);\n        },\n        visitChain: function (e) {\n          r(e.expressions);\n        },\n        visitConditional: function (e) {\n          i(e.condition), i(e.trueExp), i(e.falseExp);\n        },\n        visitFunctionCall: function (e) {\n          e.target && i(e.target), r(e.args);\n        },\n        visitImplicitReceiver: function (e) {},\n        visitInterpolation: function (e) {\n          r(e.expressions);\n        },\n        visitKeyedRead: function (e) {\n          i(e.obj), i(e.key);\n        },\n        visitKeyedWrite: function (e) {\n          i(e.obj), i(e.key), i(e.obj);\n        },\n        visitLiteralArray: function (e) {\n          r(e.expressions);\n        },\n        visitLiteralMap: function (e) {},\n        visitLiteralPrimitive: function (e) {},\n        visitMethodCall: function (e) {\n          i(e.receiver), r(e.args);\n        },\n        visitPipe: function (e) {\n          i(e.exp), r(e.args);\n        },\n        visitPrefixNot: function (e) {\n          i(e.expression);\n        },\n        visitNonNullAssert: function (e) {\n          i(e.expression);\n        },\n        visitPropertyRead: function (e) {\n          i(e.receiver);\n        },\n        visitPropertyWrite: function (e) {\n          i(e.receiver), i(e.value);\n        },\n        visitQuote: function (e) {},\n        visitSafeMethodCall: function (e) {\n          i(e.receiver), r(e.args);\n        },\n        visitSafePropertyRead: function (e) {\n          i(e.receiver);\n        }\n      });\n    },\n    ParsedProperty: function e(t, n, i, r) {\n      s(this, e), this.name = t, this.expression = n, this.type = i, this.sourceSpan = r, this.isLiteral = this.type === q.LITERAL_ATTR, this.isAnimation = this.type === q.ANIMATION;\n    },\n\n    get ParsedPropertyType() {\n      return q;\n    },\n\n    ParsedEvent: function e(t, n, i, r, a) {\n      s(this, e), this.name = t, this.targetOrPhase = n, this.type = i, this.handler = r, this.sourceSpan = a;\n    },\n    ParsedVariable: function e(t, n, i) {\n      s(this, e), this.name = t, this.value = n, this.sourceSpan = i;\n    },\n    BoundElementProperty: function e(t, n, i, r, a, o) {\n      s(this, e), this.name = t, this.type = n, this.securityContext = i, this.value = r, this.unit = a, this.sourceSpan = o;\n    }\n  }),\n      J = 0,\n      X = 9,\n      Y = 10,\n      Z = 11,\n      ee = 12,\n      te = 13,\n      ne = 32,\n      ie = 34,\n      re = 36,\n      se = 39,\n      ae = 43,\n      oe = 45,\n      ue = 48,\n      le = 57,\n      ce = 65,\n      he = 69,\n      pe = 90,\n      ve = 95,\n      fe = 97,\n      de = 101,\n      ye = 102,\n      xe = 110,\n      ge = 114,\n      ke = 116,\n      me = 118,\n      we = 122,\n      Ce = 160,\n      Pe = 96;\n\n  function be(e) {\n    return ue <= e && e <= le;\n  }\n\n  !function (e) {\n    e[e.Character = 0] = \"Character\", e[e.Identifier = 1] = \"Identifier\", e[e.Keyword = 2] = \"Keyword\", e[e.String = 3] = \"String\", e[e.Operator = 4] = \"Operator\", e[e.Number = 5] = \"Number\", e[e.Error = 6] = \"Error\";\n  }(D || (D = {}));\n\n  var Ee = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"],\n      Ae = function () {\n    function e() {\n      s(this, e);\n    }\n\n    return o(e, [{\n      key: \"tokenize\",\n      value: function (e) {\n        for (var t = new Le(e), n = [], i = t.scanToken(); null != i;) n.push(i), i = t.scanToken();\n\n        return n;\n      }\n    }]), e;\n  }(),\n      Se = function () {\n    function e(t, n, i, r) {\n      s(this, e), this.index = t, this.type = n, this.numValue = i, this.strValue = r;\n    }\n\n    return o(e, [{\n      key: \"isCharacter\",\n      value: function (e) {\n        return this.type == D.Character && this.numValue == e;\n      }\n    }, {\n      key: \"isNumber\",\n      value: function () {\n        return this.type == D.Number;\n      }\n    }, {\n      key: \"isString\",\n      value: function () {\n        return this.type == D.String;\n      }\n    }, {\n      key: \"isOperator\",\n      value: function (e) {\n        return this.type == D.Operator && this.strValue == e;\n      }\n    }, {\n      key: \"isIdentifier\",\n      value: function () {\n        return this.type == D.Identifier;\n      }\n    }, {\n      key: \"isKeyword\",\n      value: function () {\n        return this.type == D.Keyword;\n      }\n    }, {\n      key: \"isKeywordLet\",\n      value: function () {\n        return this.type == D.Keyword && \"let\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordAs\",\n      value: function () {\n        return this.type == D.Keyword && \"as\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordNull\",\n      value: function () {\n        return this.type == D.Keyword && \"null\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordUndefined\",\n      value: function () {\n        return this.type == D.Keyword && \"undefined\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordTrue\",\n      value: function () {\n        return this.type == D.Keyword && \"true\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordFalse\",\n      value: function () {\n        return this.type == D.Keyword && \"false\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordThis\",\n      value: function () {\n        return this.type == D.Keyword && \"this\" == this.strValue;\n      }\n    }, {\n      key: \"isError\",\n      value: function () {\n        return this.type == D.Error;\n      }\n    }, {\n      key: \"toNumber\",\n      value: function () {\n        return this.type == D.Number ? this.numValue : -1;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        switch (this.type) {\n          case D.Character:\n          case D.Identifier:\n          case D.Keyword:\n          case D.Operator:\n          case D.String:\n          case D.Error:\n            return this.strValue;\n\n          case D.Number:\n            return this.numValue.toString();\n\n          default:\n            return null;\n        }\n      }\n    }]), e;\n  }();\n\n  function Ne(e, t) {\n    return new Se(e, D.Character, t, String.fromCharCode(t));\n  }\n\n  function Oe(e, t) {\n    return new Se(e, D.Operator, 0, t);\n  }\n\n  var Ie = new Se(-1, D.Character, 0, \"\"),\n      Le = function () {\n    function e(t) {\n      s(this, e), this.input = t, this.peek = 0, this.index = -1, this.length = t.length, this.advance();\n    }\n\n    return o(e, [{\n      key: \"advance\",\n      value: function () {\n        this.peek = ++this.index >= this.length ? J : this.input.charCodeAt(this.index);\n      }\n    }, {\n      key: \"scanToken\",\n      value: function () {\n        for (var e = this.input, t = this.length, n = this.peek, i = this.index; n <= ne;) {\n          if (++i >= t) {\n            n = J;\n            break;\n          }\n\n          n = e.charCodeAt(i);\n        }\n\n        if (this.peek = n, this.index = i, i >= t) return null;\n        if (Me(n)) return this.scanIdentifier();\n        if (be(n)) return this.scanNumber(i);\n        var r,\n            s = i;\n\n        switch (n) {\n          case 46:\n            return this.advance(), be(this.peek) ? this.scanNumber(s) : Ne(s, 46);\n\n          case 40:\n          case 41:\n          case 123:\n          case 125:\n          case 91:\n          case 93:\n          case 44:\n          case 58:\n          case 59:\n            return this.scanCharacter(s, n);\n\n          case se:\n          case ie:\n            return this.scanString();\n\n          case 35:\n          case ae:\n          case oe:\n          case 42:\n          case 47:\n          case 37:\n          case 94:\n            return this.scanOperator(s, String.fromCharCode(n));\n\n          case 63:\n            return this.scanComplexOperator(s, \"?\", 46, \".\");\n\n          case 60:\n          case 62:\n            return this.scanComplexOperator(s, String.fromCharCode(n), 61, \"=\");\n\n          case 33:\n          case 61:\n            return this.scanComplexOperator(s, String.fromCharCode(n), 61, \"=\", 61, \"=\");\n\n          case 38:\n            return this.scanComplexOperator(s, \"&\", 38, \"&\");\n\n          case 124:\n            return this.scanComplexOperator(s, \"|\", 124, \"|\");\n\n          case Ce:\n            for (; (r = this.peek) >= X && r <= ne || r == Ce;) this.advance();\n\n            return this.scanToken();\n        }\n\n        return this.advance(), this.error(\"Unexpected character [\".concat(String.fromCharCode(n), \"]\"), 0);\n      }\n    }, {\n      key: \"scanCharacter\",\n      value: function (e, t) {\n        return this.advance(), Ne(e, t);\n      }\n    }, {\n      key: \"scanOperator\",\n      value: function (e, t) {\n        return this.advance(), Oe(e, t);\n      }\n    }, {\n      key: \"scanComplexOperator\",\n      value: function (e, t, n, i, r, s) {\n        this.advance();\n        var a = t;\n        return this.peek == n && (this.advance(), a += i), null != r && this.peek == r && (this.advance(), a += s), Oe(e, a);\n      }\n    }, {\n      key: \"scanIdentifier\",\n      value: function () {\n        var e = this.index;\n\n        for (this.advance(); Ke(this.peek);) this.advance();\n\n        var t,\n            n = this.input.substring(e, this.index);\n        return Ee.indexOf(n) > -1 ? (t = n, new Se(e, D.Keyword, 0, t)) : function (e, t) {\n          return new Se(e, D.Identifier, 0, t);\n        }(e, n);\n      }\n    }, {\n      key: \"scanNumber\",\n      value: function (e) {\n        var t,\n            n = this.index === e;\n\n        for (this.advance();;) {\n          if (be(this.peek)) ;else if (46 == this.peek) n = !1;else {\n            if ((t = this.peek) != de && t != he) break;\n            if (this.advance(), Te(this.peek) && this.advance(), !be(this.peek)) return this.error(\"Invalid exponent\", -1);\n            n = !1;\n          }\n          this.advance();\n        }\n\n        var i,\n            r = this.input.substring(e, this.index),\n            s = n ? function (e) {\n          var t = parseInt(e);\n          if (isNaN(t)) throw new Error(\"Invalid integer literal when parsing \" + e);\n          return t;\n        }(r) : parseFloat(r);\n        return i = s, new Se(e, D.Number, i, \"\");\n      }\n    }, {\n      key: \"scanString\",\n      value: function () {\n        var e = this.index,\n            t = this.peek;\n        this.advance();\n\n        for (var n = \"\", i = this.index, r = this.input; this.peek != t;) if (92 == this.peek) {\n          n += r.substring(i, this.index), this.advance();\n          var s = void 0;\n\n          if (this.peek = this.peek, 117 == this.peek) {\n            var a = r.substring(this.index + 1, this.index + 5);\n            if (!/^[0-9a-f]+$/i.test(a)) return this.error(\"Invalid unicode escape [\\\\u\".concat(a, \"]\"), 0);\n            s = parseInt(a, 16);\n\n            for (var o = 0; o < 5; o++) this.advance();\n          } else s = Re(this.peek), this.advance();\n\n          n += String.fromCharCode(s), i = this.index;\n        } else {\n          if (this.peek == J) return this.error(\"Unterminated quote\", 0);\n          this.advance();\n        }\n\n        var u,\n            l = r.substring(i, this.index);\n        return this.advance(), u = n + l, new Se(e, D.String, 0, u);\n      }\n    }, {\n      key: \"error\",\n      value: function (e, t) {\n        var n = this.index + t;\n        return function (e, t) {\n          return new Se(e, D.Error, 0, t);\n        }(n, \"Lexer Error: \".concat(e, \" at column \").concat(n, \" in expression [\").concat(this.input, \"]\"));\n      }\n    }]), e;\n  }();\n\n  function Me(e) {\n    return fe <= e && e <= we || ce <= e && e <= pe || e == ve || e == re;\n  }\n\n  function _e(e) {\n    if (0 == e.length) return !1;\n    var t = new Le(e);\n    if (!Me(t.peek)) return !1;\n\n    for (t.advance(); t.peek !== J;) {\n      if (!Ke(t.peek)) return !1;\n      t.advance();\n    }\n\n    return !0;\n  }\n\n  function Ke(e) {\n    return function (e) {\n      return e >= fe && e <= we || e >= ce && e <= pe;\n    }(e) || be(e) || e == ve || e == re;\n  }\n\n  function Te(e) {\n    return e == oe || e == ae;\n  }\n\n  function Be(e) {\n    return e === se || e === ie || e === Pe;\n  }\n\n  function Re(e) {\n    switch (e) {\n      case xe:\n        return Y;\n\n      case ye:\n        return ee;\n\n      case ge:\n        return te;\n\n      case ke:\n        return X;\n\n      case me:\n        return Z;\n\n      default:\n        return e;\n    }\n  }\n\n  var je = Object.freeze({\n    get TokenType() {\n      return D;\n    },\n\n    Lexer: Ae,\n    Token: Se,\n    EOF: Ie,\n    isIdentifier: _e,\n    isQuote: Be\n  }),\n      Fe = [/^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\//];\n  var Ve = new (function () {\n    function e(t, n) {\n      s(this, e), this.start = t, this.end = n;\n    }\n\n    return o(e, null, [{\n      key: \"fromArray\",\n      value: function (t) {\n        return t ? (function (e, t) {\n          if (!(null == t || Array.isArray(t) && 2 == t.length)) throw new Error(\"Expected '\".concat(e, \"' to be an array, [start, end].\"));\n\n          if (null != t) {\n            var n = t[0],\n                i = t[1];\n            Fe.forEach(function (e) {\n              if (e.test(n) || e.test(i)) throw new Error(\"['\".concat(n, \"', '\").concat(i, \"'] contains unusable interpolation symbol.\"));\n            });\n          }\n        }(\"interpolation\", t), new e(t[0], t[1])) : Ve;\n      }\n    }]), e;\n  }())(\"{{\", \"}}\");\n\n  function Ge(e) {\n    return e.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n  }\n\n  Object.getPrototypeOf({});\n\n  var We = function e(t, n, i) {\n    s(this, e), this.strings = t, this.expressions = n, this.offsets = i;\n  },\n      Ue = function e(t, n, i) {\n    s(this, e), this.templateBindings = t, this.warnings = n, this.errors = i;\n  };\n\n  function Qe(e) {\n    var t = Ge(e.start) + \"([\\\\s\\\\S]*?)\" + Ge(e.end);\n    return new RegExp(t, \"g\");\n  }\n\n  var ze = function () {\n    function e(t) {\n      s(this, e), this._lexer = t, this.errors = [];\n    }\n\n    return o(e, [{\n      key: \"parseAction\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve;\n\n        this._checkNoInterpolation(e, t, n);\n\n        var i = this._stripComments(e),\n            r = this._lexer.tokenize(this._stripComments(e)),\n            s = new $e(e, t, r, i.length, !0, this.errors, e.length - i.length).parseChain();\n\n        return new G(s, e, t, this.errors);\n      }\n    }, {\n      key: \"parseBinding\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve,\n            i = this._parseBindingAst(e, t, n);\n\n        return new G(i, e, t, this.errors);\n      }\n    }, {\n      key: \"parseSimpleBinding\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve,\n            i = this._parseBindingAst(e, t, n),\n            r = qe.check(i);\n\n        return r.length > 0 && this._reportError(\"Host binding expression cannot contain \".concat(r.join(\" \")), e, t), new G(i, e, t, this.errors);\n      }\n    }, {\n      key: \"_reportError\",\n      value: function (e, t, n, i) {\n        this.errors.push(new x(e, t, n, i));\n      }\n    }, {\n      key: \"_parseBindingAst\",\n      value: function (e, t, n) {\n        var i = this._parseQuote(e, t);\n\n        if (null != i) return i;\n\n        this._checkNoInterpolation(e, t, n);\n\n        var r = this._stripComments(e),\n            s = this._lexer.tokenize(r);\n\n        return new $e(e, t, s, r.length, !1, this.errors, e.length - r.length).parseChain();\n      }\n    }, {\n      key: \"_parseQuote\",\n      value: function (e, t) {\n        if (null == e) return null;\n        var n = e.indexOf(\":\");\n        if (-1 == n) return null;\n        var i = e.substring(0, n).trim();\n        if (!_e(i)) return null;\n        var r = e.substring(n + 1);\n        return new m(new g(0, e.length), i, r, t);\n      }\n    }, {\n      key: \"parseTemplateBindings\",\n      value: function (e, t, n) {\n        var i = this._lexer.tokenize(t);\n\n        return new $e(t, n, i, t.length, !1, this.errors, 0).parseTemplateBindings(e);\n      }\n    }, {\n      key: \"parseInterpolation\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve,\n            i = this.splitInterpolation(e, t, n);\n        if (null == i) return null;\n\n        for (var r = [], s = 0; s < i.expressions.length; ++s) {\n          var a = i.expressions[s],\n              o = this._stripComments(a),\n              u = this._lexer.tokenize(o),\n              l = new $e(e, t, u, o.length, !1, this.errors, i.offsets[s] + (a.length - o.length)).parseChain();\n\n          r.push(l);\n        }\n\n        return new G(new K(new g(0, null == e ? 0 : e.length), i.strings, r), e, t, this.errors);\n      }\n    }, {\n      key: \"splitInterpolation\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve,\n            i = Qe(n),\n            r = e.split(i);\n        if (r.length <= 1) return null;\n\n        for (var s = [], a = [], o = [], u = 0, l = 0; l < r.length; l++) {\n          var c = r[l];\n          l % 2 == 0 ? (s.push(c), u += c.length) : c.trim().length > 0 ? (u += n.start.length, a.push(c), o.push(u), u += c.length + n.end.length) : (this._reportError(\"Blank expressions are not allowed in interpolated strings\", e, \"at column \".concat(this._findInterpolationErrorColumn(r, l, n), \" in\"), t), a.push(\"$implict\"), o.push(u));\n        }\n\n        return new We(s, a, o);\n      }\n    }, {\n      key: \"wrapLiteralPrimitive\",\n      value: function (e, t) {\n        return new G(new L(new g(0, null == e ? 0 : e.length), e), e, t, this.errors);\n      }\n    }, {\n      key: \"_stripComments\",\n      value: function (e) {\n        var t = this._commentStart(e);\n\n        return null != t ? e.substring(0, t).trim() : e;\n      }\n    }, {\n      key: \"_commentStart\",\n      value: function (e) {\n        for (var t = null, n = 0; n < e.length - 1; n++) {\n          var i = e.charCodeAt(n),\n              r = e.charCodeAt(n + 1);\n          if (47 === i && 47 == r && null == t) return n;\n          t === i ? t = null : null == t && Be(i) && (t = i);\n        }\n\n        return null;\n      }\n    }, {\n      key: \"_checkNoInterpolation\",\n      value: function (e, t, n) {\n        var i = Qe(n),\n            r = e.split(i);\n        r.length > 1 && this._reportError(\"Got interpolation (\".concat(n.start).concat(n.end, \") where expression was expected\"), e, \"at column \".concat(this._findInterpolationErrorColumn(r, 1, n), \" in\"), t);\n      }\n    }, {\n      key: \"_findInterpolationErrorColumn\",\n      value: function (e, t, n) {\n        for (var i = \"\", r = 0; r < t; r++) i += r % 2 == 0 ? e[r] : \"\".concat(n.start).concat(e[r]).concat(n.end);\n\n        return i.length;\n      }\n    }]), e;\n  }(),\n      $e = function () {\n    function e(t, n, i, r, a, o, u) {\n      s(this, e), this.input = t, this.location = n, this.tokens = i, this.inputLength = r, this.parseAction = a, this.errors = o, this.offset = u, this.rparensExpected = 0, this.rbracketsExpected = 0, this.rbracesExpected = 0, this.index = 0;\n    }\n\n    return o(e, [{\n      key: \"peek\",\n      value: function (e) {\n        var t = this.index + e;\n        return t < this.tokens.length ? this.tokens[t] : Ie;\n      }\n    }, {\n      key: \"span\",\n      value: function (e) {\n        return new g(e, this.inputIndex);\n      }\n    }, {\n      key: \"advance\",\n      value: function () {\n        this.index++;\n      }\n    }, {\n      key: \"optionalCharacter\",\n      value: function (e) {\n        return !!this.next.isCharacter(e) && (this.advance(), !0);\n      }\n    }, {\n      key: \"peekKeywordLet\",\n      value: function () {\n        return this.next.isKeywordLet();\n      }\n    }, {\n      key: \"peekKeywordAs\",\n      value: function () {\n        return this.next.isKeywordAs();\n      }\n    }, {\n      key: \"expectCharacter\",\n      value: function (e) {\n        this.optionalCharacter(e) || this.error(\"Missing expected \".concat(String.fromCharCode(e)));\n      }\n    }, {\n      key: \"optionalOperator\",\n      value: function (e) {\n        return !!this.next.isOperator(e) && (this.advance(), !0);\n      }\n    }, {\n      key: \"expectOperator\",\n      value: function (e) {\n        this.optionalOperator(e) || this.error(\"Missing expected operator \".concat(e));\n      }\n    }, {\n      key: \"expectIdentifierOrKeyword\",\n      value: function () {\n        var e = this.next;\n        return e.isIdentifier() || e.isKeyword() ? (this.advance(), e.toString()) : (this.error(\"Unexpected token \".concat(e, \", expected identifier or keyword\")), \"\");\n      }\n    }, {\n      key: \"expectIdentifierOrKeywordOrString\",\n      value: function () {\n        var e = this.next;\n        return e.isIdentifier() || e.isKeyword() || e.isString() ? (this.advance(), e.toString()) : (this.error(\"Unexpected token \".concat(e, \", expected identifier, keyword, or string\")), \"\");\n      }\n    }, {\n      key: \"parseChain\",\n      value: function () {\n        for (var e = [], t = this.inputIndex; this.index < this.tokens.length;) {\n          var n = this.parsePipe();\n          if (e.push(n), this.optionalCharacter(59)) for (this.parseAction || this.error(\"Binding expression cannot contain chained expression\"); this.optionalCharacter(59););else this.index < this.tokens.length && this.error(\"Unexpected token '\".concat(this.next, \"'\"));\n        }\n\n        return 0 == e.length ? new w(this.span(t)) : 1 == e.length ? e[0] : new P(this.span(t), e);\n      }\n    }, {\n      key: \"parsePipe\",\n      value: function () {\n        var e = this.parseExpression();\n\n        if (this.optionalOperator(\"|\")) {\n          this.parseAction && this.error(\"Cannot have a pipe in an action expression\");\n\n          do {\n            for (var t = this.expectIdentifierOrKeyword(), n = []; this.optionalCharacter(58);) n.push(this.parseExpression());\n\n            e = new I(this.span(e.span.start), e, t, n);\n          } while (this.optionalOperator(\"|\"));\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseExpression\",\n      value: function () {\n        return this.parseConditional();\n      }\n    }, {\n      key: \"parseConditional\",\n      value: function () {\n        var e = this.inputIndex,\n            t = this.parseLogicalOr();\n\n        if (this.optionalOperator(\"?\")) {\n          var n,\n              i = this.parsePipe();\n          if (this.optionalCharacter(58)) n = this.parsePipe();else {\n            var r = this.inputIndex,\n                s = this.input.substring(e, r);\n            this.error(\"Conditional expression \".concat(s, \" requires all 3 expressions\")), n = new w(this.span(e));\n          }\n          return new b(this.span(e), t, i, n);\n        }\n\n        return t;\n      }\n    }, {\n      key: \"parseLogicalOr\",\n      value: function () {\n        for (var e = this.parseLogicalAnd(); this.optionalOperator(\"||\");) {\n          var t = this.parseLogicalAnd();\n          e = new T(this.span(e.span.start), \"||\", e, t);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseLogicalAnd\",\n      value: function () {\n        for (var e = this.parseEquality(); this.optionalOperator(\"&&\");) {\n          var t = this.parseEquality();\n          e = new T(this.span(e.span.start), \"&&\", e, t);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseEquality\",\n      value: function () {\n        for (var e = this.parseRelational(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"==\":\n            case \"===\":\n            case \"!=\":\n            case \"!==\":\n              this.advance();\n              var n = this.parseRelational();\n              e = new T(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseRelational\",\n      value: function () {\n        for (var e = this.parseAdditive(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"<\":\n            case \">\":\n            case \"<=\":\n            case \">=\":\n              this.advance();\n              var n = this.parseAdditive();\n              e = new T(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseAdditive\",\n      value: function () {\n        for (var e = this.parseMultiplicative(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"+\":\n            case \"-\":\n              this.advance();\n              var n = this.parseMultiplicative();\n              e = new T(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseMultiplicative\",\n      value: function () {\n        for (var e = this.parsePrefix(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"*\":\n            case \"%\":\n            case \"/\":\n              this.advance();\n              var n = this.parsePrefix();\n              e = new T(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parsePrefix\",\n      value: function () {\n        if (this.next.type == D.Operator) {\n          var e,\n              t = this.inputIndex,\n              n = this.next.strValue;\n\n          switch (n) {\n            case \"+\":\n              return this.advance(), e = this.parsePrefix(), new T(this.span(t), \"-\", e, new L(new g(t, t), 0));\n\n            case \"-\":\n              return this.advance(), e = this.parsePrefix(), new T(this.span(t), n, new L(new g(t, t), 0), e);\n\n            case \"!\":\n              return this.advance(), e = this.parsePrefix(), new B(this.span(t), e);\n          }\n        }\n\n        return this.parseCallChain();\n      }\n    }, {\n      key: \"parseCallChain\",\n      value: function () {\n        for (var e = this.parsePrimary();;) if (this.optionalCharacter(46)) e = this.parseAccessMemberOrMethodCall(e, !1);else if (this.optionalOperator(\"?.\")) e = this.parseAccessMemberOrMethodCall(e, !0);else if (this.optionalCharacter(91)) {\n          this.rbracketsExpected++;\n          var t = this.parsePipe();\n\n          if (this.rbracketsExpected--, this.expectCharacter(93), this.optionalOperator(\"=\")) {\n            var n = this.parseConditional();\n            e = new O(this.span(e.span.start), e, t, n);\n          } else e = new N(this.span(e.span.start), e, t);\n        } else if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var i = this.parseCallArguments();\n          this.rparensExpected--, this.expectCharacter(41), e = new V(this.span(e.span.start), e, i);\n        } else {\n          if (!this.optionalOperator(\"!\")) return e;\n          e = new R(this.span(e.span.start), e);\n        }\n      }\n    }, {\n      key: \"parsePrimary\",\n      value: function () {\n        var e = this.inputIndex;\n\n        if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var t = this.parsePipe();\n          return this.rparensExpected--, this.expectCharacter(41), t;\n        }\n\n        if (this.next.isKeywordNull()) return this.advance(), new L(this.span(e), null);\n        if (this.next.isKeywordUndefined()) return this.advance(), new L(this.span(e), void 0);\n        if (this.next.isKeywordTrue()) return this.advance(), new L(this.span(e), !0);\n        if (this.next.isKeywordFalse()) return this.advance(), new L(this.span(e), !1);\n        if (this.next.isKeywordThis()) return this.advance(), new C(this.span(e));\n\n        if (this.optionalCharacter(91)) {\n          this.rbracketsExpected++;\n          var n = this.parseExpressionList(93);\n          return this.rbracketsExpected--, this.expectCharacter(93), new M(this.span(e), n);\n        }\n\n        if (this.next.isCharacter(123)) return this.parseLiteralMap();\n        if (this.next.isIdentifier()) return this.parseAccessMemberOrMethodCall(new C(this.span(e)), !1);\n\n        if (this.next.isNumber()) {\n          var i = this.next.toNumber();\n          return this.advance(), new L(this.span(e), i);\n        }\n\n        if (this.next.isString()) {\n          var r = this.next.toString();\n          return this.advance(), new L(this.span(e), r);\n        }\n\n        return this.index >= this.tokens.length ? (this.error(\"Unexpected end of expression: \".concat(this.input)), new w(this.span(e))) : (this.error(\"Unexpected token \".concat(this.next)), new w(this.span(e)));\n      }\n    }, {\n      key: \"parseExpressionList\",\n      value: function (e) {\n        var t = [];\n        if (!this.next.isCharacter(e)) do {\n          t.push(this.parsePipe());\n        } while (this.optionalCharacter(44));\n        return t;\n      }\n    }, {\n      key: \"parseLiteralMap\",\n      value: function () {\n        var e = [],\n            t = [],\n            n = this.inputIndex;\n\n        if (this.expectCharacter(123), !this.optionalCharacter(125)) {\n          this.rbracesExpected++;\n\n          do {\n            var i = this.next.isString(),\n                r = this.expectIdentifierOrKeywordOrString();\n            e.push({\n              key: r,\n              quoted: i\n            }), this.expectCharacter(58), t.push(this.parsePipe());\n          } while (this.optionalCharacter(44));\n\n          this.rbracesExpected--, this.expectCharacter(125);\n        }\n\n        return new _(this.span(n), e, t);\n      }\n    }, {\n      key: \"parseAccessMemberOrMethodCall\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            n = e.span.start,\n            i = this.expectIdentifierOrKeyword();\n\n        if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var r = this.parseCallArguments();\n          this.expectCharacter(41), this.rparensExpected--;\n          var s = this.span(n);\n          return t ? new F(s, e, i, r) : new j(s, e, i, r);\n        }\n\n        if (t) return this.optionalOperator(\"=\") ? (this.error(\"The '?.' operator cannot be used in the assignment\"), new w(this.span(n))) : new S(this.span(n), e, i);\n\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) return this.error(\"Bindings cannot contain assignments\"), new w(this.span(n));\n          var a = this.parseConditional();\n          return new A(this.span(n), e, i, a);\n        }\n\n        return new E(this.span(n), e, i);\n      }\n    }, {\n      key: \"parseCallArguments\",\n      value: function () {\n        if (this.next.isCharacter(41)) return [];\n        var e = [];\n\n        do {\n          e.push(this.parsePipe());\n        } while (this.optionalCharacter(44));\n\n        return e;\n      }\n    }, {\n      key: \"expectTemplateBindingKey\",\n      value: function () {\n        var e = \"\",\n            t = !1;\n\n        do {\n          e += this.expectIdentifierOrKeywordOrString(), (t = this.optionalOperator(\"-\")) && (e += \"-\");\n        } while (t);\n\n        return e.toString();\n      }\n    }, {\n      key: \"parseTemplateBindings\",\n      value: function (e) {\n        var t = !0,\n            n = [];\n\n        do {\n          var i = this.inputIndex,\n              r = void 0,\n              s = void 0,\n              a = !1;\n          t ? (r = s = e, t = !1) : ((a = this.peekKeywordLet()) && this.advance(), r = this.expectTemplateBindingKey(), s = a ? r : e + r[0].toUpperCase() + r.substring(1), this.optionalCharacter(58));\n          var o = null,\n              u = null;\n          if (a) o = this.optionalOperator(\"=\") ? this.expectTemplateBindingKey() : \"$implicit\";else if (this.peekKeywordAs()) this.advance(), o = r, s = this.expectTemplateBindingKey(), a = !0;else if (this.next !== Ie && !this.peekKeywordLet()) {\n            var l = this.inputIndex,\n                c = this.parsePipe(),\n                h = this.input.substring(l - this.offset, this.inputIndex - this.offset);\n            u = new G(c, h, this.location, this.errors);\n          }\n\n          if (n.push(new W(this.span(i), s, a, o, u)), this.peekKeywordAs() && !a) {\n            var p = this.inputIndex;\n            this.advance();\n            var v = this.expectTemplateBindingKey();\n            n.push(new W(this.span(p), v, !0, s, null));\n          }\n\n          this.optionalCharacter(59) || this.optionalCharacter(44);\n        } while (this.index < this.tokens.length);\n\n        return new Ue(n, [], this.errors);\n      }\n    }, {\n      key: \"error\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        this.errors.push(new x(e, this.input, this.locationText(t), this.location)), this.skip();\n      }\n    }, {\n      key: \"locationText\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;\n        return null == e && (e = this.index), e < this.tokens.length ? \"at column \".concat(this.tokens[e].index + 1, \" in\") : \"at the end of the expression\";\n      }\n    }, {\n      key: \"skip\",\n      value: function () {\n        for (var e = this.next; this.index < this.tokens.length && !e.isCharacter(59) && (this.rparensExpected <= 0 || !e.isCharacter(41)) && (this.rbracesExpected <= 0 || !e.isCharacter(125)) && (this.rbracketsExpected <= 0 || !e.isCharacter(93));) this.next.isError() && this.errors.push(new x(this.next.toString(), this.input, this.locationText(), this.location)), this.advance(), e = this.next;\n      }\n    }, {\n      key: \"next\",\n      get: function () {\n        return this.peek(0);\n      }\n    }, {\n      key: \"inputIndex\",\n      get: function () {\n        return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n      }\n    }]), e;\n  }(),\n      qe = function () {\n    function e() {\n      s(this, e), this.errors = [];\n    }\n\n    return o(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        this.visitAll(e.expressions);\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        this.visitAll(e.values);\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        this.errors.push(\"pipes\");\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        var t = this;\n        return e.map(function (e) {\n          return e.visit(t);\n        });\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {}\n    }], [{\n      key: \"check\",\n      value: function (t) {\n        var n = new e();\n        return t.visit(n), n.errors;\n      }\n    }]), e;\n  }(),\n      De = Object.freeze({\n    SplitInterpolation: We,\n    TemplateBindingParseResult: Ue,\n    Parser: ze,\n    _ParseAST: $e\n  }),\n      He = i(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    var n = \"angular-estree-parser\",\n        i = \"NgEstreeParser\";\n\n    function s() {\n      return new De.Parser(new je.Lexer());\n    }\n\n    function a(e, t) {\n      var n = s(),\n          i = u(e, n),\n          r = i.astInput,\n          a = i.comments,\n          l = t(r, n),\n          c = l.ast;\n      return o(l.errors), {\n        ast: c,\n        comments: a\n      };\n    }\n\n    function o(e) {\n      if (0 !== e.length) {\n        var t = p(e, 1)[0].message;\n        throw new SyntaxError(t.replace(/^Parser Error: | at column \\d+ in [^]*$/g, \"\"));\n      }\n    }\n\n    function u(e, t) {\n      var n = t._commentStart(e);\n\n      return null === n ? {\n        astInput: e,\n        comments: []\n      } : {\n        astInput: e.slice(0, n),\n        comments: [{\n          type: \"Comment\",\n          value: e.slice(n + \"//\".length),\n          span: {\n            start: n,\n            end: e.length\n          }\n        }]\n      };\n    }\n\n    function l(e, t) {\n      for (var n = e.start, i = e.end; i !== n && /\\s/.test(t[i - 1]);) i--;\n\n      for (; n !== i && /\\s/.test(t[n]);) n++;\n\n      return {\n        start: n,\n        end: i\n      };\n    }\n\n    function c(e, t) {\n      for (var n = e.start, i = e.end; i !== t.length && /\\s/.test(t[i]);) i++;\n\n      for (; 0 !== n && /\\s/.test(t[n - 1]);) n--;\n\n      return {\n        start: n,\n        end: i\n      };\n    }\n\n    function h(e, t) {\n      return \"(\" === t[e.start - 1] && \")\" === t[e.end] ? {\n        start: e.start - 1,\n        end: e.end + 1\n      } : e;\n    }\n\n    t.parseNgBinding = function (e) {\n      return a(e, function (e, t) {\n        return t.parseBinding(e, n);\n      });\n    }, t.parseNgSimpleBinding = function (e) {\n      return a(e, function (e, t) {\n        return t.parseSimpleBinding(e, n);\n      });\n    }, t.parseNgAction = function (e) {\n      return a(e, function (e, t) {\n        return t.parseAction(e, n);\n      });\n    }, t.parseNgTemplateBindings = function (e) {\n      var t = s().parseTemplateBindings(i, e, n),\n          r = t.templateBindings;\n      return o(t.errors), r;\n    }, t.parseNgInterpolation = function (e) {\n      var t = s(),\n          i = u(e, t),\n          a = i.astInput,\n          l = i.comments,\n          c = t.parseInterpolation(\"{{\" + a + \"}}\", n),\n          h = c.ast;\n      o(c.errors);\n      var p = h.expressions[0];\n      return function e(t, n) {\n        if (t && \"object\" === r(t)) {\n          if (Array.isArray(t)) return t.forEach(function (t) {\n            return e(t, n);\n          });\n\n          for (var i = Object.keys(t), s = 0; s < i.length; s++) {\n            var a = i[s],\n                o = t[a];\n            \"span\" === a ? n(o) : e(o, n);\n          }\n        }\n      }(p, function (e) {\n        e.start -= \"{{\".length, e.end -= \"{{\".length;\n      }), {\n        ast: p,\n        comments: l\n      };\n    }, t.getNgType = function (e) {\n      return e instanceof H.Binary ? \"Binary\" : e instanceof H.BindingPipe ? \"BindingPipe\" : e instanceof H.Chain ? \"Chain\" : e instanceof H.Conditional ? \"Conditional\" : e instanceof H.EmptyExpr ? \"EmptyExpr\" : e instanceof H.FunctionCall ? \"FunctionCall\" : e instanceof H.ImplicitReceiver ? \"ImplicitReceiver\" : e instanceof H.KeyedRead ? \"KeyedRead\" : e instanceof H.KeyedWrite ? \"KeyedWrite\" : e instanceof H.LiteralArray ? \"LiteralArray\" : e instanceof H.LiteralMap ? \"LiteralMap\" : e instanceof H.LiteralPrimitive ? \"LiteralPrimitive\" : e instanceof H.MethodCall ? \"MethodCall\" : e instanceof H.NonNullAssert ? \"NonNullAssert\" : e instanceof H.PrefixNot ? \"PrefixNot\" : e instanceof H.PropertyRead ? \"PropertyRead\" : e instanceof H.PropertyWrite ? \"PropertyWrite\" : e instanceof H.Quote ? \"Quote\" : e instanceof H.SafeMethodCall ? \"SafeMethodCall\" : e instanceof H.SafePropertyRead ? \"SafePropertyRead\" : e.type;\n    }, t.fitSpans = function (e, t, n) {\n      for (var i = 0, r = {\n        start: e.start,\n        end: e.end\n      };;) {\n        var s = c(r, t),\n            a = h(s, t);\n        if (s.start === a.start && s.end === a.end) break;\n        r.start = a.start, r.end = a.end, i++;\n      }\n\n      return {\n        hasParens: 0 !== (n ? i - 1 : i),\n        outerSpan: l(n ? {\n          start: r.start + 1,\n          end: r.end - 1\n        } : r, t),\n        innerSpan: l(e, t)\n      };\n    }, t.findFrontChar = function (e, t, n) {\n      for (var i = t; !e.test(n[i]);) i--;\n\n      return i;\n    }, t.findBackChar = function (e, t, n) {\n      for (var i = t; !e.test(n[i]);) i++;\n\n      return i;\n    }, t.toLowerCamelCase = function (e) {\n      return e.slice(0, 1).toLowerCase() + e.slice(1);\n    }, t.getLast = function (e) {\n      return 0 === e.length ? void 0 : e[e.length - 1];\n    };\n  });\n\n  n(He);\n  var Je = i(function (e, t) {\n    function n(e, t, n, i) {\n      if (!n) {\n        var r = e.start,\n            s = e.end;\n        return {\n          start: r,\n          end: s,\n          loc: {\n            start: t.locator.locationForIndex(r),\n            end: t.locator.locationForIndex(s)\n          }\n        };\n      }\n\n      var a = He.fitSpans(e, t.text, i),\n          o = a.outerSpan,\n          u = a.innerSpan,\n          l = a.hasParens;\n      return Object.assign({\n        start: u.start,\n        end: u.end,\n        loc: {\n          start: t.locator.locationForIndex(u.start),\n          end: t.locator.locationForIndex(u.end)\n        }\n      }, l && {\n        extra: {\n          parenthesized: !0,\n          parenStart: o.start,\n          parenEnd: o.end\n        }\n      });\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.transform = function (e, i) {\n      var s = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          a = He.getNgType(e);\n\n      switch (a) {\n        case \"Binary\":\n          var o = e.left,\n              u = e.operation,\n              l = e.right,\n              c = l.span.start === l.span.end,\n              h = o.span.start === o.span.end;\n\n          if (c || h) {\n            var p = o.span.start === o.span.end ? le(l) : le(o);\n            return he(\"UnaryExpression\", {\n              prefix: !0,\n              argument: p,\n              operator: c ? \"+\" : \"-\"\n            }, {\n              start: e.span.start,\n              end: ge(p)\n            }, {\n              hasParentParens: s\n            });\n          }\n\n          var v = le(o),\n              f = le(l);\n          return he(\"&&\" === u || \"||\" === u ? \"LogicalExpression\" : \"BinaryExpression\", {\n            left: v,\n            right: f,\n            operator: u\n          }, {\n            start: xe(v),\n            end: ge(f)\n          }, {\n            hasParentParens: s\n          });\n\n        case \"BindingPipe\":\n          var d = e.exp,\n              y = e.name,\n              x = e.args,\n              g = le(d),\n              k = fe(/\\S/, fe(/\\|/, ge(g)) + 1),\n              m = he(\"Identifier\", {\n            name: y\n          }, {\n            start: k,\n            end: k + y.length\n          }),\n              w = x.map(le);\n          return he(\"NGPipeExpression\", {\n            left: g,\n            right: m,\n            arguments: w\n          }, {\n            start: xe(g),\n            end: ge(0 === w.length ? m : He.getLast(w))\n          }, {\n            hasParentParens: s\n          });\n\n        case \"Chain\":\n          return he(\"NGChainedExpression\", {\n            expressions: e.expressions.map(le)\n          }, e.span, {\n            hasParentParens: s\n          });\n\n        case \"Comment\":\n          return he(\"CommentLine\", {\n            value: e.value\n          }, e.span, {\n            processSpan: !1\n          });\n\n        case \"Conditional\":\n          var C = e.condition,\n              P = e.trueExp,\n              b = e.falseExp,\n              E = le(C),\n              A = le(P),\n              S = le(b);\n          return he(\"ConditionalExpression\", {\n            test: E,\n            consequent: A,\n            alternate: S\n          }, {\n            start: xe(E),\n            end: ge(S)\n          }, {\n            hasParentParens: s\n          });\n\n        case \"EmptyExpr\":\n          return he(\"NGEmptyExpression\", {}, e.span, {\n            hasParentParens: s\n          });\n\n        case \"FunctionCall\":\n          var N = e.target,\n              O = e.args,\n              I = 1 === O.length ? [ce(O[0])] : O.map(le),\n              L = le(N);\n          return he(\"CallExpression\", {\n            callee: L,\n            arguments: I\n          }, {\n            start: xe(L),\n            end: e.span.end\n          }, {\n            hasParentParens: s\n          });\n\n        case \"KeyedRead\":\n          var M = e.obj,\n              _ = e.key,\n              K = le(M);\n          return he(\"MemberExpression\", {\n            computed: !0,\n            object: K,\n            property: le(_)\n          }, {\n            start: xe(K),\n            end: e.span.end\n          }, {\n            hasParentParens: s\n          });\n\n        case \"LiteralArray\":\n          return he(\"ArrayExpression\", {\n            elements: e.expressions.map(le)\n          }, e.span, {\n            hasParentParens: s\n          });\n\n        case \"LiteralMap\":\n          var T = e.keys,\n              B = e.values.map(function (e) {\n            return le(e);\n          });\n          return he(\"ObjectExpression\", {\n            properties: T.map(function (t, n) {\n              var i = t.key,\n                  r = t.quoted,\n                  s = B[n],\n                  a = {\n                start: fe(/\\S/, 0 === n ? e.span.start + 1 : fe(/,/, ge(B[n - 1])) + 1),\n                end: ve(/\\S/, ve(/:/, xe(s) - 1) - 1) + 1\n              },\n                  o = r ? he(\"StringLiteral\", {\n                value: i\n              }, a) : he(\"Identifier\", {\n                name: i\n              }, a);\n              return he(\"ObjectProperty\", {\n                key: o,\n                value: s,\n                method: !1,\n                shorthand: !1,\n                computed: !1\n              }, {\n                start: xe(o),\n                end: ge(s)\n              });\n            })\n          }, e.span, {\n            hasParentParens: s\n          });\n\n        case \"LiteralPrimitive\":\n          var R = e.value;\n\n          switch (r(R)) {\n            case \"boolean\":\n              return he(\"BooleanLiteral\", {\n                value: R\n              }, e.span, {\n                hasParentParens: s\n              });\n\n            case \"number\":\n              return he(\"NumericLiteral\", {\n                value: R\n              }, e.span, {\n                hasParentParens: s\n              });\n\n            case \"object\":\n              return he(\"NullLiteral\", {}, e.span, {\n                hasParentParens: s\n              });\n\n            case \"string\":\n              return he(\"StringLiteral\", {\n                value: R\n              }, e.span, {\n                hasParentParens: s\n              });\n\n            case \"undefined\":\n              return he(\"Identifier\", {\n                name: \"undefined\"\n              }, e.span, {\n                hasParentParens: s\n              });\n\n            default:\n              throw new Error(\"Unexpected LiteralPrimitive value type \".concat(r(R)));\n          }\n\n        case \"MethodCall\":\n        case \"SafeMethodCall\":\n          var j = \"SafeMethodCall\" === a,\n              F = e.receiver,\n              V = e.name,\n              G = e.args,\n              W = 1 === G.length ? [ce(G[0])] : G.map(le),\n              U = ve(/\\S/, ve(/\\(/, (0 === W.length ? ve(/\\)/, e.span.end - 1) : xe(W[0])) - 1) - 1) + 1,\n              Q = pe(F, he(\"Identifier\", {\n            name: V\n          }, {\n            start: U - V.length,\n            end: U\n          }), {\n            computed: !1,\n            optional: j\n          }),\n              z = de(Q);\n          return he(j || z ? \"OptionalCallExpression\" : \"CallExpression\", {\n            callee: Q,\n            arguments: W\n          }, {\n            start: xe(Q),\n            end: e.span.end\n          }, {\n            hasParentParens: s\n          });\n\n        case \"NonNullAssert\":\n          var $ = le(e.expression);\n          return he(\"TSNonNullExpression\", {\n            expression: $\n          }, {\n            start: xe($),\n            end: e.span.end\n          }, {\n            hasParentParens: s\n          });\n\n        case \"PrefixNot\":\n          var q = le(e.expression);\n          return he(\"UnaryExpression\", {\n            prefix: !0,\n            operator: \"!\",\n            argument: q\n          }, {\n            start: e.span.start,\n            end: ge(q)\n          }, {\n            hasParentParens: s\n          });\n\n        case \"PropertyRead\":\n        case \"SafePropertyRead\":\n          var D = \"SafePropertyRead\" === a,\n              H = e.receiver,\n              J = e.name,\n              X = ve(/\\S/, e.span.end - 1) + 1;\n          return pe(H, he(\"Identifier\", {\n            name: J\n          }, {\n            start: X - J.length,\n            end: X\n          }, H.span.start === H.span.end ? {\n            hasParentParens: s\n          } : {}), {\n            computed: !1,\n            optional: D\n          }, {\n            hasParentParens: s\n          });\n\n        case \"KeyedWrite\":\n          var Y = e.obj,\n              Z = e.key,\n              ee = e.value,\n              te = le(Z),\n              ne = le(ee),\n              ie = pe(Y, te, {\n            computed: !0,\n            optional: !1\n          }, {\n            end: fe(/\\]/, ge(te)) + 1\n          });\n          return he(\"AssignmentExpression\", {\n            left: ie,\n            operator: \"=\",\n            right: ne\n          }, {\n            start: xe(ie),\n            end: ge(ne)\n          }, {\n            hasParentParens: s\n          });\n\n        case \"PropertyWrite\":\n          var re = e.receiver,\n              se = e.name,\n              ae = le(e.value),\n              oe = ve(/\\S/, ve(/=/, xe(ae) - 1) - 1) + 1,\n              ue = pe(re, he(\"Identifier\", {\n            name: se\n          }, {\n            start: oe - se.length,\n            end: oe\n          }), {\n            computed: !1,\n            optional: !1\n          });\n          return he(\"AssignmentExpression\", {\n            left: ue,\n            operator: \"=\",\n            right: ae\n          }, {\n            start: xe(ue),\n            end: ge(ae)\n          }, {\n            hasParentParens: s\n          });\n\n        case \"Quote\":\n          return he(\"NGQuotedExpression\", {\n            prefix: e.prefix,\n            value: e.uninterpretedExpression\n          }, e.span, {\n            hasParentParens: s\n          });\n\n        default:\n          throw new Error(\"Unexpected node \".concat(a));\n      }\n\n      function le(e) {\n        return t.transform(e, i);\n      }\n\n      function ce(e) {\n        return t.transform(e, i, !0);\n      }\n\n      function he(e, t, r) {\n        var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            a = s.processSpan,\n            o = void 0 === a || a,\n            u = s.hasParentParens,\n            l = void 0 !== u && u,\n            c = Object.assign({\n          type: e\n        }, n(r, i, o, l), t);\n\n        switch (e) {\n          case \"Identifier\":\n            var h = c;\n            h.loc.identifierName = h.name;\n            break;\n\n          case \"NumericLiteral\":\n            var p = c;\n            p.extra = Object.assign({}, p.extra, {\n              raw: i.text.slice(p.start, p.end),\n              rawValue: p.value\n            });\n            break;\n\n          case \"StringLiteral\":\n            var v = c;\n            v.extra = Object.assign({}, v.extra, {\n              raw: i.text.slice(v.start, v.end),\n              rawValue: v.value\n            });\n        }\n\n        return c;\n      }\n\n      function pe(e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            r = i.end,\n            s = void 0 === r ? ge(t) : r,\n            a = i.hasParentParens,\n            o = void 0 !== a && a;\n        if (e.span.start === e.span.end) return t;\n        var u = \"ImplicitReceiver\" === He.getNgType(e) ? he(\"ThisExpression\", {}, e.span) : le(e),\n            l = de(u);\n        return he(n.optional || l ? \"OptionalMemberExpression\" : \"MemberExpression\", Object.assign({\n          object: u,\n          property: t,\n          computed: n.computed\n        }, n.optional ? {\n          optional: !0\n        } : l ? {\n          optional: !1\n        } : null), {\n          start: xe(u),\n          end: s\n        }, {\n          hasParentParens: o\n        });\n      }\n\n      function ve(e, t) {\n        return He.findFrontChar(e, t, i.text);\n      }\n\n      function fe(e, t) {\n        return He.findBackChar(e, t, i.text);\n      }\n\n      function de(e) {\n        return (\"OptionalCallExpression\" === e.type || \"OptionalMemberExpression\" === e.type) && !ye(e);\n      }\n\n      function ye(e) {\n        return e.extra && e.extra.parenthesized;\n      }\n\n      function xe(e) {\n        return ye(e) ? e.extra.parenStart : e.start;\n      }\n\n      function ge(e) {\n        return ye(e) ? e.extra.parenEnd : e.end;\n      }\n    }, t.transformSpan = n;\n  });\n  n(Je);\n  var Xe = i(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.transformTemplateBindings = function (e, t) {\n      for (var n = p(e, 1)[0], i = n.key, r = 0 === t.text.slice(n.span.start, n.span.end).trim().length ? e.slice(1) : e, s = [], a = null, o = 0; o < r.length; o++) {\n        var u = r[o],\n            l = u.key,\n            c = u.keyIsVar,\n            h = u.name,\n            v = u.span;\n        a && a.key === h && c && /^as\\s$/.test(t.text.slice(v.start, v.start + 3)) ? function () {\n          var e = x(He.findBackChar(/\\S/, v.start + 3, t.text), l),\n              n = y(\"NGMicrosyntaxKey\", {\n            name: l\n          }, e),\n              i = function (e, n) {\n            return Object.assign({}, e, Je.transformSpan({\n              start: e.start,\n              end: n\n            }, t));\n          },\n              r = function (e) {\n            return Object.assign({}, i(e, n.end), {\n              alias: n\n            });\n          },\n              a = s.pop();\n\n          if (\"NGMicrosyntaxExpression\" === a.type) s.push(r(a));else {\n            if (\"NGMicrosyntaxKeyedExpression\" !== a.type) throw new Error(\"Unexpected type \".concat(a.type));\n            var o = r(a.expression);\n            s.push(i(Object.assign({}, a, {\n              expression: o\n            }), o.end));\n          }\n        }() : s.push(f(u, o)), a = u;\n      }\n\n      return y(\"NGMicrosyntax\", {\n        body: s\n      }, 0 === s.length ? e[0].span : {\n        start: s[0].start,\n        end: s[s.length - 1].end\n      });\n\n      function f(e, n) {\n        var i = e.key,\n            r = e.keyIsVar,\n            s = e.name,\n            a = e.expression,\n            o = e.span;\n\n        if (r) {\n          if (/^let\\s$/.test(t.text.slice(o.start, o.start + 4))) {\n            var u = x(He.findBackChar(/\\S/, o.start + 4, t.text), i);\n            return y(\"NGMicrosyntaxLet\", {\n              key: y(\"NGMicrosyntaxKey\", {\n                name: i\n              }, u),\n              value: 0 === t.text.slice(u.end, o.end).trim().length ? null : y(\"NGMicrosyntaxKey\", {\n                name: s\n              }, {\n                start: He.findBackChar(/=/, u.end, t.text) + 1,\n                end: o.end\n              })\n            }, o);\n          }\n\n          var l = x(o.start, s);\n          return y(\"NGMicrosyntaxAs\", {\n            key: y(\"NGMicrosyntaxKey\", {\n              name: s\n            }, l),\n            alias: y(\"NGMicrosyntaxKey\", {\n              name: i\n            }, {\n              start: He.findBackChar(/\\S/, l.end, t.text) + \"as\".length,\n              end: o.end\n            })\n          }, o);\n        }\n\n        if (a) {\n          if (0 === n) return y(\"NGMicrosyntaxExpression\", {\n            expression: d(a.ast),\n            alias: null\n          }, o);\n          var c = d(a.ast),\n              h = c.start,\n              p = c.end,\n              v = g(i);\n          return y(\"NGMicrosyntaxKeyedExpression\", {\n            key: y(\"NGMicrosyntaxKey\", {\n              name: v\n            }, x(o.start, v)),\n            expression: y(\"NGMicrosyntaxExpression\", {\n              expression: c,\n              alias: null\n            }, {\n              start: h,\n              end: p\n            })\n          }, o);\n        }\n\n        return y(\"NGMicrosyntaxKey\", {\n          name: g(i)\n        }, o);\n      }\n\n      function d(e) {\n        return Je.transform(e, t);\n      }\n\n      function y(e, n, i) {\n        var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n        return Object.assign({\n          type: e\n        }, Je.transformSpan(i, t, r, !1), n);\n      }\n\n      function x(e, n) {\n        if (\"'\" !== t.text[e] && '\"' !== t.text[e]) return {\n          start: e,\n          end: e + n.length\n        };\n\n        for (var i = t.text[e], r = 0, s = e + 1;;) {\n          var a = t.text[s];\n          if (a === i && r % 2 == 0) return {\n            start: e,\n            end: s + 1\n          };\n          \"\\\\\" === a ? r++ : r = 0, s++;\n        }\n      }\n\n      function g(e) {\n        return He.toLowerCamelCase(e.slice(i.length));\n      }\n    };\n  });\n  n(Xe);\n  var Ye = i(function (e, t) {\n    function n(e, t) {\n      var n = t(e),\n          i = n.ast,\n          r = n.comments,\n          s = new y.Context(e),\n          a = function (e) {\n        return Je.transform(e, s);\n      },\n          o = a(i);\n\n      return o.comments = r.map(a), o;\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.parseBinding = function (e) {\n      return n(e, He.parseNgBinding);\n    }, t.parseSimpleBinding = function (e) {\n      return n(e, He.parseNgSimpleBinding);\n    }, t.parseInterpolation = function (e) {\n      return n(e, He.parseNgInterpolation);\n    }, t.parseAction = function (e) {\n      return n(e, He.parseNgAction);\n    }, t.parseTemplateBindings = function (e) {\n      return Xe.transformTemplateBindings(He.parseNgTemplateBindings(e), new y.Context(e));\n    };\n  });\n\n  function Ze(e) {\n    return Object.assign({\n      astFormat: \"estree\",\n      parse: function (t, n, i) {\n        var r = e(t, Ye);\n        return {\n          type: \"NGRoot\",\n          node: \"__ng_action\" === i.parser && \"NGChainedExpression\" !== r.type ? Object.assign({}, r, {\n            type: \"NGChainedExpression\",\n            expressions: [r]\n          }) : r\n        };\n      }\n    }, t);\n  }\n\n  return n(Ye), {\n    parsers: {\n      __ng_action: Ze(function (e, t) {\n        return t.parseAction(e);\n      }),\n      __ng_binding: Ze(function (e, t) {\n        return t.parseBinding(e);\n      }),\n      __ng_interpolation: Ze(function (e, t) {\n        return t.parseInterpolation(e);\n      }),\n      __ng_directive: Ze(function (e, t) {\n        return t.parseTemplateBindings(e);\n      })\n    }\n  };\n});","map":null,"metadata":{},"sourceType":"script"}