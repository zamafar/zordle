{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports[\"postcss\"] = factory();else root[\"prettierPlugins\"] = root[\"prettierPlugins\"] || {}, root[\"prettierPlugins\"][\"postcss\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            /******/\n            configurable: false,\n\n            /******/\n            enumerable: true,\n\n            /******/\n            get: getter\n            /******/\n\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 87);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      var TAG = exports.TAG = 'tag';\n      var STRING = exports.STRING = 'string';\n      var SELECTOR = exports.SELECTOR = 'selector';\n      var ROOT = exports.ROOT = 'root';\n      var PSEUDO = exports.PSEUDO = 'pseudo';\n      var NESTING = exports.NESTING = 'nesting';\n      var ID = exports.ID = 'id';\n      var COMMENT = exports.COMMENT = 'comment';\n      var COMBINATOR = exports.COMBINATOR = 'combinator';\n      var CLASS = exports.CLASS = 'class';\n      var ATTRIBUTE = exports.ATTRIBUTE = 'attribute';\n      var UNIVERSAL = exports.UNIVERSAL = 'universal';\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _get(target, property, receiver) {\n        if (typeof Reflect !== \"undefined\" && Reflect.get) {\n          _get = Reflect.get;\n        } else {\n          _get = function _get(target, property, receiver) {\n            var base = _superPropBase(target, property);\n\n            if (!base) return;\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n\n            if (desc.get) {\n              return desc.get.call(receiver);\n            }\n\n            return desc.value;\n          };\n        }\n\n        return _get(target, property, receiver || target);\n      }\n\n      function _superPropBase(object, property) {\n        while (!Object.prototype.hasOwnProperty.call(object, property)) {\n          object = _getPrototypeOf(object);\n          if (object === null) break;\n        }\n\n        return object;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Node = __webpack_require__(3);\n\n      var Container =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Container, _Node);\n\n        function Container(opts) {\n          var _this;\n\n          _classCallCheck(this, Container);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Container).call(this, opts));\n\n          if (!_this.nodes) {\n            _this.nodes = [];\n          }\n\n          return _this;\n        }\n\n        _createClass(Container, [{\n          key: \"push\",\n          value: function push(child) {\n            child.parent = this;\n            this.nodes.push(child);\n            return this;\n          }\n        }, {\n          key: \"each\",\n          value: function each(callback) {\n            if (!this.lastEach) this.lastEach = 0;\n            if (!this.indexes) this.indexes = {};\n            this.lastEach += 1;\n            var id = this.lastEach,\n                index,\n                result;\n            this.indexes[id] = 0;\n            if (!this.nodes) return undefined;\n\n            while (this.indexes[id] < this.nodes.length) {\n              index = this.indexes[id];\n              result = callback(this.nodes[index], index);\n              if (result === false) break;\n              this.indexes[id] += 1;\n            }\n\n            delete this.indexes[id];\n            return result;\n          }\n        }, {\n          key: \"walk\",\n          value: function walk(callback) {\n            return this.each(function (child, i) {\n              var result = callback(child, i);\n\n              if (result !== false && child.walk) {\n                result = child.walk(callback);\n              }\n\n              return result;\n            });\n          }\n        }, {\n          key: \"walkType\",\n          value: function walkType(type, callback) {\n            var _this2 = this;\n\n            if (!type || !callback) {\n              throw new Error('Parameters {type} and {callback} are required.');\n            } // allow users to pass a constructor, or node type string; eg. Word.\n\n\n            type = type.name && type.prototype ? type.name : type;\n            return this.walk(function (node, index) {\n              if (node.type === type) {\n                return callback.call(_this2, node, index);\n              }\n            });\n          }\n        }, {\n          key: \"append\",\n          value: function append(node) {\n            node.parent = this;\n            this.nodes.push(node);\n            return this;\n          }\n        }, {\n          key: \"prepend\",\n          value: function prepend(node) {\n            node.parent = this;\n            this.nodes.unshift(node);\n            return this;\n          }\n        }, {\n          key: \"cleanRaws\",\n          value: function cleanRaws(keepBetween) {\n            _get(_getPrototypeOf(Container.prototype), \"cleanRaws\", this).call(this, keepBetween);\n\n            if (this.nodes) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = this.nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var node = _step.value;\n                  node.cleanRaws(keepBetween);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n          }\n        }, {\n          key: \"insertAfter\",\n          value: function insertAfter(oldNode, newNode) {\n            var oldIndex = this.index(oldNode),\n                index;\n            this.nodes.splice(oldIndex + 1, 0, newNode);\n\n            for (var id in this.indexes) {\n              index = this.indexes[id];\n\n              if (oldIndex <= index) {\n                this.indexes[id] = index + this.nodes.length;\n              }\n            }\n\n            return this;\n          }\n        }, {\n          key: \"insertBefore\",\n          value: function insertBefore(oldNode, newNode) {\n            var oldIndex = this.index(oldNode),\n                index;\n            this.nodes.splice(oldIndex, 0, newNode);\n\n            for (var id in this.indexes) {\n              index = this.indexes[id];\n\n              if (oldIndex <= index) {\n                this.indexes[id] = index + this.nodes.length;\n              }\n            }\n\n            return this;\n          }\n        }, {\n          key: \"removeChild\",\n          value: function removeChild(child) {\n            child = this.index(child);\n            this.nodes[child].parent = undefined;\n            this.nodes.splice(child, 1);\n            var index;\n\n            for (var id in this.indexes) {\n              index = this.indexes[id];\n\n              if (index >= child) {\n                this.indexes[id] = index - 1;\n              }\n            }\n\n            return this;\n          }\n        }, {\n          key: \"removeAll\",\n          value: function removeAll() {\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = this.nodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var node = _step2.value;\n                node.parent = undefined;\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            this.nodes = [];\n            return this;\n          }\n        }, {\n          key: \"every\",\n          value: function every(condition) {\n            return this.nodes.every(condition);\n          }\n        }, {\n          key: \"some\",\n          value: function some(condition) {\n            return this.nodes.some(condition);\n          }\n        }, {\n          key: \"index\",\n          value: function index(child) {\n            if (typeof child === 'number') {\n              return child;\n            } else {\n              return this.nodes.indexOf(child);\n            }\n          }\n        }, {\n          key: \"toString\",\n          value: function toString() {\n            var result = this.nodes.map(String).join('');\n\n            if (this.value) {\n              result = this.value + result;\n            }\n\n            if (this.raws.before) {\n              result = this.raws.before + result;\n            }\n\n            if (this.raws.after) {\n              result += this.raws.after;\n            }\n\n            return result;\n          }\n        }, {\n          key: \"first\",\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[0];\n          }\n        }, {\n          key: \"last\",\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[this.nodes.length - 1];\n          }\n        }]);\n\n        return Container;\n      }(Node);\n\n      Container.registerWalker = function (constructor) {\n        var walkerName = 'walk' + constructor.name; // plural sugar\n\n        if (walkerName.lastIndexOf('s') !== walkerName.length - 1) {\n          walkerName += 's';\n        }\n\n        if (Container.prototype[walkerName]) {\n          return;\n        } // we need access to `this` so we can't use an arrow function\n\n\n        Container.prototype[walkerName] = function (callback) {\n          return this.walkType(constructor, callback);\n        };\n      };\n\n      module.exports = Container;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      var singleQuote = exports.singleQuote = '\\''.charCodeAt(0);\n      var doubleQuote = exports.doubleQuote = '\"'.charCodeAt(0);\n      var backslash = exports.backslash = '\\\\'.charCodeAt(0);\n      var backTick = exports.backTick = '`'.charCodeAt(0);\n      var slash = exports.slash = '/'.charCodeAt(0);\n      var newline = exports.newline = '\\n'.charCodeAt(0);\n      var space = exports.space = ' '.charCodeAt(0);\n      var feed = exports.feed = '\\f'.charCodeAt(0);\n      var tab = exports.tab = '\\t'.charCodeAt(0);\n      var carriageReturn = exports.carriageReturn = '\\r'.charCodeAt(0);\n      var openedParenthesis = exports.openedParenthesis = '('.charCodeAt(0);\n      var closedParenthesis = exports.closedParenthesis = ')'.charCodeAt(0);\n      var openedCurlyBracket = exports.openedCurlyBracket = '{'.charCodeAt(0);\n      var closedCurlyBracket = exports.closedCurlyBracket = '}'.charCodeAt(0);\n      var openSquareBracket = exports.openSquareBracket = '['.charCodeAt(0);\n      var closeSquareBracket = exports.closeSquareBracket = ']'.charCodeAt(0);\n      var semicolon = exports.semicolon = ';'.charCodeAt(0);\n      var asterisk = exports.asterisk = '*'.charCodeAt(0);\n      var colon = exports.colon = ':'.charCodeAt(0);\n      var comma = exports.comma = ','.charCodeAt(0);\n      var dot = exports.dot = '.'.charCodeAt(0);\n      var atRule = exports.atRule = '@'.charCodeAt(0);\n      var tilde = exports.tilde = '~'.charCodeAt(0);\n      var hash = exports.hash = '#'.charCodeAt(0);\n      var atEndPattern = exports.atEndPattern = /[ \\n\\t\\r\\f\\{\\(\\)'\"\\\\;/\\[\\]#]/g;\n      var wordEndPattern = exports.wordEndPattern = /[ \\n\\t\\r\\f\\(\\)\\{\\}:,;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\n      var badBracketPattern = exports.badBracketPattern = /.[\\\\\\/\\(\"'\\n]/;\n      var variablePattern = exports.variablePattern = /^@[^:\\(\\{]+:/;\n      var hashColorPattern = exports.hashColorPattern = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      var cloneNode = function cloneNode(obj, parent) {\n        var cloned = new obj.constructor();\n\n        for (var i in obj) {\n          if (!obj.hasOwnProperty(i)) continue;\n\n          var value = obj[i],\n              type = _typeof(value);\n\n          if (i === 'parent' && type === 'object') {\n            if (parent) cloned[i] = parent;\n          } else if (i === 'source') {\n            cloned[i] = value;\n          } else if (value instanceof Array) {\n            cloned[i] = value.map(function (j) {\n              return cloneNode(j, cloned);\n            });\n          } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {\n            if (type === 'object' && value !== null) value = cloneNode(value);\n            cloned[i] = value;\n          }\n        }\n\n        return cloned;\n      };\n\n      module.exports =\n      /*#__PURE__*/\n      function () {\n        function Node(defaults) {\n          _classCallCheck(this, Node);\n\n          defaults = defaults || {};\n          this.raws = {\n            before: '',\n            after: ''\n          };\n\n          for (var name in defaults) {\n            this[name] = defaults[name];\n          }\n        }\n\n        _createClass(Node, [{\n          key: \"remove\",\n          value: function remove() {\n            if (this.parent) {\n              this.parent.removeChild(this);\n            }\n\n            this.parent = undefined;\n            return this;\n          }\n        }, {\n          key: \"toString\",\n          value: function toString() {\n            return [this.raws.before, String(this.value), this.raws.after].join('');\n          }\n        }, {\n          key: \"clone\",\n          value: function clone(overrides) {\n            overrides = overrides || {};\n            var cloned = cloneNode(this);\n\n            for (var name in overrides) {\n              cloned[name] = overrides[name];\n            }\n\n            return cloned;\n          }\n        }, {\n          key: \"cloneBefore\",\n          value: function cloneBefore(overrides) {\n            overrides = overrides || {};\n            var cloned = this.clone(overrides);\n            this.parent.insertBefore(this, cloned);\n            return cloned;\n          }\n        }, {\n          key: \"cloneAfter\",\n          value: function cloneAfter(overrides) {\n            overrides = overrides || {};\n            var cloned = this.clone(overrides);\n            this.parent.insertAfter(this, cloned);\n            return cloned;\n          }\n        }, {\n          key: \"replaceWith\",\n          value: function replaceWith() {\n            var nodes = Array.prototype.slice.call(arguments);\n\n            if (this.parent) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = nodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var node = _step.value;\n                  this.parent.insertBefore(this, node);\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n\n              this.remove();\n            }\n\n            return this;\n          }\n        }, {\n          key: \"moveTo\",\n          value: function moveTo(container) {\n            this.cleanRaws(this.root() === container.root());\n            this.remove();\n            container.append(this);\n            return this;\n          }\n        }, {\n          key: \"moveBefore\",\n          value: function moveBefore(node) {\n            this.cleanRaws(this.root() === node.root());\n            this.remove();\n            node.parent.insertBefore(node, this);\n            return this;\n          }\n        }, {\n          key: \"moveAfter\",\n          value: function moveAfter(node) {\n            this.cleanRaws(this.root() === node.root());\n            this.remove();\n            node.parent.insertAfter(node, this);\n            return this;\n          }\n        }, {\n          key: \"next\",\n          value: function next() {\n            var index = this.parent.index(this);\n            return this.parent.nodes[index + 1];\n          }\n        }, {\n          key: \"prev\",\n          value: function prev() {\n            var index = this.parent.index(this);\n            return this.parent.nodes[index - 1];\n          }\n        }, {\n          key: \"toJSON\",\n          value: function toJSON() {\n            var fixed = {};\n\n            for (var name in this) {\n              if (!this.hasOwnProperty(name)) continue;\n              if (name === 'parent') continue;\n              var value = this[name];\n\n              if (value instanceof Array) {\n                fixed[name] = value.map(function (i) {\n                  if (_typeof(i) === 'object' && i.toJSON) {\n                    return i.toJSON();\n                  } else {\n                    return i;\n                  }\n                });\n              } else if (_typeof(value) === 'object' && value.toJSON) {\n                fixed[name] = value.toJSON();\n              } else {\n                fixed[name] = value;\n              }\n            }\n\n            return fixed;\n          }\n        }, {\n          key: \"root\",\n          value: function root() {\n            var result = this;\n\n            while (result.parent) {\n              result = result.parent;\n            }\n\n            return result;\n          }\n        }, {\n          key: \"cleanRaws\",\n          value: function cleanRaws(keepBetween) {\n            delete this.raws.before;\n            delete this.raws.after;\n            if (!keepBetween) delete this.raws.between;\n          }\n        }, {\n          key: \"positionInside\",\n          value: function positionInside(index) {\n            var string = this.toString(),\n                column = this.source.start.column,\n                line = this.source.start.line;\n\n            for (var i = 0; i < index; i++) {\n              if (string[i] === '\\n') {\n                column = 1;\n                line += 1;\n              } else {\n                column += 1;\n              }\n            }\n\n            return {\n              line: line,\n              column: column\n            };\n          }\n        }, {\n          key: \"positionBy\",\n          value: function positionBy(opts) {\n            var pos = this.source.start;\n\n            if (opts.index) {\n              pos = this.positionInside(opts.index);\n            } else if (opts.word) {\n              var index = this.toString().indexOf(opts.word);\n              if (index !== -1) pos = this.positionInside(index);\n            }\n\n            return pos;\n          }\n        }]);\n\n        return Node;\n      }();\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = warnOnce;\n      var printed = {};\n\n      function warnOnce(message) {\n        if (printed[message]) return;\n        printed[message] = true;\n        if (typeof console !== 'undefined' && console.warn) console.warn(message);\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var cloneNode = function cloneNode(obj, parent) {\n        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n          return obj;\n        }\n\n        var cloned = new obj.constructor();\n\n        for (var i in obj) {\n          if (!obj.hasOwnProperty(i)) {\n            continue;\n          }\n\n          var value = obj[i];\n          var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n          if (i === 'parent' && type === 'object') {\n            if (parent) {\n              cloned[i] = parent;\n            }\n          } else if (value instanceof Array) {\n            cloned[i] = value.map(function (j) {\n              return cloneNode(j, cloned);\n            });\n          } else {\n            cloned[i] = cloneNode(value, cloned);\n          }\n        }\n\n        return cloned;\n      };\n\n      var _class = function () {\n        function _class() {\n          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          _classCallCheck(this, _class);\n\n          for (var key in opts) {\n            this[key] = opts[key];\n          }\n\n          var _opts$spaces = opts.spaces;\n          _opts$spaces = _opts$spaces === undefined ? {} : _opts$spaces;\n          var _opts$spaces$before = _opts$spaces.before,\n              before = _opts$spaces$before === undefined ? '' : _opts$spaces$before,\n              _opts$spaces$after = _opts$spaces.after,\n              after = _opts$spaces$after === undefined ? '' : _opts$spaces$after;\n          this.spaces = {\n            before: before,\n            after: after\n          };\n        }\n\n        _class.prototype.remove = function remove() {\n          if (this.parent) {\n            this.parent.removeChild(this);\n          }\n\n          this.parent = undefined;\n          return this;\n        };\n\n        _class.prototype.replaceWith = function replaceWith() {\n          if (this.parent) {\n            for (var index in arguments) {\n              this.parent.insertBefore(this, arguments[index]);\n            }\n\n            this.remove();\n          }\n\n          return this;\n        };\n\n        _class.prototype.next = function next() {\n          return this.parent.at(this.parent.index(this) + 1);\n        };\n\n        _class.prototype.prev = function prev() {\n          return this.parent.at(this.parent.index(this) - 1);\n        };\n\n        _class.prototype.clone = function clone() {\n          var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var cloned = cloneNode(this);\n\n          for (var name in overrides) {\n            cloned[name] = overrides[name];\n          }\n\n          return cloned;\n        };\n\n        _class.prototype.toString = function toString() {\n          return [this.spaces.before, String(this.value), this.spaces.after].join('');\n        };\n\n        return _class;\n      }();\n\n      exports.default = _class;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n        // resolves . and .. elements in a path array with directory names there\n        // must be no slashes, empty elements, or device names (c:\\) in the array\n        // (so also no leading and trailing slashes - it does not distinguish\n        // relative and absolute paths)\n        function normalizeArray(parts, allowAboveRoot) {\n          // if the path tries to go above the root, `up` ends up > 0\n          var up = 0;\n\n          for (var i = parts.length - 1; i >= 0; i--) {\n            var last = parts[i];\n\n            if (last === '.') {\n              parts.splice(i, 1);\n            } else if (last === '..') {\n              parts.splice(i, 1);\n              up++;\n            } else if (up) {\n              parts.splice(i, 1);\n              up--;\n            }\n          } // if the path is allowed to go above the root, restore leading ..s\n\n\n          if (allowAboveRoot) {\n            for (; up--; up) {\n              parts.unshift('..');\n            }\n          }\n\n          return parts;\n        } // Split a filename into [root, dir, basename, ext], unix version\n        // 'root' is just a slash, or nothing.\n\n\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\n        var splitPath = function splitPath(filename) {\n          return splitPathRe.exec(filename).slice(1);\n        }; // path.resolve([from ...], to)\n        // posix version\n\n\n        exports.resolve = function () {\n          var resolvedPath = '',\n              resolvedAbsolute = false;\n\n          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n            if (typeof path !== 'string') {\n              throw new TypeError('Arguments to path.resolve must be strings');\n            } else if (!path) {\n              continue;\n            }\n\n            resolvedPath = path + '/' + resolvedPath;\n            resolvedAbsolute = path.charAt(0) === '/';\n          } // At this point the path should be resolved to a full absolute path, but\n          // handle relative paths to be safe (might happen when process.cwd() fails)\n          // Normalize the path\n\n\n          resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n            return !!p;\n          }), !resolvedAbsolute).join('/');\n          return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n        }; // path.normalize(path)\n        // posix version\n\n\n        exports.normalize = function (path) {\n          var isAbsolute = exports.isAbsolute(path),\n              trailingSlash = substr(path, -1) === '/'; // Normalize the path\n\n          path = normalizeArray(filter(path.split('/'), function (p) {\n            return !!p;\n          }), !isAbsolute).join('/');\n\n          if (!path && !isAbsolute) {\n            path = '.';\n          }\n\n          if (path && trailingSlash) {\n            path += '/';\n          }\n\n          return (isAbsolute ? '/' : '') + path;\n        }; // posix version\n\n\n        exports.isAbsolute = function (path) {\n          return path.charAt(0) === '/';\n        }; // posix version\n\n\n        exports.join = function () {\n          var paths = Array.prototype.slice.call(arguments, 0);\n          return exports.normalize(filter(paths, function (p, index) {\n            if (typeof p !== 'string') {\n              throw new TypeError('Arguments to path.join must be strings');\n            }\n\n            return p;\n          }).join('/'));\n        }; // path.relative(from, to)\n        // posix version\n\n\n        exports.relative = function (from, to) {\n          from = exports.resolve(from).substr(1);\n          to = exports.resolve(to).substr(1);\n\n          function trim(arr) {\n            var start = 0;\n\n            for (; start < arr.length; start++) {\n              if (arr[start] !== '') break;\n            }\n\n            var end = arr.length - 1;\n\n            for (; end >= 0; end--) {\n              if (arr[end] !== '') break;\n            }\n\n            if (start > end) return [];\n            return arr.slice(start, end - start + 1);\n          }\n\n          var fromParts = trim(from.split('/'));\n          var toParts = trim(to.split('/'));\n          var length = Math.min(fromParts.length, toParts.length);\n          var samePartsLength = length;\n\n          for (var i = 0; i < length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n              samePartsLength = i;\n              break;\n            }\n          }\n\n          var outputParts = [];\n\n          for (var i = samePartsLength; i < fromParts.length; i++) {\n            outputParts.push('..');\n          }\n\n          outputParts = outputParts.concat(toParts.slice(samePartsLength));\n          return outputParts.join('/');\n        };\n\n        exports.sep = '/';\n        exports.delimiter = ':';\n\n        exports.dirname = function (path) {\n          var result = splitPath(path),\n              root = result[0],\n              dir = result[1];\n\n          if (!root && !dir) {\n            // No dirname whatsoever\n            return '.';\n          }\n\n          if (dir) {\n            // It has a dirname, strip trailing slash\n            dir = dir.substr(0, dir.length - 1);\n          }\n\n          return root + dir;\n        };\n\n        exports.basename = function (path, ext) {\n          var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?\n\n          if (ext && f.substr(-1 * ext.length) === ext) {\n            f = f.substr(0, f.length - ext.length);\n          }\n\n          return f;\n        };\n\n        exports.extname = function (path) {\n          return splitPath(path)[3];\n        };\n\n        function filter(xs, f) {\n          if (xs.filter) return xs.filter(f);\n          var res = [];\n\n          for (var i = 0; i < xs.length; i++) {\n            if (f(xs[i], i, xs)) res.push(xs[i]);\n          }\n\n          return res;\n        } // String.prototype.substr - negative index don't work in IE8\n\n\n        var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n          return str.substr(start, len);\n        } : function (str, start, len) {\n          if (start < 0) start = str.length + start;\n          return str.substr(start, len);\n        };\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(12));\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Namespace = function (_Node) {\n        _inherits(Namespace, _Node);\n\n        function Namespace() {\n          _classCallCheck(this, Namespace);\n\n          return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n        }\n\n        Namespace.prototype.toString = function toString() {\n          return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join('');\n        };\n\n        _createClass(Namespace, [{\n          key: 'ns',\n          get: function get() {\n            var n = this.namespace;\n            return n ? (typeof n === 'string' ? n : '') + '|' : '';\n          }\n        }]);\n\n        return Namespace;\n      }(_node2.default);\n\n      exports.default = Namespace;\n      ;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n\n      /**\n       * This is a helper function for getting values from parameter/options\n       * objects.\n       *\n       * @param args The object we are extracting values from\n       * @param name The name of the property we are getting.\n       * @param defaultValue An optional value to return if the property is missing\n       * from the object. If this is not specified and the property is missing, an\n       * error will be thrown.\n       */\n      function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n          return aArgs[aName];\n        } else if (arguments.length === 3) {\n          return aDefaultValue;\n        } else {\n          throw new Error('\"' + aName + '\" is a required argument.');\n        }\n      }\n\n      exports.getArg = getArg;\n      var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\n      var dataUrlRegexp = /^data:.+\\,.+$/;\n\n      function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n\n        if (!match) {\n          return null;\n        }\n\n        return {\n          scheme: match[1],\n          auth: match[2],\n          host: match[3],\n          port: match[4],\n          path: match[5]\n        };\n      }\n\n      exports.urlParse = urlParse;\n\n      function urlGenerate(aParsedUrl) {\n        var url = '';\n\n        if (aParsedUrl.scheme) {\n          url += aParsedUrl.scheme + ':';\n        }\n\n        url += '//';\n\n        if (aParsedUrl.auth) {\n          url += aParsedUrl.auth + '@';\n        }\n\n        if (aParsedUrl.host) {\n          url += aParsedUrl.host;\n        }\n\n        if (aParsedUrl.port) {\n          url += \":\" + aParsedUrl.port;\n        }\n\n        if (aParsedUrl.path) {\n          url += aParsedUrl.path;\n        }\n\n        return url;\n      }\n\n      exports.urlGenerate = urlGenerate;\n      /**\n       * Normalizes a path, or the path portion of a URL:\n       *\n       * - Replaces consecutive slashes with one slash.\n       * - Removes unnecessary '.' parts.\n       * - Removes unnecessary '<dir>/..' parts.\n       *\n       * Based on code in the Node.js 'path' core module.\n       *\n       * @param aPath The path or url to normalize.\n       */\n\n      function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n\n        if (url) {\n          if (!url.path) {\n            return aPath;\n          }\n\n          path = url.path;\n        }\n\n        var isAbsolute = exports.isAbsolute(path);\n        var parts = path.split(/\\/+/);\n\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n          part = parts[i];\n\n          if (part === '.') {\n            parts.splice(i, 1);\n          } else if (part === '..') {\n            up++;\n          } else if (up > 0) {\n            if (part === '') {\n              // The first part is blank if the path is absolute. Trying to go\n              // above the root is a no-op. Therefore we can remove all '..' parts\n              // directly after the root.\n              parts.splice(i + 1, up);\n              up = 0;\n            } else {\n              parts.splice(i, 2);\n              up--;\n            }\n          }\n        }\n\n        path = parts.join('/');\n\n        if (path === '') {\n          path = isAbsolute ? '/' : '.';\n        }\n\n        if (url) {\n          url.path = path;\n          return urlGenerate(url);\n        }\n\n        return path;\n      }\n\n      exports.normalize = normalize;\n      /**\n       * Joins two paths/URLs.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be joined with the root.\n       *\n       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n       *   first.\n       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n       *   is updated with the result and aRoot is returned. Otherwise the result\n       *   is returned.\n       *   - If aPath is absolute, the result is aPath.\n       *   - Otherwise the two paths are joined with a slash.\n       * - Joining for example 'http://' and 'www.example.com' is also supported.\n       */\n\n      function join(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        if (aPath === \"\") {\n          aPath = \".\";\n        }\n\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n\n        if (aRootUrl) {\n          aRoot = aRootUrl.path || '/';\n        } // `join(foo, '//www.example.org')`\n\n\n        if (aPathUrl && !aPathUrl.scheme) {\n          if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n          }\n\n          return urlGenerate(aPathUrl);\n        }\n\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n          return aPath;\n        } // `join('http://', 'www.example.com')`\n\n\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n          aRootUrl.host = aPath;\n          return urlGenerate(aRootUrl);\n        }\n\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n        if (aRootUrl) {\n          aRootUrl.path = joined;\n          return urlGenerate(aRootUrl);\n        }\n\n        return joined;\n      }\n\n      exports.join = join;\n\n      exports.isAbsolute = function (aPath) {\n        return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n      };\n      /**\n       * Make a path relative to a URL or another path.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be made relative to aRoot.\n       */\n\n\n      function relative(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        aRoot = aRoot.replace(/\\/$/, ''); // It is possible for the path to be above the root. In this case, simply\n        // checking whether the root is a prefix of the path won't work. Instead, we\n        // need to remove components from the root one by one, until either we find\n        // a prefix that fits, or we run out of components to remove.\n\n        var level = 0;\n\n        while (aPath.indexOf(aRoot + '/') !== 0) {\n          var index = aRoot.lastIndexOf(\"/\");\n\n          if (index < 0) {\n            return aPath;\n          } // If the only part of the root that is left is the scheme (i.e. http://,\n          // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n          // have exhausted all components, so the path is not relative to the root.\n\n\n          aRoot = aRoot.slice(0, index);\n\n          if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n          }\n\n          ++level;\n        } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n        return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n      }\n\n      exports.relative = relative;\n\n      var supportsNullProto = function () {\n        var obj = Object.create(null);\n        return !('__proto__' in obj);\n      }();\n\n      function identity(s) {\n        return s;\n      }\n      /**\n       * Because behavior goes wacky when you set `__proto__` on objects, we\n       * have to prefix all the strings in our set with an arbitrary character.\n       *\n       * See https://github.com/mozilla/source-map/pull/31 and\n       * https://github.com/mozilla/source-map/issues/30\n       *\n       * @param String aStr\n       */\n\n\n      function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return '$' + aStr;\n        }\n\n        return aStr;\n      }\n\n      exports.toSetString = supportsNullProto ? identity : toSetString;\n\n      function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return aStr.slice(1);\n        }\n\n        return aStr;\n      }\n\n      exports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n      function isProtoString(s) {\n        if (!s) {\n          return false;\n        }\n\n        var length = s.length;\n\n        if (length < 9\n        /* \"__proto__\".length */\n        ) {\n            return false;\n          }\n\n        if (s.charCodeAt(length - 1) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 2) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 3) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 4) !== 116\n        /* 't' */\n        || s.charCodeAt(length - 5) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 6) !== 114\n        /* 'r' */\n        || s.charCodeAt(length - 7) !== 112\n        /* 'p' */\n        || s.charCodeAt(length - 8) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 9) !== 95\n        /* '_' */\n        ) {\n            return false;\n          }\n\n        for (var i = length - 10; i >= 0; i--) {\n          if (s.charCodeAt(i) !== 36\n          /* '$' */\n          ) {\n              return false;\n            }\n        }\n\n        return true;\n      }\n      /**\n       * Comparator between two mappings where the original positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same original source/line/column, but different generated\n       * line and column the same. Useful when searching for a mapping with a\n       * stubbed out mapping.\n       */\n\n\n      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0 || onlyCompareOriginal) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByOriginalPositions = compareByOriginalPositions;\n      /**\n       * Comparator between two mappings with deflated source and name indices where\n       * the generated positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same generated line and column, but different\n       * source/name/original line and column the same. Useful when searching for a\n       * mapping with a stubbed out mapping.\n       */\n\n      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0 || onlyCompareGenerated) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n      function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n          return 0;\n        }\n\n        if (aStr1 === null) {\n          return 1; // aStr2 !== null\n        }\n\n        if (aStr2 === null) {\n          return -1; // aStr1 !== null\n        }\n\n        if (aStr1 > aStr2) {\n          return 1;\n        }\n\n        return -1;\n      }\n      /**\n       * Comparator between two mappings with inflated source and name strings where\n       * the generated positions are compared.\n       */\n\n\n      function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n      /**\n       * Strip any JSON XSSI avoidance prefix from the string (as documented\n       * in the source maps specification), and then parse the string as\n       * JSON.\n       */\n\n      function parseSourceMapInput(str) {\n        return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n      }\n\n      exports.parseSourceMapInput = parseSourceMapInput;\n      /**\n       * Compute the URL of a source given the the source root, the source's\n       * URL, and the source map's URL.\n       */\n\n      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n        sourceURL = sourceURL || '';\n\n        if (sourceRoot) {\n          // This follows what Chrome does.\n          if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n            sourceRoot += '/';\n          } // The spec says:\n          //   Line 4: An optional source root, useful for relocating source\n          //   files on a server or removing repeated values in the\n          //   sources entry.  This value is prepended to the individual\n          //   entries in the source field.\n\n\n          sourceURL = sourceRoot + sourceURL;\n        } // Historically, SourceMapConsumer did not take the sourceMapURL as\n        // a parameter.  This mode is still somewhat supported, which is why\n        // this code block is conditional.  However, it's preferable to pass\n        // the source map URL to SourceMapConsumer, so that this function\n        // can implement the source URL resolution algorithm as outlined in\n        // the spec.  This block is basically the equivalent of:\n        //    new URL(sourceURL, sourceMapURL).toString()\n        // ... except it avoids using URL, which wasn't available in the\n        // older releases of node still supported by this library.\n        //\n        // The spec says:\n        //   If the sources are not absolute URLs after prepending of the\n        //   sourceRoot, the sources are resolved relative to the\n        //   SourceMap (like resolving script src in a html document).\n\n\n        if (sourceMapURL) {\n          var parsed = urlParse(sourceMapURL);\n\n          if (!parsed) {\n            throw new Error(\"sourceMapURL could not be parsed\");\n          }\n\n          if (parsed.path) {\n            // Strip the last path component, but keep the \"/\".\n            var index = parsed.path.lastIndexOf('/');\n\n            if (index >= 0) {\n              parsed.path = parsed.path.substring(0, index + 1);\n            }\n          }\n\n          sourceURL = join(urlGenerate(parsed), sourceURL);\n        }\n\n        return normalize(sourceURL);\n      }\n\n      exports.computeSourceURL = computeSourceURL;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n\n      /**\n       * This is a helper function for getting values from parameter/options\n       * objects.\n       *\n       * @param args The object we are extracting values from\n       * @param name The name of the property we are getting.\n       * @param defaultValue An optional value to return if the property is missing\n       * from the object. If this is not specified and the property is missing, an\n       * error will be thrown.\n       */\n      function getArg(aArgs, aName, aDefaultValue) {\n        if (aName in aArgs) {\n          return aArgs[aName];\n        } else if (arguments.length === 3) {\n          return aDefaultValue;\n        } else {\n          throw new Error('\"' + aName + '\" is a required argument.');\n        }\n      }\n\n      exports.getArg = getArg;\n      var urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\n      var dataUrlRegexp = /^data:.+\\,.+$/;\n\n      function urlParse(aUrl) {\n        var match = aUrl.match(urlRegexp);\n\n        if (!match) {\n          return null;\n        }\n\n        return {\n          scheme: match[1],\n          auth: match[2],\n          host: match[3],\n          port: match[4],\n          path: match[5]\n        };\n      }\n\n      exports.urlParse = urlParse;\n\n      function urlGenerate(aParsedUrl) {\n        var url = '';\n\n        if (aParsedUrl.scheme) {\n          url += aParsedUrl.scheme + ':';\n        }\n\n        url += '//';\n\n        if (aParsedUrl.auth) {\n          url += aParsedUrl.auth + '@';\n        }\n\n        if (aParsedUrl.host) {\n          url += aParsedUrl.host;\n        }\n\n        if (aParsedUrl.port) {\n          url += \":\" + aParsedUrl.port;\n        }\n\n        if (aParsedUrl.path) {\n          url += aParsedUrl.path;\n        }\n\n        return url;\n      }\n\n      exports.urlGenerate = urlGenerate;\n      /**\n       * Normalizes a path, or the path portion of a URL:\n       *\n       * - Replaces consecutive slashes with one slash.\n       * - Removes unnecessary '.' parts.\n       * - Removes unnecessary '<dir>/..' parts.\n       *\n       * Based on code in the Node.js 'path' core module.\n       *\n       * @param aPath The path or url to normalize.\n       */\n\n      function normalize(aPath) {\n        var path = aPath;\n        var url = urlParse(aPath);\n\n        if (url) {\n          if (!url.path) {\n            return aPath;\n          }\n\n          path = url.path;\n        }\n\n        var isAbsolute = exports.isAbsolute(path);\n        var parts = path.split(/\\/+/);\n\n        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n          part = parts[i];\n\n          if (part === '.') {\n            parts.splice(i, 1);\n          } else if (part === '..') {\n            up++;\n          } else if (up > 0) {\n            if (part === '') {\n              // The first part is blank if the path is absolute. Trying to go\n              // above the root is a no-op. Therefore we can remove all '..' parts\n              // directly after the root.\n              parts.splice(i + 1, up);\n              up = 0;\n            } else {\n              parts.splice(i, 2);\n              up--;\n            }\n          }\n        }\n\n        path = parts.join('/');\n\n        if (path === '') {\n          path = isAbsolute ? '/' : '.';\n        }\n\n        if (url) {\n          url.path = path;\n          return urlGenerate(url);\n        }\n\n        return path;\n      }\n\n      exports.normalize = normalize;\n      /**\n       * Joins two paths/URLs.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be joined with the root.\n       *\n       * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n       *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n       *   first.\n       * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n       *   is updated with the result and aRoot is returned. Otherwise the result\n       *   is returned.\n       *   - If aPath is absolute, the result is aPath.\n       *   - Otherwise the two paths are joined with a slash.\n       * - Joining for example 'http://' and 'www.example.com' is also supported.\n       */\n\n      function join(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        if (aPath === \"\") {\n          aPath = \".\";\n        }\n\n        var aPathUrl = urlParse(aPath);\n        var aRootUrl = urlParse(aRoot);\n\n        if (aRootUrl) {\n          aRoot = aRootUrl.path || '/';\n        } // `join(foo, '//www.example.org')`\n\n\n        if (aPathUrl && !aPathUrl.scheme) {\n          if (aRootUrl) {\n            aPathUrl.scheme = aRootUrl.scheme;\n          }\n\n          return urlGenerate(aPathUrl);\n        }\n\n        if (aPathUrl || aPath.match(dataUrlRegexp)) {\n          return aPath;\n        } // `join('http://', 'www.example.com')`\n\n\n        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n          aRootUrl.host = aPath;\n          return urlGenerate(aRootUrl);\n        }\n\n        var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n        if (aRootUrl) {\n          aRootUrl.path = joined;\n          return urlGenerate(aRootUrl);\n        }\n\n        return joined;\n      }\n\n      exports.join = join;\n\n      exports.isAbsolute = function (aPath) {\n        return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n      };\n      /**\n       * Make a path relative to a URL or another path.\n       *\n       * @param aRoot The root path or URL.\n       * @param aPath The path or URL to be made relative to aRoot.\n       */\n\n\n      function relative(aRoot, aPath) {\n        if (aRoot === \"\") {\n          aRoot = \".\";\n        }\n\n        aRoot = aRoot.replace(/\\/$/, ''); // It is possible for the path to be above the root. In this case, simply\n        // checking whether the root is a prefix of the path won't work. Instead, we\n        // need to remove components from the root one by one, until either we find\n        // a prefix that fits, or we run out of components to remove.\n\n        var level = 0;\n\n        while (aPath.indexOf(aRoot + '/') !== 0) {\n          var index = aRoot.lastIndexOf(\"/\");\n\n          if (index < 0) {\n            return aPath;\n          } // If the only part of the root that is left is the scheme (i.e. http://,\n          // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n          // have exhausted all components, so the path is not relative to the root.\n\n\n          aRoot = aRoot.slice(0, index);\n\n          if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n            return aPath;\n          }\n\n          ++level;\n        } // Make sure we add a \"../\" for each component we removed from the root.\n\n\n        return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n      }\n\n      exports.relative = relative;\n\n      var supportsNullProto = function () {\n        var obj = Object.create(null);\n        return !('__proto__' in obj);\n      }();\n\n      function identity(s) {\n        return s;\n      }\n      /**\n       * Because behavior goes wacky when you set `__proto__` on objects, we\n       * have to prefix all the strings in our set with an arbitrary character.\n       *\n       * See https://github.com/mozilla/source-map/pull/31 and\n       * https://github.com/mozilla/source-map/issues/30\n       *\n       * @param String aStr\n       */\n\n\n      function toSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return '$' + aStr;\n        }\n\n        return aStr;\n      }\n\n      exports.toSetString = supportsNullProto ? identity : toSetString;\n\n      function fromSetString(aStr) {\n        if (isProtoString(aStr)) {\n          return aStr.slice(1);\n        }\n\n        return aStr;\n      }\n\n      exports.fromSetString = supportsNullProto ? identity : fromSetString;\n\n      function isProtoString(s) {\n        if (!s) {\n          return false;\n        }\n\n        var length = s.length;\n\n        if (length < 9\n        /* \"__proto__\".length */\n        ) {\n            return false;\n          }\n\n        if (s.charCodeAt(length - 1) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 2) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 3) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 4) !== 116\n        /* 't' */\n        || s.charCodeAt(length - 5) !== 111\n        /* 'o' */\n        || s.charCodeAt(length - 6) !== 114\n        /* 'r' */\n        || s.charCodeAt(length - 7) !== 112\n        /* 'p' */\n        || s.charCodeAt(length - 8) !== 95\n        /* '_' */\n        || s.charCodeAt(length - 9) !== 95\n        /* '_' */\n        ) {\n            return false;\n          }\n\n        for (var i = length - 10; i >= 0; i--) {\n          if (s.charCodeAt(i) !== 36\n          /* '$' */\n          ) {\n              return false;\n            }\n        }\n\n        return true;\n      }\n      /**\n       * Comparator between two mappings where the original positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same original source/line/column, but different generated\n       * line and column the same. Useful when searching for a mapping with a\n       * stubbed out mapping.\n       */\n\n\n      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n        var cmp = mappingA.source - mappingB.source;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0 || onlyCompareOriginal) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return mappingA.name - mappingB.name;\n      }\n\n      exports.compareByOriginalPositions = compareByOriginalPositions;\n      /**\n       * Comparator between two mappings with deflated source and name indices where\n       * the generated positions are compared.\n       *\n       * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n       * mappings with the same generated line and column, but different\n       * source/name/original line and column the same. Useful when searching for a\n       * mapping with a stubbed out mapping.\n       */\n\n      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0 || onlyCompareGenerated) {\n          return cmp;\n        }\n\n        cmp = mappingA.source - mappingB.source;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return mappingA.name - mappingB.name;\n      }\n\n      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\n      function strcmp(aStr1, aStr2) {\n        if (aStr1 === aStr2) {\n          return 0;\n        }\n\n        if (aStr1 > aStr2) {\n          return 1;\n        }\n\n        return -1;\n      }\n      /**\n       * Comparator between two mappings with inflated source and name strings where\n       * the generated positions are compared.\n       */\n\n\n      function compareByGeneratedPositionsInflated(mappingA, mappingB) {\n        var cmp = mappingA.generatedLine - mappingB.generatedLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = strcmp(mappingA.source, mappingB.source);\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalLine - mappingB.originalLine;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        cmp = mappingA.originalColumn - mappingB.originalColumn;\n\n        if (cmp !== 0) {\n          return cmp;\n        }\n\n        return strcmp(mappingA.name, mappingB.name);\n      }\n\n      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _container = __webpack_require__(25);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      var _list = __webpack_require__(162);\n\n      var _list2 = _interopRequireDefault(_list);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS rule: a selector followed by a declaration block.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('a{}');\n       * const rule = root.first;\n       * rule.type       //=> 'rule'\n       * rule.toString() //=> 'a{}'\n       */\n\n\n      var Rule = function (_Container) {\n        _inherits(Rule, _Container);\n\n        function Rule(defaults) {\n          _classCallCheck(this, Rule);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));\n\n          _this.type = 'rule';\n          if (!_this.nodes) _this.nodes = [];\n          return _this;\n        }\n        /**\n         * An array containing the rules individual selectors.\n         * Groups of selectors are split at commas.\n         *\n         * @type {string[]}\n         *\n         * @example\n         * const root = postcss.parse('a, b { }');\n         * const rule = root.first;\n         *\n         * rule.selector  //=> 'a, b'\n         * rule.selectors //=> ['a', 'b']\n         *\n         * rule.selectors = ['a', 'strong'];\n         * rule.selector //=> 'a, strong'\n         */\n\n\n        _createClass(Rule, [{\n          key: 'selectors',\n          get: function get() {\n            return _list2.default.comma(this.selector);\n          },\n          set: function set(values) {\n            var match = this.selector ? this.selector.match(/,\\s*/) : null;\n            var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');\n            this.selector = values.join(sep);\n          }\n        }, {\n          key: '_selector',\n          get: function get() {\n            (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');\n            return this.raws.selector;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Rule#_selector is deprecated. Use Rule#raws.selector');\n            this.raws.selector = val;\n          }\n          /**\n           * @memberof Rule#\n           * @member {string} selector - the rules full selector represented\n           *                             as a string\n           *\n           * @example\n           * const root = postcss.parse('a, b { }');\n           * const rule = root.first;\n           * rule.selector //=> 'a, b'\n           */\n\n          /**\n           * @memberof Rule#\n           * @member {object} raws - Information to generate byte-to-byte equal\n           *                         node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node. It also stores `*`\n           *   and `_` symbols before the declaration (IE hack).\n           * * `after`: the space symbols after the last child of the node\n           *   to the end of the node.\n           * * `between`: the symbols between the property and value\n           *   for declarations, selector and `{` for rules, or last parameter\n           *   and `{` for at-rules.\n           * * `semicolon`: contains true if the last child has\n           *   an (optional) semicolon.\n           *\n           * PostCSS cleans selectors from comments and extra spaces,\n           * but it stores origin content in raws properties.\n           * As such, if you dont change a declarations value,\n           * PostCSS will use the raw value with comments.\n           *\n           * @example\n           * const root = postcss.parse('a {\\n  color:black\\n}')\n           * root.first.first.raws //=> { before: '', between: ' ', after: '\\n' }\n           */\n\n        }]);\n\n        return Rule;\n      }(_container2.default);\n\n      exports.default = Rule;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = unclosed;\n\n      function unclosed(state, what) {\n        throw state.input.error(\"Unclosed \" + what, state.line, state.pos - state.offset);\n      }\n\n      module.exports = exports[\"default\"];\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports) {\n      // shim for using process in browser\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n      /***/\n\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _declaration = _interopRequireDefault(__webpack_require__(67));\n\n      var _comment = _interopRequireDefault(__webpack_require__(19));\n\n      var _node = _interopRequireDefault(__webpack_require__(20));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n\n      function cleanSource(nodes) {\n        return nodes.map(function (i) {\n          if (i.nodes) i.nodes = cleanSource(i.nodes);\n          delete i.source;\n          return i;\n        });\n      }\n      /**\n       * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n       * inherit some common methods to help work with their children.\n       *\n       * Note that all containers can store any content. If you write a rule inside\n       * a rule, PostCSS will parse it.\n       *\n       * @extends Node\n       * @abstract\n       */\n\n\n      var Container =\n      /*#__PURE__*/\n      function (_Node) {\n        _inheritsLoose(Container, _Node);\n\n        function Container() {\n          return _Node.apply(this, arguments) || this;\n        }\n\n        var _proto = Container.prototype;\n\n        _proto.push = function push(child) {\n          child.parent = this;\n          this.nodes.push(child);\n          return this;\n        };\n        /**\n         * Iterates through the containers immediate children,\n         * calling `callback` for each child.\n         *\n         * Returning `false` in the callback will break iteration.\n         *\n         * This method only iterates through the containers immediate children.\n         * If you need to recursively iterate through all the containers descendant\n         * nodes, use {@link Container#walk}.\n         *\n         * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n         * if you are mutating the array of child nodes during iteration.\n         * PostCSS will adjust the current index to match the mutations.\n         *\n         * @param {childIterator} callback Iterator receives each node and index.\n         *\n         * @return {false|undefined} Returns `false` if iteration was broke.\n         *\n         * @example\n         * const root = postcss.parse('a { color: black; z-index: 1 }')\n         * const rule = root.first\n         *\n         * for (const decl of rule.nodes) {\n         *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n         *   // Cycle will be infinite, because cloneBefore moves the current node\n         *   // to the next index\n         * }\n         *\n         * rule.each(decl => {\n         *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })\n         *   // Will be executed only for color and z-index\n         * })\n         */\n\n\n        _proto.each = function each(callback) {\n          if (!this.lastEach) this.lastEach = 0;\n          if (!this.indexes) this.indexes = {};\n          this.lastEach += 1;\n          var id = this.lastEach;\n          this.indexes[id] = 0;\n          if (!this.nodes) return undefined;\n          var index, result;\n\n          while (this.indexes[id] < this.nodes.length) {\n            index = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if (result === false) break;\n            this.indexes[id] += 1;\n          }\n\n          delete this.indexes[id];\n          return result;\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each node.\n         *\n         * Like container.each(), this method is safe to use\n         * if you are mutating arrays during iteration.\n         *\n         * If you only need to iterate through the containers immediate children,\n         * use {@link Container#each}.\n         *\n         * @param {childIterator} callback Iterator receives each node and index.\n         *\n         * @return {false|undefined} Returns `false` if iteration was broke.\n         *\n         * @example\n         * root.walk(node => {\n         *   // Traverses all descendant nodes.\n         * })\n         */\n\n\n        _proto.walk = function walk(callback) {\n          return this.each(function (child, i) {\n            var result;\n\n            try {\n              result = callback(child, i);\n            } catch (e) {\n              e.postcssNode = child;\n\n              if (e.stack && child.source && /\\n\\s{4}at /.test(e.stack)) {\n                var s = child.source;\n                e.stack = e.stack.replace(/\\n\\s{4}at /, \"$&\" + s.input.from + \":\" + s.start.line + \":\" + s.start.column + \"$&\");\n              }\n\n              throw e;\n            }\n\n            if (result !== false && child.walk) {\n              result = child.walk(callback);\n            }\n\n            return result;\n          });\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each declaration node.\n         *\n         * If you pass a filter, iteration will only happen over declarations\n         * with matching properties.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [prop]   String or regular expression\n         *                                 to filter declarations by property name.\n         * @param {childIterator} callback Iterator receives each node and index.\n         *\n         * @return {false|undefined} Returns `false` if iteration was broke.\n         *\n         * @example\n         * root.walkDecls(decl => {\n         *   checkPropertySupport(decl.prop)\n         * })\n         *\n         * root.walkDecls('border-radius', decl => {\n         *   decl.remove()\n         * })\n         *\n         * root.walkDecls(/^background/, decl => {\n         *   decl.value = takeFirstColorFromGradient(decl.value)\n         * })\n         */\n\n\n        _proto.walkDecls = function walkDecls(prop, callback) {\n          if (!callback) {\n            callback = prop;\n            return this.walk(function (child, i) {\n              if (child.type === 'decl') {\n                return callback(child, i);\n              }\n            });\n          }\n\n          if (prop instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'decl' && prop.test(child.prop)) {\n                return callback(child, i);\n              }\n            });\n          }\n\n          return this.walk(function (child, i) {\n            if (child.type === 'decl' && child.prop === prop) {\n              return callback(child, i);\n            }\n          });\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each rule node.\n         *\n         * If you pass a filter, iteration will only happen over rules\n         * with matching selectors.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [selector] String or regular expression\n         *                                   to filter rules by selector.\n         * @param {childIterator} callback   Iterator receives each node and index.\n         *\n         * @return {false|undefined} returns `false` if iteration was broke.\n         *\n         * @example\n         * const selectors = []\n         * root.walkRules(rule => {\n         *   selectors.push(rule.selector)\n         * })\n         * console.log(`Your CSS uses ${ selectors.length } selectors`)\n         */\n\n\n        _proto.walkRules = function walkRules(selector, callback) {\n          if (!callback) {\n            callback = selector;\n            return this.walk(function (child, i) {\n              if (child.type === 'rule') {\n                return callback(child, i);\n              }\n            });\n          }\n\n          if (selector instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'rule' && selector.test(child.selector)) {\n                return callback(child, i);\n              }\n            });\n          }\n\n          return this.walk(function (child, i) {\n            if (child.type === 'rule' && child.selector === selector) {\n              return callback(child, i);\n            }\n          });\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each at-rule node.\n         *\n         * If you pass a filter, iteration will only happen over at-rules\n         * that have matching names.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [name]   String or regular expression\n         *                                 to filter at-rules by name.\n         * @param {childIterator} callback Iterator receives each node and index.\n         *\n         * @return {false|undefined} Returns `false` if iteration was broke.\n         *\n         * @example\n         * root.walkAtRules(rule => {\n         *   if (isOld(rule.name)) rule.remove()\n         * })\n         *\n         * let first = false\n         * root.walkAtRules('charset', rule => {\n         *   if (!first) {\n         *     first = true\n         *   } else {\n         *     rule.remove()\n         *   }\n         * })\n         */\n\n\n        _proto.walkAtRules = function walkAtRules(name, callback) {\n          if (!callback) {\n            callback = name;\n            return this.walk(function (child, i) {\n              if (child.type === 'atrule') {\n                return callback(child, i);\n              }\n            });\n          }\n\n          if (name instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'atrule' && name.test(child.name)) {\n                return callback(child, i);\n              }\n            });\n          }\n\n          return this.walk(function (child, i) {\n            if (child.type === 'atrule' && child.name === name) {\n              return callback(child, i);\n            }\n          });\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each comment node.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {childIterator} callback Iterator receives each node and index.\n         *\n         * @return {false|undefined} Returns `false` if iteration was broke.\n         *\n         * @example\n         * root.walkComments(comment => {\n         *   comment.remove()\n         * })\n         */\n\n\n        _proto.walkComments = function walkComments(callback) {\n          return this.walk(function (child, i) {\n            if (child.type === 'comment') {\n              return callback(child, i);\n            }\n          });\n        };\n        /**\n         * Inserts new nodes to the end of the container.\n         *\n         * @param {...(Node|object|string|Node[])} children New nodes.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n         * rule.append(decl1, decl2)\n         *\n         * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n         * root.append({ selector: 'a' })                       // rule\n         * rule.append({ prop: 'color', value: 'black' })       // declaration\n         * rule.append({ text: 'Comment' })                     // comment\n         *\n         * root.append('a {}')\n         * root.first.append('color: black; z-index: 1')\n         */\n\n\n        _proto.append = function append() {\n          for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n            children[_key] = arguments[_key];\n          }\n\n          for (var _i = 0; _i < children.length; _i++) {\n            var child = children[_i];\n            var nodes = this.normalize(child, this.last);\n\n            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i2 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n              var _ref;\n\n              if (_isArray) {\n                if (_i2 >= _iterator.length) break;\n                _ref = _iterator[_i2++];\n              } else {\n                _i2 = _iterator.next();\n                if (_i2.done) break;\n                _ref = _i2.value;\n              }\n\n              var node = _ref;\n              this.nodes.push(node);\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Inserts new nodes to the start of the container.\n         *\n         * @param {...(Node|object|string|Node[])} children New nodes.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * const decl1 = postcss.decl({ prop: 'color', value: 'black' })\n         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' })\n         * rule.prepend(decl1, decl2)\n         *\n         * root.append({ name: 'charset', params: '\"UTF-8\"' })  // at-rule\n         * root.append({ selector: 'a' })                       // rule\n         * rule.append({ prop: 'color', value: 'black' })       // declaration\n         * rule.append({ text: 'Comment' })                     // comment\n         *\n         * root.append('a {}')\n         * root.first.append('color: black; z-index: 1')\n         */\n\n\n        _proto.prepend = function prepend() {\n          for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            children[_key2] = arguments[_key2];\n          }\n\n          children = children.reverse();\n\n          for (var _iterator2 = children, _isArray2 = Array.isArray(_iterator2), _i3 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n            var _ref2;\n\n            if (_isArray2) {\n              if (_i3 >= _iterator2.length) break;\n              _ref2 = _iterator2[_i3++];\n            } else {\n              _i3 = _iterator2.next();\n              if (_i3.done) break;\n              _ref2 = _i3.value;\n            }\n\n            var child = _ref2;\n            var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n            for (var _iterator3 = nodes, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n              var _ref3;\n\n              if (_isArray3) {\n                if (_i4 >= _iterator3.length) break;\n                _ref3 = _iterator3[_i4++];\n              } else {\n                _i4 = _iterator3.next();\n                if (_i4.done) break;\n                _ref3 = _i4.value;\n              }\n\n              var node = _ref3;\n              this.nodes.unshift(node);\n            }\n\n            for (var id in this.indexes) {\n              this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n          }\n\n          return this;\n        };\n\n        _proto.cleanRaws = function cleanRaws(keepBetween) {\n          _Node.prototype.cleanRaws.call(this, keepBetween);\n\n          if (this.nodes) {\n            for (var _iterator4 = this.nodes, _isArray4 = Array.isArray(_iterator4), _i5 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n              var _ref4;\n\n              if (_isArray4) {\n                if (_i5 >= _iterator4.length) break;\n                _ref4 = _iterator4[_i5++];\n              } else {\n                _i5 = _iterator4.next();\n                if (_i5.done) break;\n                _ref4 = _i5.value;\n              }\n\n              var node = _ref4;\n              node.cleanRaws(keepBetween);\n            }\n          }\n        };\n        /**\n         * Insert new node before old node within the container.\n         *\n         * @param {Node|number} exist             Child or childs index.\n         * @param {Node|object|string|Node[]} add New node.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))\n         */\n\n\n        _proto.insertBefore = function insertBefore(exist, add) {\n          exist = this.index(exist);\n          var type = exist === 0 ? 'prepend' : false;\n          var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n          for (var _iterator5 = nodes, _isArray5 = Array.isArray(_iterator5), _i6 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n            var _ref5;\n\n            if (_isArray5) {\n              if (_i6 >= _iterator5.length) break;\n              _ref5 = _iterator5[_i6++];\n            } else {\n              _i6 = _iterator5.next();\n              if (_i6.done) break;\n              _ref5 = _i6.value;\n            }\n\n            var node = _ref5;\n            this.nodes.splice(exist, 0, node);\n          }\n\n          var index;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (exist <= index) {\n              this.indexes[id] = index + nodes.length;\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Insert new node after old node within the container.\n         *\n         * @param {Node|number} exist             Child or childs index.\n         * @param {Node|object|string|Node[]} add New node.\n         *\n         * @return {Node} This node for methods chain.\n         */\n\n\n        _proto.insertAfter = function insertAfter(exist, add) {\n          exist = this.index(exist);\n          var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n          for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i7 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n            var _ref6;\n\n            if (_isArray6) {\n              if (_i7 >= _iterator6.length) break;\n              _ref6 = _iterator6[_i7++];\n            } else {\n              _i7 = _iterator6.next();\n              if (_i7.done) break;\n              _ref6 = _i7.value;\n            }\n\n            var node = _ref6;\n            this.nodes.splice(exist + 1, 0, node);\n          }\n\n          var index;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (exist < index) {\n              this.indexes[id] = index + nodes.length;\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Removes node from the container and cleans the parent properties\n         * from the node and its children.\n         *\n         * @param {Node|number} child Child or childs index.\n         *\n         * @return {Node} This node for methods chain\n         *\n         * @example\n         * rule.nodes.length  //=> 5\n         * rule.removeChild(decl)\n         * rule.nodes.length  //=> 4\n         * decl.parent        //=> undefined\n         */\n\n\n        _proto.removeChild = function removeChild(child) {\n          child = this.index(child);\n          this.nodes[child].parent = undefined;\n          this.nodes.splice(child, 1);\n          var index;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (index >= child) {\n              this.indexes[id] = index - 1;\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Removes all children from the container\n         * and cleans their parent properties.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * rule.removeAll()\n         * rule.nodes.length //=> 0\n         */\n\n\n        _proto.removeAll = function removeAll() {\n          for (var _iterator7 = this.nodes, _isArray7 = Array.isArray(_iterator7), _i8 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n            var _ref7;\n\n            if (_isArray7) {\n              if (_i8 >= _iterator7.length) break;\n              _ref7 = _iterator7[_i8++];\n            } else {\n              _i8 = _iterator7.next();\n              if (_i8.done) break;\n              _ref7 = _i8.value;\n            }\n\n            var node = _ref7;\n            node.parent = undefined;\n          }\n\n          this.nodes = [];\n          return this;\n        };\n        /**\n         * Passes all declaration values within the container that match pattern\n         * through callback, replacing those values with the returned result\n         * of callback.\n         *\n         * This method is useful if you are using a custom unit or function\n         * and need to iterate through all values.\n         *\n         * @param {string|RegExp} pattern      Replace pattern.\n         * @param {object} opts                Options to speed up the search.\n         * @param {string|string[]} opts.props An array of property names.\n         * @param {string} opts.fast           String thats used to narrow down\n         *                                     values and speed up the regexp search.\n         * @param {function|string} callback   String to replace pattern or callback\n         *                                     that returns a new value. The callback\n         *                                     will receive the same arguments\n         *                                     as those passed to a function parameter\n         *                                     of `String#replace`.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n         *   return 15 * parseInt(string) + 'px'\n         * })\n         */\n\n\n        _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n          if (!callback) {\n            callback = opts;\n            opts = {};\n          }\n\n          this.walkDecls(function (decl) {\n            if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n            if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n            decl.value = decl.value.replace(pattern, callback);\n          });\n          return this;\n        };\n        /**\n         * Returns `true` if callback returns `true`\n         * for all of the containers children.\n         *\n         * @param {childCondition} condition Iterator returns true or false.\n         *\n         * @return {boolean} Is every child pass condition.\n         *\n         * @example\n         * const noPrefixes = rule.every(i => i.prop[0] !== '-')\n         */\n\n\n        _proto.every = function every(condition) {\n          return this.nodes.every(condition);\n        };\n        /**\n         * Returns `true` if callback returns `true` for (at least) one\n         * of the containers children.\n         *\n         * @param {childCondition} condition Iterator returns true or false.\n         *\n         * @return {boolean} Is some child pass condition.\n         *\n         * @example\n         * const hasPrefix = rule.some(i => i.prop[0] === '-')\n         */\n\n\n        _proto.some = function some(condition) {\n          return this.nodes.some(condition);\n        };\n        /**\n         * Returns a `child`s index within the {@link Container#nodes} array.\n         *\n         * @param {Node} child Child of the current container.\n         *\n         * @return {number} Child index.\n         *\n         * @example\n         * rule.index( rule.nodes[2] ) //=> 2\n         */\n\n\n        _proto.index = function index(child) {\n          if (typeof child === 'number') {\n            return child;\n          }\n\n          return this.nodes.indexOf(child);\n        };\n        /**\n         * The containers first child.\n         *\n         * @type {Node}\n         *\n         * @example\n         * rule.first === rules.nodes[0]\n         */\n\n\n        _proto.normalize = function normalize(nodes, sample) {\n          var _this = this;\n\n          if (typeof nodes === 'string') {\n            var parse = __webpack_require__(69);\n\n            nodes = cleanSource(parse(nodes).nodes);\n          } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n\n            for (var _iterator8 = nodes, _isArray8 = Array.isArray(_iterator8), _i9 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n              var _ref8;\n\n              if (_isArray8) {\n                if (_i9 >= _iterator8.length) break;\n                _ref8 = _iterator8[_i9++];\n              } else {\n                _i9 = _iterator8.next();\n                if (_i9.done) break;\n                _ref8 = _i9.value;\n              }\n\n              var i = _ref8;\n              if (i.parent) i.parent.removeChild(i, 'ignore');\n            }\n          } else if (nodes.type === 'root') {\n            nodes = nodes.nodes.slice(0);\n\n            for (var _iterator9 = nodes, _isArray9 = Array.isArray(_iterator9), _i10 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n              var _ref9;\n\n              if (_isArray9) {\n                if (_i10 >= _iterator9.length) break;\n                _ref9 = _iterator9[_i10++];\n              } else {\n                _i10 = _iterator9.next();\n                if (_i10.done) break;\n                _ref9 = _i10.value;\n              }\n\n              var _i11 = _ref9;\n              if (_i11.parent) _i11.parent.removeChild(_i11, 'ignore');\n            }\n          } else if (nodes.type) {\n            nodes = [nodes];\n          } else if (nodes.prop) {\n            if (typeof nodes.value === 'undefined') {\n              throw new Error('Value field is missed in node creation');\n            } else if (typeof nodes.value !== 'string') {\n              nodes.value = String(nodes.value);\n            }\n\n            nodes = [new _declaration.default(nodes)];\n          } else if (nodes.selector) {\n            var Rule = __webpack_require__(70);\n\n            nodes = [new Rule(nodes)];\n          } else if (nodes.name) {\n            var AtRule = __webpack_require__(68);\n\n            nodes = [new AtRule(nodes)];\n          } else if (nodes.text) {\n            nodes = [new _comment.default(nodes)];\n          } else {\n            throw new Error('Unknown node type in node creation');\n          }\n\n          var processed = nodes.map(function (i) {\n            if (i.parent) i.parent.removeChild(i);\n\n            if (typeof i.raws.before === 'undefined') {\n              if (sample && typeof sample.raws.before !== 'undefined') {\n                i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n              }\n            }\n\n            i.parent = _this;\n            return i;\n          });\n          return processed;\n        };\n        /**\n         * @memberof Container#\n         * @member {Node[]} nodes An array containing the containers children.\n         *\n         * @example\n         * const root = postcss.parse('a { color: black }')\n         * root.nodes.length           //=> 1\n         * root.nodes[0].selector      //=> 'a'\n         * root.nodes[0].nodes[0].prop //=> 'color'\n         */\n\n\n        _createClass(Container, [{\n          key: \"first\",\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[0];\n          }\n          /**\n           * The containers last child.\n           *\n           * @type {Node}\n           *\n           * @example\n           * rule.last === rule.nodes[rule.nodes.length - 1]\n           */\n\n        }, {\n          key: \"last\",\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[this.nodes.length - 1];\n          }\n        }]);\n\n        return Container;\n      }(_node.default);\n\n      var _default = Container;\n      /**\n       * @callback childCondition\n       * @param {Node} node    Container child.\n       * @param {number} index Child index.\n       * @param {Node[]} nodes All container children.\n       * @return {boolean}\n       */\n\n      /**\n       * @callback childIterator\n       * @param {Node} node    Container child.\n       * @param {number} index Child index.\n       * @return {false|undefined} Returning `false` will break iteration.\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = lessStringify;\n\n      var _lessStringifier = __webpack_require__(163);\n\n      var _lessStringifier2 = _interopRequireDefault(_lessStringifier);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function lessStringify(node, builder) {\n        var str = new _lessStringifier2.default(builder);\n        str.stringify(node);\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports) {\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      var g; // This works in non-strict mode\n\n      g = function () {\n        return this;\n      }();\n\n      try {\n        // This works if eval is allowed (see CSP)\n        g = g || Function(\"return this\")() || (1, eval)(\"this\");\n      } catch (e) {\n        // This works if the window reference is available\n        if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n      } // g can still be undefined, but nothing to do about it...\n      // We return undefined, instead of nothing here, so it's\n      // easier to handle this case. if(!global) { ...}\n\n\n      module.exports = g;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      var _types = __webpack_require__(0);\n\n      var types = _interopRequireWildcard(_types);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj.default = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Container = function (_Node) {\n        _inherits(Container, _Node);\n\n        function Container(opts) {\n          _classCallCheck(this, Container);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, opts));\n\n          if (!_this.nodes) {\n            _this.nodes = [];\n          }\n\n          return _this;\n        }\n\n        Container.prototype.append = function append(selector) {\n          selector.parent = this;\n          this.nodes.push(selector);\n          return this;\n        };\n\n        Container.prototype.prepend = function prepend(selector) {\n          selector.parent = this;\n          this.nodes.unshift(selector);\n          return this;\n        };\n\n        Container.prototype.at = function at(index) {\n          return this.nodes[index];\n        };\n\n        Container.prototype.index = function index(child) {\n          if (typeof child === 'number') {\n            return child;\n          }\n\n          return this.nodes.indexOf(child);\n        };\n\n        Container.prototype.removeChild = function removeChild(child) {\n          child = this.index(child);\n          this.at(child).parent = undefined;\n          this.nodes.splice(child, 1);\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (index >= child) {\n              this.indexes[id] = index - 1;\n            }\n          }\n\n          return this;\n        };\n\n        Container.prototype.removeAll = function removeAll() {\n          for (var _iterator = this.nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var node = _ref;\n            node.parent = undefined;\n          }\n\n          this.nodes = [];\n          return this;\n        };\n\n        Container.prototype.empty = function empty() {\n          return this.removeAll();\n        };\n\n        Container.prototype.insertAfter = function insertAfter(oldNode, newNode) {\n          var oldIndex = this.index(oldNode);\n          this.nodes.splice(oldIndex + 1, 0, newNode);\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (oldIndex <= index) {\n              this.indexes[id] = index + this.nodes.length;\n            }\n          }\n\n          return this;\n        };\n\n        Container.prototype.insertBefore = function insertBefore(oldNode, newNode) {\n          var oldIndex = this.index(oldNode);\n          this.nodes.splice(oldIndex, 0, newNode);\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (oldIndex <= index) {\n              this.indexes[id] = index + this.nodes.length;\n            }\n          }\n\n          return this;\n        };\n\n        Container.prototype.each = function each(callback) {\n          if (!this.lastEach) {\n            this.lastEach = 0;\n          }\n\n          if (!this.indexes) {\n            this.indexes = {};\n          }\n\n          this.lastEach++;\n          var id = this.lastEach;\n          this.indexes[id] = 0;\n\n          if (!this.length) {\n            return undefined;\n          }\n\n          var index = void 0,\n              result = void 0;\n\n          while (this.indexes[id] < this.length) {\n            index = this.indexes[id];\n            result = callback(this.at(index), index);\n\n            if (result === false) {\n              break;\n            }\n\n            this.indexes[id] += 1;\n          }\n\n          delete this.indexes[id];\n\n          if (result === false) {\n            return false;\n          }\n        };\n\n        Container.prototype.walk = function walk(callback) {\n          return this.each(function (node, i) {\n            var result = callback(node, i);\n\n            if (result !== false && node.length) {\n              result = node.walk(callback);\n            }\n\n            if (result === false) {\n              return false;\n            }\n          });\n        };\n\n        Container.prototype.walkAttributes = function walkAttributes(callback) {\n          var _this2 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.ATTRIBUTE) {\n              return callback.call(_this2, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkClasses = function walkClasses(callback) {\n          var _this3 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.CLASS) {\n              return callback.call(_this3, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkCombinators = function walkCombinators(callback) {\n          var _this4 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.COMBINATOR) {\n              return callback.call(_this4, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkComments = function walkComments(callback) {\n          var _this5 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.COMMENT) {\n              return callback.call(_this5, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkIds = function walkIds(callback) {\n          var _this6 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.ID) {\n              return callback.call(_this6, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkNesting = function walkNesting(callback) {\n          var _this7 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.NESTING) {\n              return callback.call(_this7, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkPseudos = function walkPseudos(callback) {\n          var _this8 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.PSEUDO) {\n              return callback.call(_this8, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkTags = function walkTags(callback) {\n          var _this9 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.TAG) {\n              return callback.call(_this9, selector);\n            }\n          });\n        };\n\n        Container.prototype.walkUniversals = function walkUniversals(callback) {\n          var _this10 = this;\n\n          return this.walk(function (selector) {\n            if (selector.type === types.UNIVERSAL) {\n              return callback.call(_this10, selector);\n            }\n          });\n        };\n\n        Container.prototype.split = function split(callback) {\n          var _this11 = this;\n\n          var current = [];\n          return this.reduce(function (memo, node, index) {\n            var split = callback.call(_this11, node);\n            current.push(node);\n\n            if (split) {\n              memo.push(current);\n              current = [];\n            } else if (index === _this11.length - 1) {\n              memo.push(current);\n            }\n\n            return memo;\n          }, []);\n        };\n\n        Container.prototype.map = function map(callback) {\n          return this.nodes.map(callback);\n        };\n\n        Container.prototype.reduce = function reduce(callback, memo) {\n          return this.nodes.reduce(callback, memo);\n        };\n\n        Container.prototype.every = function every(callback) {\n          return this.nodes.every(callback);\n        };\n\n        Container.prototype.some = function some(callback) {\n          return this.nodes.some(callback);\n        };\n\n        Container.prototype.filter = function filter(callback) {\n          return this.nodes.filter(callback);\n        };\n\n        Container.prototype.sort = function sort(callback) {\n          return this.nodes.sort(callback);\n        };\n\n        Container.prototype.toString = function toString() {\n          return this.map(String).join('');\n        };\n\n        _createClass(Container, [{\n          key: 'first',\n          get: function get() {\n            return this.at(0);\n          }\n        }, {\n          key: 'last',\n          get: function get() {\n            return this.at(this.length - 1);\n          }\n        }, {\n          key: 'length',\n          get: function get() {\n            return this.nodes.length;\n          }\n        }]);\n\n        return Container;\n      }(_node2.default);\n\n      exports.default = Container;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n      var DEFAULT_RAW = {\n        colon: ': ',\n        indent: '    ',\n        beforeDecl: '\\n',\n        beforeRule: '\\n',\n        beforeOpen: ' ',\n        beforeClose: '\\n',\n        beforeComment: '\\n',\n        after: '\\n',\n        emptyBody: '',\n        commentLeft: ' ',\n        commentRight: ' '\n      };\n\n      function capitalize(str) {\n        return str[0].toUpperCase() + str.slice(1);\n      }\n\n      var Stringifier =\n      /*#__PURE__*/\n      function () {\n        function Stringifier(builder) {\n          this.builder = builder;\n        }\n\n        var _proto = Stringifier.prototype;\n\n        _proto.stringify = function stringify(node, semicolon) {\n          this[node.type](node, semicolon);\n        };\n\n        _proto.root = function root(node) {\n          this.body(node);\n          if (node.raws.after) this.builder(node.raws.after);\n        };\n\n        _proto.comment = function comment(node) {\n          var left = this.raw(node, 'left', 'commentLeft');\n          var right = this.raw(node, 'right', 'commentRight');\n          this.builder('/*' + left + node.text + right + '*/', node);\n        };\n\n        _proto.decl = function decl(node, semicolon) {\n          var between = this.raw(node, 'between', 'colon');\n          var string = node.prop + between + this.rawValue(node, 'value');\n\n          if (node.important) {\n            string += node.raws.important || ' !important';\n          }\n\n          if (semicolon) string += ';';\n          this.builder(string, node);\n        };\n\n        _proto.rule = function rule(node) {\n          this.block(node, this.rawValue(node, 'selector'));\n\n          if (node.raws.ownSemicolon) {\n            this.builder(node.raws.ownSemicolon, node, 'end');\n          }\n        };\n\n        _proto.atrule = function atrule(node, semicolon) {\n          var name = '@' + node.name;\n          var params = node.params ? this.rawValue(node, 'params') : '';\n\n          if (typeof node.raws.afterName !== 'undefined') {\n            name += node.raws.afterName;\n          } else if (params) {\n            name += ' ';\n          }\n\n          if (node.nodes) {\n            this.block(node, name + params);\n          } else {\n            var end = (node.raws.between || '') + (semicolon ? ';' : '');\n            this.builder(name + params + end, node);\n          }\n        };\n\n        _proto.body = function body(node) {\n          var last = node.nodes.length - 1;\n\n          while (last > 0) {\n            if (node.nodes[last].type !== 'comment') break;\n            last -= 1;\n          }\n\n          var semicolon = this.raw(node, 'semicolon');\n\n          for (var i = 0; i < node.nodes.length; i++) {\n            var child = node.nodes[i];\n            var before = this.raw(child, 'before');\n            if (before) this.builder(before);\n            this.stringify(child, last !== i || semicolon);\n          }\n        };\n\n        _proto.block = function block(node, start) {\n          var between = this.raw(node, 'between', 'beforeOpen');\n          this.builder(start + between + '{', node, 'start');\n          var after;\n\n          if (node.nodes && node.nodes.length) {\n            this.body(node);\n            after = this.raw(node, 'after');\n          } else {\n            after = this.raw(node, 'after', 'emptyBody');\n          }\n\n          if (after) this.builder(after);\n          this.builder('}', node, 'end');\n        };\n\n        _proto.raw = function raw(node, own, detect) {\n          var value;\n          if (!detect) detect = own; // Already had\n\n          if (own) {\n            value = node.raws[own];\n            if (typeof value !== 'undefined') return value;\n          }\n\n          var parent = node.parent; // Hack for first rule in CSS\n\n          if (detect === 'before') {\n            if (!parent || parent.type === 'root' && parent.first === node) {\n              return '';\n            }\n          } // Floating child without parent\n\n\n          if (!parent) return DEFAULT_RAW[detect]; // Detect style by other nodes\n\n          var root = node.root();\n          if (!root.rawCache) root.rawCache = {};\n\n          if (typeof root.rawCache[detect] !== 'undefined') {\n            return root.rawCache[detect];\n          }\n\n          if (detect === 'before' || detect === 'after') {\n            return this.beforeAfter(node, detect);\n          } else {\n            var method = 'raw' + capitalize(detect);\n\n            if (this[method]) {\n              value = this[method](root, node);\n            } else {\n              root.walk(function (i) {\n                value = i.raws[own];\n                if (typeof value !== 'undefined') return false;\n              });\n            }\n          }\n\n          if (typeof value === 'undefined') value = DEFAULT_RAW[detect];\n          root.rawCache[detect] = value;\n          return value;\n        };\n\n        _proto.rawSemicolon = function rawSemicolon(root) {\n          var value;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n              value = i.raws.semicolon;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        _proto.rawEmptyBody = function rawEmptyBody(root) {\n          var value;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length === 0) {\n              value = i.raws.after;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        _proto.rawIndent = function rawIndent(root) {\n          if (root.raws.indent) return root.raws.indent;\n          var value;\n          root.walk(function (i) {\n            var p = i.parent;\n\n            if (p && p !== root && p.parent && p.parent === root) {\n              if (typeof i.raws.before !== 'undefined') {\n                var parts = i.raws.before.split('\\n');\n                value = parts[parts.length - 1];\n                value = value.replace(/[^\\s]/g, '');\n                return false;\n              }\n            }\n          });\n          return value;\n        };\n\n        _proto.rawBeforeComment = function rawBeforeComment(root, node) {\n          var value;\n          root.walkComments(function (i) {\n            if (typeof i.raws.before !== 'undefined') {\n              value = i.raws.before;\n\n              if (value.indexOf('\\n') !== -1) {\n                value = value.replace(/[^\\n]+$/, '');\n              }\n\n              return false;\n            }\n          });\n\n          if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeDecl');\n          } else if (value) {\n            value = value.replace(/[^\\s]/g, '');\n          }\n\n          return value;\n        };\n\n        _proto.rawBeforeDecl = function rawBeforeDecl(root, node) {\n          var value;\n          root.walkDecls(function (i) {\n            if (typeof i.raws.before !== 'undefined') {\n              value = i.raws.before;\n\n              if (value.indexOf('\\n') !== -1) {\n                value = value.replace(/[^\\n]+$/, '');\n              }\n\n              return false;\n            }\n          });\n\n          if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeRule');\n          } else if (value) {\n            value = value.replace(/[^\\s]/g, '');\n          }\n\n          return value;\n        };\n\n        _proto.rawBeforeRule = function rawBeforeRule(root) {\n          var value;\n          root.walk(function (i) {\n            if (i.nodes && (i.parent !== root || root.first !== i)) {\n              if (typeof i.raws.before !== 'undefined') {\n                value = i.raws.before;\n\n                if (value.indexOf('\\n') !== -1) {\n                  value = value.replace(/[^\\n]+$/, '');\n                }\n\n                return false;\n              }\n            }\n          });\n          if (value) value = value.replace(/[^\\s]/g, '');\n          return value;\n        };\n\n        _proto.rawBeforeClose = function rawBeforeClose(root) {\n          var value;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length > 0) {\n              if (typeof i.raws.after !== 'undefined') {\n                value = i.raws.after;\n\n                if (value.indexOf('\\n') !== -1) {\n                  value = value.replace(/[^\\n]+$/, '');\n                }\n\n                return false;\n              }\n            }\n          });\n          if (value) value = value.replace(/[^\\s]/g, '');\n          return value;\n        };\n\n        _proto.rawBeforeOpen = function rawBeforeOpen(root) {\n          var value;\n          root.walk(function (i) {\n            if (i.type !== 'decl') {\n              value = i.raws.between;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        _proto.rawColon = function rawColon(root) {\n          var value;\n          root.walkDecls(function (i) {\n            if (typeof i.raws.between !== 'undefined') {\n              value = i.raws.between.replace(/[^\\s:]/g, '');\n              return false;\n            }\n          });\n          return value;\n        };\n\n        _proto.beforeAfter = function beforeAfter(node, detect) {\n          var value;\n\n          if (node.type === 'decl') {\n            value = this.raw(node, null, 'beforeDecl');\n          } else if (node.type === 'comment') {\n            value = this.raw(node, null, 'beforeComment');\n          } else if (detect === 'before') {\n            value = this.raw(node, null, 'beforeRule');\n          } else {\n            value = this.raw(node, null, 'beforeClose');\n          }\n\n          var buf = node.parent;\n          var depth = 0;\n\n          while (buf && buf.type !== 'root') {\n            depth += 1;\n            buf = buf.parent;\n          }\n\n          if (value.indexOf('\\n') !== -1) {\n            var indent = this.raw(node, null, 'indent');\n\n            if (indent.length) {\n              for (var step = 0; step < depth; step++) {\n                value += indent;\n              }\n            }\n          }\n\n          return value;\n        };\n\n        _proto.rawValue = function rawValue(node, prop) {\n          var value = node[prop];\n          var raw = node.raws[prop];\n\n          if (raw && raw.value === value) {\n            return raw.raw;\n          }\n\n          return value;\n        };\n\n        return Stringifier;\n      }();\n\n      var _default = Stringifier;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (global) {\n        /*!\n        * The buffer module from node.js, for the browser.\n        *\n        * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n        * @license  MIT\n        */\n\n        /* eslint-disable no-proto */\n        var base64 = __webpack_require__(121);\n\n        var ieee754 = __webpack_require__(122);\n\n        var isArray = __webpack_require__(123);\n\n        exports.Buffer = Buffer;\n        exports.SlowBuffer = SlowBuffer;\n        exports.INSPECT_MAX_BYTES = 50;\n        /**\n         * If `Buffer.TYPED_ARRAY_SUPPORT`:\n         *   === true    Use Uint8Array implementation (fastest)\n         *   === false   Use Object implementation (most compatible, even IE6)\n         *\n         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n         * Opera 11.6+, iOS 4.2+.\n         *\n         * Due to various browser bugs, sometimes the Object implementation will be used even\n         * when the browser supports typed arrays.\n         *\n         * Note:\n         *\n         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n         *\n         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n         *\n         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n         *     incorrect length in some situations.\n        \n         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n         * get the Object implementation, which is slower but behaves correctly.\n         */\n\n        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();\n        /*\n         * Export kMaxLength after typed array support is determined.\n         */\n\n        exports.kMaxLength = kMaxLength();\n\n        function typedArraySupport() {\n          try {\n            var arr = new Uint8Array(1);\n            arr.__proto__ = {\n              __proto__: Uint8Array.prototype,\n              foo: function foo() {\n                return 42;\n              }\n            };\n            return arr.foo() === 42 && // typed array instances can be augmented\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`\n          } catch (e) {\n            return false;\n          }\n        }\n\n        function kMaxLength() {\n          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;\n        }\n\n        function createBuffer(that, length) {\n          if (kMaxLength() < length) {\n            throw new RangeError('Invalid typed array length');\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = new Uint8Array(length);\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            if (that === null) {\n              that = new Buffer(length);\n            }\n\n            that.length = length;\n          }\n\n          return that;\n        }\n        /**\n         * The Buffer constructor returns instances of `Uint8Array` that have their\n         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n         * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n         * returns a single octet.\n         *\n         * The `Uint8Array` prototype remains unmodified.\n         */\n\n\n        function Buffer(arg, encodingOrOffset, length) {\n          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n            return new Buffer(arg, encodingOrOffset, length);\n          } // Common case.\n\n\n          if (typeof arg === 'number') {\n            if (typeof encodingOrOffset === 'string') {\n              throw new Error('If encoding is specified then the first argument must be a string');\n            }\n\n            return allocUnsafe(this, arg);\n          }\n\n          return from(this, arg, encodingOrOffset, length);\n        }\n\n        Buffer.poolSize = 8192; // not used by this implementation\n        // TODO: Legacy, not needed anymore. Remove in next major version.\n\n        Buffer._augment = function (arr) {\n          arr.__proto__ = Buffer.prototype;\n          return arr;\n        };\n\n        function from(that, value, encodingOrOffset, length) {\n          if (typeof value === 'number') {\n            throw new TypeError('\"value\" argument must not be a number');\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n            return fromArrayBuffer(that, value, encodingOrOffset, length);\n          }\n\n          if (typeof value === 'string') {\n            return fromString(that, value, encodingOrOffset);\n          }\n\n          return fromObject(that, value);\n        }\n        /**\n         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n         * if value is a number.\n         * Buffer.from(str[, encoding])\n         * Buffer.from(array)\n         * Buffer.from(buffer)\n         * Buffer.from(arrayBuffer[, byteOffset[, length]])\n         **/\n\n\n        Buffer.from = function (value, encodingOrOffset, length) {\n          return from(null, value, encodingOrOffset, length);\n        };\n\n        if (Buffer.TYPED_ARRAY_SUPPORT) {\n          Buffer.prototype.__proto__ = Uint8Array.prototype;\n          Buffer.__proto__ = Uint8Array;\n\n          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {\n            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n            Object.defineProperty(Buffer, Symbol.species, {\n              value: null,\n              configurable: true\n            });\n          }\n        }\n\n        function assertSize(size) {\n          if (typeof size !== 'number') {\n            throw new TypeError('\"size\" argument must be a number');\n          } else if (size < 0) {\n            throw new RangeError('\"size\" argument must not be negative');\n          }\n        }\n\n        function alloc(that, size, fill, encoding) {\n          assertSize(size);\n\n          if (size <= 0) {\n            return createBuffer(that, size);\n          }\n\n          if (fill !== undefined) {\n            // Only pay attention to encoding if it's a string. This\n            // prevents accidentally sending in a number that would\n            // be interpretted as a start offset.\n            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);\n          }\n\n          return createBuffer(that, size);\n        }\n        /**\n         * Creates a new filled Buffer instance.\n         * alloc(size[, fill[, encoding]])\n         **/\n\n\n        Buffer.alloc = function (size, fill, encoding) {\n          return alloc(null, size, fill, encoding);\n        };\n\n        function allocUnsafe(that, size) {\n          assertSize(size);\n          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT) {\n            for (var i = 0; i < size; ++i) {\n              that[i] = 0;\n            }\n          }\n\n          return that;\n        }\n        /**\n         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n         * */\n\n\n        Buffer.allocUnsafe = function (size) {\n          return allocUnsafe(null, size);\n        };\n        /**\n         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n         */\n\n\n        Buffer.allocUnsafeSlow = function (size) {\n          return allocUnsafe(null, size);\n        };\n\n        function fromString(that, string, encoding) {\n          if (typeof encoding !== 'string' || encoding === '') {\n            encoding = 'utf8';\n          }\n\n          if (!Buffer.isEncoding(encoding)) {\n            throw new TypeError('\"encoding\" must be a valid string encoding');\n          }\n\n          var length = byteLength(string, encoding) | 0;\n          that = createBuffer(that, length);\n          var actual = that.write(string, encoding);\n\n          if (actual !== length) {\n            // Writing a hex string, for example, that contains invalid characters will\n            // cause everything after the first invalid character to be ignored. (e.g.\n            // 'abxxcd' will be treated as 'ab')\n            that = that.slice(0, actual);\n          }\n\n          return that;\n        }\n\n        function fromArrayLike(that, array) {\n          var length = array.length < 0 ? 0 : checked(array.length) | 0;\n          that = createBuffer(that, length);\n\n          for (var i = 0; i < length; i += 1) {\n            that[i] = array[i] & 255;\n          }\n\n          return that;\n        }\n\n        function fromArrayBuffer(that, array, byteOffset, length) {\n          array.byteLength; // this throws if `array` is not a valid ArrayBuffer\n\n          if (byteOffset < 0 || array.byteLength < byteOffset) {\n            throw new RangeError('\\'offset\\' is out of bounds');\n          }\n\n          if (array.byteLength < byteOffset + (length || 0)) {\n            throw new RangeError('\\'length\\' is out of bounds');\n          }\n\n          if (byteOffset === undefined && length === undefined) {\n            array = new Uint8Array(array);\n          } else if (length === undefined) {\n            array = new Uint8Array(array, byteOffset);\n          } else {\n            array = new Uint8Array(array, byteOffset, length);\n          }\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            // Return an augmented `Uint8Array` instance, for best performance\n            that = array;\n            that.__proto__ = Buffer.prototype;\n          } else {\n            // Fallback: Return an object instance of the Buffer class\n            that = fromArrayLike(that, array);\n          }\n\n          return that;\n        }\n\n        function fromObject(that, obj) {\n          if (Buffer.isBuffer(obj)) {\n            var len = checked(obj.length) | 0;\n            that = createBuffer(that, len);\n\n            if (that.length === 0) {\n              return that;\n            }\n\n            obj.copy(that, 0, 0, len);\n            return that;\n          }\n\n          if (obj) {\n            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n              if (typeof obj.length !== 'number' || isnan(obj.length)) {\n                return createBuffer(that, 0);\n              }\n\n              return fromArrayLike(that, obj);\n            }\n\n            if (obj.type === 'Buffer' && isArray(obj.data)) {\n              return fromArrayLike(that, obj.data);\n            }\n          }\n\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n        }\n\n        function checked(length) {\n          // Note: cannot use `length < kMaxLength()` here because that fails when\n          // length is NaN (which is otherwise coerced to zero.)\n          if (length >= kMaxLength()) {\n            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');\n          }\n\n          return length | 0;\n        }\n\n        function SlowBuffer(length) {\n          if (+length != length) {\n            // eslint-disable-line eqeqeq\n            length = 0;\n          }\n\n          return Buffer.alloc(+length);\n        }\n\n        Buffer.isBuffer = function isBuffer(b) {\n          return !!(b != null && b._isBuffer);\n        };\n\n        Buffer.compare = function compare(a, b) {\n          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n            throw new TypeError('Arguments must be Buffers');\n          }\n\n          if (a === b) return 0;\n          var x = a.length;\n          var y = b.length;\n\n          for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n            if (a[i] !== b[i]) {\n              x = a[i];\n              y = b[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        };\n\n        Buffer.isEncoding = function isEncoding(encoding) {\n          switch (String(encoding).toLowerCase()) {\n            case 'hex':\n            case 'utf8':\n            case 'utf-8':\n            case 'ascii':\n            case 'latin1':\n            case 'binary':\n            case 'base64':\n            case 'ucs2':\n            case 'ucs-2':\n            case 'utf16le':\n            case 'utf-16le':\n              return true;\n\n            default:\n              return false;\n          }\n        };\n\n        Buffer.concat = function concat(list, length) {\n          if (!isArray(list)) {\n            throw new TypeError('\"list\" argument must be an Array of Buffers');\n          }\n\n          if (list.length === 0) {\n            return Buffer.alloc(0);\n          }\n\n          var i;\n\n          if (length === undefined) {\n            length = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              length += list[i].length;\n            }\n          }\n\n          var buffer = Buffer.allocUnsafe(length);\n          var pos = 0;\n\n          for (i = 0; i < list.length; ++i) {\n            var buf = list[i];\n\n            if (!Buffer.isBuffer(buf)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            buf.copy(buffer, pos);\n            pos += buf.length;\n          }\n\n          return buffer;\n        };\n\n        function byteLength(string, encoding) {\n          if (Buffer.isBuffer(string)) {\n            return string.length;\n          }\n\n          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n            return string.byteLength;\n          }\n\n          if (typeof string !== 'string') {\n            string = '' + string;\n          }\n\n          var len = string.length;\n          if (len === 0) return 0; // Use a for loop to avoid recursion\n\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n                return len;\n\n              case 'utf8':\n              case 'utf-8':\n              case undefined:\n                return utf8ToBytes(string).length;\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return len * 2;\n\n              case 'hex':\n                return len >>> 1;\n\n              case 'base64':\n                return base64ToBytes(string).length;\n\n              default:\n                if (loweredCase) return utf8ToBytes(string).length; // assume utf8\n\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        }\n\n        Buffer.byteLength = byteLength;\n\n        function slowToString(encoding, start, end) {\n          var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n          // property of a typed array.\n          // This behaves neither like String nor Uint8Array in that we set start/end\n          // to their upper/lower bounds if the value passed is out of range.\n          // undefined is handled specially as per ECMA-262 6th Edition,\n          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n          if (start === undefined || start < 0) {\n            start = 0;\n          } // Return early if start > this.length. Done here to prevent potential uint32\n          // coercion fail below.\n\n\n          if (start > this.length) {\n            return '';\n          }\n\n          if (end === undefined || end > this.length) {\n            end = this.length;\n          }\n\n          if (end <= 0) {\n            return '';\n          } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n          end >>>= 0;\n          start >>>= 0;\n\n          if (end <= start) {\n            return '';\n          }\n\n          if (!encoding) encoding = 'utf8';\n\n          while (true) {\n            switch (encoding) {\n              case 'hex':\n                return hexSlice(this, start, end);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Slice(this, start, end);\n\n              case 'ascii':\n                return asciiSlice(this, start, end);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Slice(this, start, end);\n\n              case 'base64':\n                return base64Slice(this, start, end);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return utf16leSlice(this, start, end);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = (encoding + '').toLowerCase();\n                loweredCase = true;\n            }\n          }\n        } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n        // Buffer instances.\n\n\n        Buffer.prototype._isBuffer = true;\n\n        function swap(b, n, m) {\n          var i = b[n];\n          b[n] = b[m];\n          b[m] = i;\n        }\n\n        Buffer.prototype.swap16 = function swap16() {\n          var len = this.length;\n\n          if (len % 2 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 16-bits');\n          }\n\n          for (var i = 0; i < len; i += 2) {\n            swap(this, i, i + 1);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap32 = function swap32() {\n          var len = this.length;\n\n          if (len % 4 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 32-bits');\n          }\n\n          for (var i = 0; i < len; i += 4) {\n            swap(this, i, i + 3);\n            swap(this, i + 1, i + 2);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.swap64 = function swap64() {\n          var len = this.length;\n\n          if (len % 8 !== 0) {\n            throw new RangeError('Buffer size must be a multiple of 64-bits');\n          }\n\n          for (var i = 0; i < len; i += 8) {\n            swap(this, i, i + 7);\n            swap(this, i + 1, i + 6);\n            swap(this, i + 2, i + 5);\n            swap(this, i + 3, i + 4);\n          }\n\n          return this;\n        };\n\n        Buffer.prototype.toString = function toString() {\n          var length = this.length | 0;\n          if (length === 0) return '';\n          if (arguments.length === 0) return utf8Slice(this, 0, length);\n          return slowToString.apply(this, arguments);\n        };\n\n        Buffer.prototype.equals = function equals(b) {\n          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n          if (this === b) return true;\n          return Buffer.compare(this, b) === 0;\n        };\n\n        Buffer.prototype.inspect = function inspect() {\n          var str = '';\n          var max = exports.INSPECT_MAX_BYTES;\n\n          if (this.length > 0) {\n            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n            if (this.length > max) str += ' ... ';\n          }\n\n          return '<Buffer ' + str + '>';\n        };\n\n        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n          if (!Buffer.isBuffer(target)) {\n            throw new TypeError('Argument must be a Buffer');\n          }\n\n          if (start === undefined) {\n            start = 0;\n          }\n\n          if (end === undefined) {\n            end = target ? target.length : 0;\n          }\n\n          if (thisStart === undefined) {\n            thisStart = 0;\n          }\n\n          if (thisEnd === undefined) {\n            thisEnd = this.length;\n          }\n\n          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n            throw new RangeError('out of range index');\n          }\n\n          if (thisStart >= thisEnd && start >= end) {\n            return 0;\n          }\n\n          if (thisStart >= thisEnd) {\n            return -1;\n          }\n\n          if (start >= end) {\n            return 1;\n          }\n\n          start >>>= 0;\n          end >>>= 0;\n          thisStart >>>= 0;\n          thisEnd >>>= 0;\n          if (this === target) return 0;\n          var x = thisEnd - thisStart;\n          var y = end - start;\n          var len = Math.min(x, y);\n          var thisCopy = this.slice(thisStart, thisEnd);\n          var targetCopy = target.slice(start, end);\n\n          for (var i = 0; i < len; ++i) {\n            if (thisCopy[i] !== targetCopy[i]) {\n              x = thisCopy[i];\n              y = targetCopy[i];\n              break;\n            }\n          }\n\n          if (x < y) return -1;\n          if (y < x) return 1;\n          return 0;\n        }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n        //\n        // Arguments:\n        // - buffer - a Buffer to search\n        // - val - a string, Buffer, or number\n        // - byteOffset - an index into `buffer`; will be clamped to an int32\n        // - encoding - an optional encoding, relevant is val is a string\n        // - dir - true for indexOf, false for lastIndexOf\n\n\n        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n          // Empty buffer means no match\n          if (buffer.length === 0) return -1; // Normalize byteOffset\n\n          if (typeof byteOffset === 'string') {\n            encoding = byteOffset;\n            byteOffset = 0;\n          } else if (byteOffset > 0x7fffffff) {\n            byteOffset = 0x7fffffff;\n          } else if (byteOffset < -0x80000000) {\n            byteOffset = -0x80000000;\n          }\n\n          byteOffset = +byteOffset; // Coerce to Number.\n\n          if (isNaN(byteOffset)) {\n            // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n            byteOffset = dir ? 0 : buffer.length - 1;\n          } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n          if (byteOffset >= buffer.length) {\n            if (dir) return -1;else byteOffset = buffer.length - 1;\n          } else if (byteOffset < 0) {\n            if (dir) byteOffset = 0;else return -1;\n          } // Normalize val\n\n\n          if (typeof val === 'string') {\n            val = Buffer.from(val, encoding);\n          } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n          if (Buffer.isBuffer(val)) {\n            // Special case: looking for empty string/buffer always fails\n            if (val.length === 0) {\n              return -1;\n            }\n\n            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n          } else if (typeof val === 'number') {\n            val = val & 0xFF; // Search for a byte value [0-255]\n\n            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {\n              if (dir) {\n                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n              } else {\n                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n              }\n            }\n\n            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n          }\n\n          throw new TypeError('val must be string, number or Buffer');\n        }\n\n        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n          var indexSize = 1;\n          var arrLength = arr.length;\n          var valLength = val.length;\n\n          if (encoding !== undefined) {\n            encoding = String(encoding).toLowerCase();\n\n            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n              if (arr.length < 2 || val.length < 2) {\n                return -1;\n              }\n\n              indexSize = 2;\n              arrLength /= 2;\n              valLength /= 2;\n              byteOffset /= 2;\n            }\n          }\n\n          function read(buf, i) {\n            if (indexSize === 1) {\n              return buf[i];\n            } else {\n              return buf.readUInt16BE(i * indexSize);\n            }\n          }\n\n          var i;\n\n          if (dir) {\n            var foundIndex = -1;\n\n            for (i = byteOffset; i < arrLength; i++) {\n              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                if (foundIndex === -1) foundIndex = i;\n                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n              } else {\n                if (foundIndex !== -1) i -= i - foundIndex;\n                foundIndex = -1;\n              }\n            }\n          } else {\n            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n            for (i = byteOffset; i >= 0; i--) {\n              var found = true;\n\n              for (var j = 0; j < valLength; j++) {\n                if (read(arr, i + j) !== read(val, j)) {\n                  found = false;\n                  break;\n                }\n              }\n\n              if (found) return i;\n            }\n          }\n\n          return -1;\n        }\n\n        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n          return this.indexOf(val, byteOffset, encoding) !== -1;\n        };\n\n        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n        };\n\n        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n        };\n\n        function hexWrite(buf, string, offset, length) {\n          offset = Number(offset) || 0;\n          var remaining = buf.length - offset;\n\n          if (!length) {\n            length = remaining;\n          } else {\n            length = Number(length);\n\n            if (length > remaining) {\n              length = remaining;\n            }\n          } // must be an even number of digits\n\n\n          var strLen = string.length;\n          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n          if (length > strLen / 2) {\n            length = strLen / 2;\n          }\n\n          for (var i = 0; i < length; ++i) {\n            var parsed = parseInt(string.substr(i * 2, 2), 16);\n            if (isNaN(parsed)) return i;\n            buf[offset + i] = parsed;\n          }\n\n          return i;\n        }\n\n        function utf8Write(buf, string, offset, length) {\n          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        function asciiWrite(buf, string, offset, length) {\n          return blitBuffer(asciiToBytes(string), buf, offset, length);\n        }\n\n        function latin1Write(buf, string, offset, length) {\n          return asciiWrite(buf, string, offset, length);\n        }\n\n        function base64Write(buf, string, offset, length) {\n          return blitBuffer(base64ToBytes(string), buf, offset, length);\n        }\n\n        function ucs2Write(buf, string, offset, length) {\n          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n        }\n\n        Buffer.prototype.write = function write(string, offset, length, encoding) {\n          // Buffer#write(string)\n          if (offset === undefined) {\n            encoding = 'utf8';\n            length = this.length;\n            offset = 0; // Buffer#write(string, encoding)\n          } else if (length === undefined && typeof offset === 'string') {\n            encoding = offset;\n            length = this.length;\n            offset = 0; // Buffer#write(string, offset[, length][, encoding])\n          } else if (isFinite(offset)) {\n            offset = offset | 0;\n\n            if (isFinite(length)) {\n              length = length | 0;\n              if (encoding === undefined) encoding = 'utf8';\n            } else {\n              encoding = length;\n              length = undefined;\n            } // legacy write(string, encoding, offset, length) - remove in v0.13\n\n          } else {\n            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n          }\n\n          var remaining = this.length - offset;\n          if (length === undefined || length > remaining) length = remaining;\n\n          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n            throw new RangeError('Attempt to write outside buffer bounds');\n          }\n\n          if (!encoding) encoding = 'utf8';\n          var loweredCase = false;\n\n          for (;;) {\n            switch (encoding) {\n              case 'hex':\n                return hexWrite(this, string, offset, length);\n\n              case 'utf8':\n              case 'utf-8':\n                return utf8Write(this, string, offset, length);\n\n              case 'ascii':\n                return asciiWrite(this, string, offset, length);\n\n              case 'latin1':\n              case 'binary':\n                return latin1Write(this, string, offset, length);\n\n              case 'base64':\n                // Warning: maxLength not taken into account in base64Write\n                return base64Write(this, string, offset, length);\n\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return ucs2Write(this, string, offset, length);\n\n              default:\n                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                encoding = ('' + encoding).toLowerCase();\n                loweredCase = true;\n            }\n          }\n        };\n\n        Buffer.prototype.toJSON = function toJSON() {\n          return {\n            type: 'Buffer',\n            data: Array.prototype.slice.call(this._arr || this, 0)\n          };\n        };\n\n        function base64Slice(buf, start, end) {\n          if (start === 0 && end === buf.length) {\n            return base64.fromByteArray(buf);\n          } else {\n            return base64.fromByteArray(buf.slice(start, end));\n          }\n        }\n\n        function utf8Slice(buf, start, end) {\n          end = Math.min(buf.length, end);\n          var res = [];\n          var i = start;\n\n          while (i < end) {\n            var firstByte = buf[i];\n            var codePoint = null;\n            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n            if (i + bytesPerSequence <= end) {\n              var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n              switch (bytesPerSequence) {\n                case 1:\n                  if (firstByte < 0x80) {\n                    codePoint = firstByte;\n                  }\n\n                  break;\n\n                case 2:\n                  secondByte = buf[i + 1];\n\n                  if ((secondByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                    if (tempCodePoint > 0x7F) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 3:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n                  break;\n\n                case 4:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  fourthByte = buf[i + 3];\n\n                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n\n              }\n            }\n\n            if (codePoint === null) {\n              // we did not generate a valid codePoint so insert a\n              // replacement char (U+FFFD) and advance only 1 byte\n              codePoint = 0xFFFD;\n              bytesPerSequence = 1;\n            } else if (codePoint > 0xFFFF) {\n              // encode to utf16 (surrogate pair dance)\n              codePoint -= 0x10000;\n              res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n              codePoint = 0xDC00 | codePoint & 0x3FF;\n            }\n\n            res.push(codePoint);\n            i += bytesPerSequence;\n          }\n\n          return decodeCodePointsArray(res);\n        } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n        // the lowest limit is Chrome, with 0x10000 args.\n        // We go 1 magnitude less, for safety\n\n\n        var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n        function decodeCodePointsArray(codePoints) {\n          var len = codePoints.length;\n\n          if (len <= MAX_ARGUMENTS_LENGTH) {\n            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n          } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n          var res = '';\n          var i = 0;\n\n          while (i < len) {\n            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n          }\n\n          return res;\n        }\n\n        function asciiSlice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i] & 0x7F);\n          }\n\n          return ret;\n        }\n\n        function latin1Slice(buf, start, end) {\n          var ret = '';\n          end = Math.min(buf.length, end);\n\n          for (var i = start; i < end; ++i) {\n            ret += String.fromCharCode(buf[i]);\n          }\n\n          return ret;\n        }\n\n        function hexSlice(buf, start, end) {\n          var len = buf.length;\n          if (!start || start < 0) start = 0;\n          if (!end || end < 0 || end > len) end = len;\n          var out = '';\n\n          for (var i = start; i < end; ++i) {\n            out += toHex(buf[i]);\n          }\n\n          return out;\n        }\n\n        function utf16leSlice(buf, start, end) {\n          var bytes = buf.slice(start, end);\n          var res = '';\n\n          for (var i = 0; i < bytes.length; i += 2) {\n            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n          }\n\n          return res;\n        }\n\n        Buffer.prototype.slice = function slice(start, end) {\n          var len = this.length;\n          start = ~~start;\n          end = end === undefined ? len : ~~end;\n\n          if (start < 0) {\n            start += len;\n            if (start < 0) start = 0;\n          } else if (start > len) {\n            start = len;\n          }\n\n          if (end < 0) {\n            end += len;\n            if (end < 0) end = 0;\n          } else if (end > len) {\n            end = len;\n          }\n\n          if (end < start) end = start;\n          var newBuf;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            newBuf = this.subarray(start, end);\n            newBuf.__proto__ = Buffer.prototype;\n          } else {\n            var sliceLen = end - start;\n            newBuf = new Buffer(sliceLen, undefined);\n\n            for (var i = 0; i < sliceLen; ++i) {\n              newBuf[i] = this[i + start];\n            }\n          }\n\n          return newBuf;\n        };\n        /*\n         * Need to make sure that buffer isn't trying to write out of bounds.\n         */\n\n\n        function checkOffset(offset, ext, length) {\n          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n        }\n\n        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            checkOffset(offset, byteLength, this.length);\n          }\n\n          var val = this[offset + --byteLength];\n          var mul = 1;\n\n          while (byteLength > 0 && (mul *= 0x100)) {\n            val += this[offset + --byteLength] * mul;\n          }\n\n          return val;\n        };\n\n        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          return this[offset];\n        };\n\n        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] | this[offset + 1] << 8;\n        };\n\n        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          return this[offset] << 8 | this[offset + 1];\n        };\n\n        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n        };\n\n        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n        };\n\n        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var val = this[offset];\n          var mul = 1;\n          var i = 0;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            val += this[offset + i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n          if (!noAssert) checkOffset(offset, byteLength, this.length);\n          var i = byteLength;\n          var mul = 1;\n          var val = this[offset + --i];\n\n          while (i > 0 && (mul *= 0x100)) {\n            val += this[offset + --i] * mul;\n          }\n\n          mul *= 0x80;\n          if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n          return val;\n        };\n\n        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 1, this.length);\n          if (!(this[offset] & 0x80)) return this[offset];\n          return (0xff - this[offset] + 1) * -1;\n        };\n\n        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset] | this[offset + 1] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 2, this.length);\n          var val = this[offset + 1] | this[offset] << 8;\n          return val & 0x8000 ? val | 0xFFFF0000 : val;\n        };\n\n        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n        };\n\n        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n        };\n\n        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, true, 23, 4);\n        };\n\n        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 4, this.length);\n          return ieee754.read(this, offset, false, 23, 4);\n        };\n\n        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, true, 52, 8);\n        };\n\n        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n          if (!noAssert) checkOffset(offset, 8, this.length);\n          return ieee754.read(this, offset, false, 52, 8);\n        };\n\n        function checkInt(buf, value, offset, ext, max, min) {\n          if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n          if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n        }\n\n        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var mul = 1;\n          var i = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          byteLength = byteLength | 0;\n\n          if (!noAssert) {\n            var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n            checkInt(this, value, offset, byteLength, maxBytes, 0);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            this[offset + i] = value / mul & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        function objectWriteUInt16(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;\n          }\n        }\n\n        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        function objectWriteUInt32(buf, value, offset, littleEndian) {\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;\n          }\n        }\n\n        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = 0;\n          var mul = 1;\n          var sub = 0;\n          this[offset] = value & 0xFF;\n\n          while (++i < byteLength && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n          value = +value;\n          offset = offset | 0;\n\n          if (!noAssert) {\n            var limit = Math.pow(2, 8 * byteLength - 1);\n            checkInt(this, value, offset, byteLength, limit - 1, -limit);\n          }\n\n          var i = byteLength - 1;\n          var mul = 1;\n          var sub = 0;\n          this[offset + i] = value & 0xFF;\n\n          while (--i >= 0 && (mul *= 0x100)) {\n            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n              sub = 1;\n            }\n\n            this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n          }\n\n          return offset + byteLength;\n        };\n\n        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n          if (value < 0) value = 0xff + value + 1;\n          this[offset] = value & 0xff;\n          return offset + 1;\n        };\n\n        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n          } else {\n            objectWriteUInt16(this, value, offset, true);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n          } else {\n            objectWriteUInt16(this, value, offset, false);\n          }\n\n          return offset + 2;\n        };\n\n        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n          } else {\n            objectWriteUInt32(this, value, offset, true);\n          }\n\n          return offset + 4;\n        };\n\n        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n          value = +value;\n          offset = offset | 0;\n          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n          if (value < 0) value = 0xffffffff + value + 1;\n\n          if (Buffer.TYPED_ARRAY_SUPPORT) {\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n          } else {\n            objectWriteUInt32(this, value, offset, false);\n          }\n\n          return offset + 4;\n        };\n\n        function checkIEEE754(buf, value, offset, ext, max, min) {\n          if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          if (offset < 0) throw new RangeError('Index out of range');\n        }\n\n        function writeFloat(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 23, 4);\n          return offset + 4;\n        }\n\n        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n          return writeFloat(this, value, offset, false, noAssert);\n        };\n\n        function writeDouble(buf, value, offset, littleEndian, noAssert) {\n          if (!noAssert) {\n            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n          }\n\n          ieee754.write(buf, value, offset, littleEndian, 52, 8);\n          return offset + 8;\n        }\n\n        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, true, noAssert);\n        };\n\n        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n          return writeDouble(this, value, offset, false, noAssert);\n        }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n        Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n          if (!start) start = 0;\n          if (!end && end !== 0) end = this.length;\n          if (targetStart >= target.length) targetStart = target.length;\n          if (!targetStart) targetStart = 0;\n          if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n          if (end === start) return 0;\n          if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n          if (targetStart < 0) {\n            throw new RangeError('targetStart out of bounds');\n          }\n\n          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n          if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n          if (end > this.length) end = this.length;\n\n          if (target.length - targetStart < end - start) {\n            end = target.length - targetStart + start;\n          }\n\n          var len = end - start;\n          var i;\n\n          if (this === target && start < targetStart && targetStart < end) {\n            // descending copy from end\n            for (i = len - 1; i >= 0; --i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n            // ascending copy from start\n            for (i = 0; i < len; ++i) {\n              target[i + targetStart] = this[i + start];\n            }\n          } else {\n            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);\n          }\n\n          return len;\n        }; // Usage:\n        //    buffer.fill(number[, offset[, end]])\n        //    buffer.fill(buffer[, offset[, end]])\n        //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n        Buffer.prototype.fill = function fill(val, start, end, encoding) {\n          // Handle string cases:\n          if (typeof val === 'string') {\n            if (typeof start === 'string') {\n              encoding = start;\n              start = 0;\n              end = this.length;\n            } else if (typeof end === 'string') {\n              encoding = end;\n              end = this.length;\n            }\n\n            if (val.length === 1) {\n              var code = val.charCodeAt(0);\n\n              if (code < 256) {\n                val = code;\n              }\n            }\n\n            if (encoding !== undefined && typeof encoding !== 'string') {\n              throw new TypeError('encoding must be a string');\n            }\n\n            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n          } else if (typeof val === 'number') {\n            val = val & 255;\n          } // Invalid ranges are not set to a default, so can range check early.\n\n\n          if (start < 0 || this.length < start || this.length < end) {\n            throw new RangeError('Out of range index');\n          }\n\n          if (end <= start) {\n            return this;\n          }\n\n          start = start >>> 0;\n          end = end === undefined ? this.length : end >>> 0;\n          if (!val) val = 0;\n          var i;\n\n          if (typeof val === 'number') {\n            for (i = start; i < end; ++i) {\n              this[i] = val;\n            }\n          } else {\n            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());\n            var len = bytes.length;\n\n            for (i = 0; i < end - start; ++i) {\n              this[i + start] = bytes[i % len];\n            }\n          }\n\n          return this;\n        }; // HELPER FUNCTIONS\n        // ================\n\n\n        var INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\n        function base64clean(str) {\n          // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n          str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n          if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n          while (str.length % 4 !== 0) {\n            str = str + '=';\n          }\n\n          return str;\n        }\n\n        function stringtrim(str) {\n          if (str.trim) return str.trim();\n          return str.replace(/^\\s+|\\s+$/g, '');\n        }\n\n        function toHex(n) {\n          if (n < 16) return '0' + n.toString(16);\n          return n.toString(16);\n        }\n\n        function utf8ToBytes(string, units) {\n          units = units || Infinity;\n          var codePoint;\n          var length = string.length;\n          var leadSurrogate = null;\n          var bytes = [];\n\n          for (var i = 0; i < length; ++i) {\n            codePoint = string.charCodeAt(i); // is surrogate component\n\n            if (codePoint > 0xD7FF && codePoint < 0xE000) {\n              // last char was a lead\n              if (!leadSurrogate) {\n                // no lead yet\n                if (codePoint > 0xDBFF) {\n                  // unexpected trail\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } else if (i + 1 === length) {\n                  // unpaired lead\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  continue;\n                } // valid lead\n\n\n                leadSurrogate = codePoint;\n                continue;\n              } // 2 leads in a row\n\n\n              if (codePoint < 0xDC00) {\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                leadSurrogate = codePoint;\n                continue;\n              } // valid surrogate pair\n\n\n              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n            } else if (leadSurrogate) {\n              // valid bmp char, but last char was a lead\n              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n            }\n\n            leadSurrogate = null; // encode utf8\n\n            if (codePoint < 0x80) {\n              if ((units -= 1) < 0) break;\n              bytes.push(codePoint);\n            } else if (codePoint < 0x800) {\n              if ((units -= 2) < 0) break;\n              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x10000) {\n              if ((units -= 3) < 0) break;\n              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else if (codePoint < 0x110000) {\n              if ((units -= 4) < 0) break;\n              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n            } else {\n              throw new Error('Invalid code point');\n            }\n          }\n\n          return bytes;\n        }\n\n        function asciiToBytes(str) {\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            // Node's code seems to be doing this and not & 0x7F..\n            byteArray.push(str.charCodeAt(i) & 0xFF);\n          }\n\n          return byteArray;\n        }\n\n        function utf16leToBytes(str, units) {\n          var c, hi, lo;\n          var byteArray = [];\n\n          for (var i = 0; i < str.length; ++i) {\n            if ((units -= 2) < 0) break;\n            c = str.charCodeAt(i);\n            hi = c >> 8;\n            lo = c % 256;\n            byteArray.push(lo);\n            byteArray.push(hi);\n          }\n\n          return byteArray;\n        }\n\n        function base64ToBytes(str) {\n          return base64.toByteArray(base64clean(str));\n        }\n\n        function blitBuffer(src, dst, offset, length) {\n          for (var i = 0; i < length; ++i) {\n            if (i + offset >= dst.length || i >= src.length) break;\n            dst[i + offset] = src[i];\n          }\n\n          return i;\n        }\n\n        function isnan(val) {\n          return val !== val; // eslint-disable-line no-self-compare\n        }\n        /* WEBPACK VAR INJECTION */\n\n      }).call(exports, __webpack_require__(15));\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _node = _interopRequireDefault(__webpack_require__(20));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a comment between declarations or statements (rule and at-rules).\n       *\n       * Comments inside selectors, at-rule parameters, or declaration values\n       * will be stored in the `raws` properties explained above.\n       *\n       * @extends Node\n       */\n\n\n      var Comment =\n      /*#__PURE__*/\n      function (_Node) {\n        _inheritsLoose(Comment, _Node);\n\n        function Comment(defaults) {\n          var _this;\n\n          _this = _Node.call(this, defaults) || this;\n          _this.type = 'comment';\n          return _this;\n        }\n        /**\n         * @memberof Comment#\n         * @member {string} text The comments text.\n         */\n\n        /**\n         * @memberof Comment#\n         * @member {object} raws Information to generate byte-to-byte equal\n         *                       node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `before`: the space symbols before the node.\n         * * `left`: the space symbols between `/*` and the comments text.\n         * * `right`: the space symbols between the comments text.\n         */\n\n\n        return Comment;\n      }(_node.default);\n\n      var _default = Comment;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _cssSyntaxError = _interopRequireDefault(__webpack_require__(60));\n\n      var _stringifier = _interopRequireDefault(__webpack_require__(17));\n\n      var _stringify = _interopRequireDefault(__webpack_require__(65));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function cloneNode(obj, parent) {\n        var cloned = new obj.constructor();\n\n        for (var i in obj) {\n          if (!obj.hasOwnProperty(i)) continue;\n          var value = obj[i];\n\n          var type = _typeof(value);\n\n          if (i === 'parent' && type === 'object') {\n            if (parent) cloned[i] = parent;\n          } else if (i === 'source') {\n            cloned[i] = value;\n          } else if (value instanceof Array) {\n            cloned[i] = value.map(function (j) {\n              return cloneNode(j, cloned);\n            });\n          } else {\n            if (type === 'object' && value !== null) value = cloneNode(value);\n            cloned[i] = value;\n          }\n        }\n\n        return cloned;\n      }\n      /**\n       * All node classes inherit the following common methods.\n       *\n       * @abstract\n       */\n\n\n      var Node =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {object} [defaults] Value for node properties.\n         */\n        function Node(defaults) {\n          if (defaults === void 0) {\n            defaults = {};\n          }\n\n          this.raws = {};\n\n          if (false) {\n            if (_typeof(defaults) !== 'object' && typeof defaults !== 'undefined') {\n              throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));\n            }\n          }\n\n          for (var name in defaults) {\n            this[name] = defaults[name];\n          }\n        }\n        /**\n         * Returns a `CssSyntaxError` instance containing the original position\n         * of the node in the source, showing line and column numbers and also\n         * a small excerpt to facilitate debugging.\n         *\n         * If present, an input source map will be used to get the original position\n         * of the source, even from a previous compilation step\n         * (e.g., from Sass compilation).\n         *\n         * This method produces very useful error messages.\n         *\n         * @param {string} message     Error description.\n         * @param {object} [opts]      Options.\n         * @param {string} opts.plugin Plugin name that created this error.\n         *                             PostCSS will set it automatically.\n         * @param {string} opts.word   A word inside a nodes string that should\n         *                             be highlighted as the source of the error.\n         * @param {number} opts.index  An index inside a nodes string that should\n         *                             be highlighted as the source of the error.\n         *\n         * @return {CssSyntaxError} Error object to throw it.\n         *\n         * @example\n         * if (!variables[name]) {\n         *   throw decl.error('Unknown variable ' + name, { word: name })\n         *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n         *   //   color: $black\n         *   // a\n         *   //          ^\n         *   //   background: white\n         * }\n         */\n\n\n        var _proto = Node.prototype;\n\n        _proto.error = function error(message, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          if (this.source) {\n            var pos = this.positionBy(opts);\n            return this.source.input.error(message, pos.line, pos.column, opts);\n          }\n\n          return new _cssSyntaxError.default(message);\n        };\n        /**\n         * This method is provided as a convenience wrapper for {@link Result#warn}.\n         *\n         * @param {Result} result      The {@link Result} instance\n         *                             that will receive the warning.\n         * @param {string} text        Warning message.\n         * @param {object} [opts]      Options\n         * @param {string} opts.plugin Plugin name that created this warning.\n         *                             PostCSS will set it automatically.\n         * @param {string} opts.word   A word inside a nodes string that should\n         *                             be highlighted as the source of the warning.\n         * @param {number} opts.index  An index inside a nodes string that should\n         *                             be highlighted as the source of the warning.\n         *\n         * @return {Warning} Created warning object.\n         *\n         * @example\n         * const plugin = postcss.plugin('postcss-deprecated', () => {\n         *   return (root, result) => {\n         *     root.walkDecls('bad', decl => {\n         *       decl.warn(result, 'Deprecated property bad')\n         *     })\n         *   }\n         * })\n         */\n\n\n        _proto.warn = function warn(result, text, opts) {\n          var data = {\n            node: this\n          };\n\n          for (var i in opts) {\n            data[i] = opts[i];\n          }\n\n          return result.warn(text, data);\n        };\n        /**\n         * Removes the node from its parent and cleans the parent properties\n         * from the node and its children.\n         *\n         * @example\n         * if (decl.prop.match(/^-webkit-/)) {\n         *   decl.remove()\n         * }\n         *\n         * @return {Node} Node to make calls chain.\n         */\n\n\n        _proto.remove = function remove() {\n          if (this.parent) {\n            this.parent.removeChild(this);\n          }\n\n          this.parent = undefined;\n          return this;\n        };\n        /**\n         * Returns a CSS string representing the node.\n         *\n         * @param {stringifier|syntax} [stringifier] A syntax to use\n         *                                           in string generation.\n         *\n         * @return {string} CSS string of this node.\n         *\n         * @example\n         * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n         */\n\n\n        _proto.toString = function toString(stringifier) {\n          if (stringifier === void 0) {\n            stringifier = _stringify.default;\n          }\n\n          if (stringifier.stringify) stringifier = stringifier.stringify;\n          var result = '';\n          stringifier(this, function (i) {\n            result += i;\n          });\n          return result;\n        };\n        /**\n         * Returns an exact clone of the node.\n         *\n         * The resulting cloned node and its (cloned) children will retain\n         * code style properties.\n         *\n         * @param {object} [overrides] New properties to override in the clone.\n         *\n         * @example\n         * decl.raws.before    //=> \"\\n  \"\n         * const cloned = decl.clone({ prop: '-moz-' + decl.prop })\n         * cloned.raws.before  //=> \"\\n  \"\n         * cloned.toString()   //=> -moz-transform: scale(0)\n         *\n         * @return {Node} Clone of the node.\n         */\n\n\n        _proto.clone = function clone(overrides) {\n          if (overrides === void 0) {\n            overrides = {};\n          }\n\n          var cloned = cloneNode(this);\n\n          for (var name in overrides) {\n            cloned[name] = overrides[name];\n          }\n\n          return cloned;\n        };\n        /**\n         * Shortcut to clone the node and insert the resulting cloned node\n         * before the current node.\n         *\n         * @param {object} [overrides] Mew properties to override in the clone.\n         *\n         * @example\n         * decl.cloneBefore({ prop: '-moz-' + decl.prop })\n         *\n         * @return {Node} New node\n         */\n\n\n        _proto.cloneBefore = function cloneBefore(overrides) {\n          if (overrides === void 0) {\n            overrides = {};\n          }\n\n          var cloned = this.clone(overrides);\n          this.parent.insertBefore(this, cloned);\n          return cloned;\n        };\n        /**\n         * Shortcut to clone the node and insert the resulting cloned node\n         * after the current node.\n         *\n         * @param {object} [overrides] New properties to override in the clone.\n         *\n         * @return {Node} New node.\n         */\n\n\n        _proto.cloneAfter = function cloneAfter(overrides) {\n          if (overrides === void 0) {\n            overrides = {};\n          }\n\n          var cloned = this.clone(overrides);\n          this.parent.insertAfter(this, cloned);\n          return cloned;\n        };\n        /**\n         * Inserts node(s) before the current node and removes the current node.\n         *\n         * @param {...Node} nodes Mode(s) to replace current one.\n         *\n         * @example\n         * if (atrule.name === 'mixin') {\n         *   atrule.replaceWith(mixinRules[atrule.params])\n         * }\n         *\n         * @return {Node} Current node to methods chain.\n         */\n\n\n        _proto.replaceWith = function replaceWith() {\n          if (this.parent) {\n            for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n              nodes[_key] = arguments[_key];\n            }\n\n            for (var _i = 0; _i < nodes.length; _i++) {\n              var node = nodes[_i];\n              this.parent.insertBefore(this, node);\n            }\n\n            this.remove();\n          }\n\n          return this;\n        };\n        /**\n         * Returns the next child of the nodes parent.\n         * Returns `undefined` if the current node is the last child.\n         *\n         * @return {Node|undefined} Next node.\n         *\n         * @example\n         * if (comment.text === 'delete next') {\n         *   const next = comment.next()\n         *   if (next) {\n         *     next.remove()\n         *   }\n         * }\n         */\n\n\n        _proto.next = function next() {\n          if (!this.parent) return undefined;\n          var index = this.parent.index(this);\n          return this.parent.nodes[index + 1];\n        };\n        /**\n         * Returns the previous child of the nodes parent.\n         * Returns `undefined` if the current node is the first child.\n         *\n         * @return {Node|undefined} Previous node.\n         *\n         * @example\n         * const annotation = decl.prev()\n         * if (annotation.type === 'comment') {\n         *   readAnnotation(annotation.text)\n         * }\n         */\n\n\n        _proto.prev = function prev() {\n          if (!this.parent) return undefined;\n          var index = this.parent.index(this);\n          return this.parent.nodes[index - 1];\n        };\n        /**\n         * Insert new node before current node to current nodes parent.\n         *\n         * Just alias for `node.parent.insertBefore(node, add)`.\n         *\n         * @param {Node|object|string|Node[]} add New node.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * decl.before('content: \"\"')\n         */\n\n\n        _proto.before = function before(add) {\n          this.parent.insertBefore(this, add);\n          return this;\n        };\n        /**\n         * Insert new node after current node to current nodes parent.\n         *\n         * Just alias for `node.parent.insertAfter(node, add)`.\n         *\n         * @param {Node|object|string|Node[]} add New node.\n         *\n         * @return {Node} This node for methods chain.\n         *\n         * @example\n         * decl.after('color: black')\n         */\n\n\n        _proto.after = function after(add) {\n          this.parent.insertAfter(this, add);\n          return this;\n        };\n\n        _proto.toJSON = function toJSON() {\n          var fixed = {};\n\n          for (var name in this) {\n            if (!this.hasOwnProperty(name)) continue;\n            if (name === 'parent') continue;\n            var value = this[name];\n\n            if (value instanceof Array) {\n              fixed[name] = value.map(function (i) {\n                if (_typeof(i) === 'object' && i.toJSON) {\n                  return i.toJSON();\n                } else {\n                  return i;\n                }\n              });\n            } else if (_typeof(value) === 'object' && value.toJSON) {\n              fixed[name] = value.toJSON();\n            } else {\n              fixed[name] = value;\n            }\n          }\n\n          return fixed;\n        };\n        /**\n         * Returns a {@link Node#raws} value. If the node is missing\n         * the code style property (because the node was manually built or cloned),\n         * PostCSS will try to autodetect the code style property by looking\n         * at other nodes in the tree.\n         *\n         * @param {string} prop          Name of code style property.\n         * @param {string} [defaultType] Name of default value, it can be missed\n         *                               if the value is the same as prop.\n         *\n         * @example\n         * const root = postcss.parse('a { background: white }')\n         * root.nodes[0].append({ prop: 'color', value: 'black' })\n         * root.nodes[0].nodes[1].raws.before   //=> undefined\n         * root.nodes[0].nodes[1].raw('before') //=> ' '\n         *\n         * @return {string} Code style value.\n         */\n\n\n        _proto.raw = function raw(prop, defaultType) {\n          var str = new _stringifier.default();\n          return str.raw(this, prop, defaultType);\n        };\n        /**\n         * Finds the Root instance of the nodes tree.\n         *\n         * @example\n         * root.nodes[0].nodes[0].root() === root\n         *\n         * @return {Root} Root parent.\n         */\n\n\n        _proto.root = function root() {\n          var result = this;\n\n          while (result.parent) {\n            result = result.parent;\n          }\n\n          return result;\n        };\n        /**\n         * Clear the code style properties for the node and its children.\n         *\n         * @param {boolean} [keepBetween] Keep the raws.between symbols.\n         *\n         * @return {undefined}\n         *\n         * @example\n         * node.raws.before  //=> ' '\n         * node.cleanRaws()\n         * node.raws.before  //=> undefined\n         */\n\n\n        _proto.cleanRaws = function cleanRaws(keepBetween) {\n          delete this.raws.before;\n          delete this.raws.after;\n          if (!keepBetween) delete this.raws.between;\n        };\n\n        _proto.positionInside = function positionInside(index) {\n          var string = this.toString();\n          var column = this.source.start.column;\n          var line = this.source.start.line;\n\n          for (var i = 0; i < index; i++) {\n            if (string[i] === '\\n') {\n              column = 1;\n              line += 1;\n            } else {\n              column += 1;\n            }\n          }\n\n          return {\n            line: line,\n            column: column\n          };\n        };\n\n        _proto.positionBy = function positionBy(opts) {\n          var pos = this.source.start;\n\n          if (opts.index) {\n            pos = this.positionInside(opts.index);\n          } else if (opts.word) {\n            var index = this.toString().indexOf(opts.word);\n            if (index !== -1) pos = this.positionInside(index);\n          }\n\n          return pos;\n        };\n        /**\n         * @memberof Node#\n         * @member {string} type String representing the nodes type.\n         *                       Possible values are `root`, `atrule`, `rule`,\n         *                       `decl`, or `comment`.\n         *\n         * @example\n         * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n         */\n\n        /**\n         * @memberof Node#\n         * @member {Container} parent The nodes parent node.\n         *\n         * @example\n         * root.nodes[0].parent === root\n         */\n\n        /**\n         * @memberof Node#\n         * @member {source} source The input source of the node.\n         *\n         * The property is used in source map generation.\n         *\n         * If you create a node manually (e.g., with `postcss.decl()`),\n         * that node will not have a `source` property and will be absent\n         * from the source map. For this reason, the plugin developer should\n         * consider cloning nodes to create new ones (in which case the new nodes\n         * source will reference the original, cloned node) or setting\n         * the `source` property manually.\n         *\n         * ```js\n         * // Bad\n         * const prefixed = postcss.decl({\n         *   prop: '-moz-' + decl.prop,\n         *   value: decl.value\n         * })\n         *\n         * // Good\n         * const prefixed = decl.clone({ prop: '-moz-' + decl.prop })\n         * ```\n         *\n         * ```js\n         * if (atrule.name === 'add-link') {\n         *   const rule = postcss.rule({ selector: 'a', source: atrule.source })\n         *   atrule.parent.insertBefore(atrule, rule)\n         * }\n         * ```\n         *\n         * @example\n         * decl.source.input.from //=> '/home/ai/a.sass'\n         * decl.source.start      //=> { line: 10, column: 2 }\n         * decl.source.end        //=> { line: 10, column: 12 }\n         */\n\n        /**\n         * @memberof Node#\n         * @member {object} raws Information to generate byte-to-byte equal\n         *                       node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `before`: the space symbols before the node. It also stores `*`\n         *   and `_` symbols before the declaration (IE hack).\n         * * `after`: the space symbols after the last child of the node\n         *   to the end of the node.\n         * * `between`: the symbols between the property and value\n         *   for declarations, selector and `{` for rules, or last parameter\n         *   and `{` for at-rules.\n         * * `semicolon`: contains true if the last child has\n         *   an (optional) semicolon.\n         * * `afterName`: the space between the at-rule name and its parameters.\n         * * `left`: the space symbols between `/*` and the comments text.\n         * * `right`: the space symbols between the comments text\n         *   and <code>*&#47;</code>.\n         * * `important`: the content of the important statement,\n         *   if it is not just `!important`.\n         *\n         * PostCSS cleans selectors, declaration values and at-rule parameters\n         * from comments and extra spaces, but it stores origin content in raws\n         * properties. As such, if you dont change a declarations value,\n         * PostCSS will use the raw value with comments.\n         *\n         * @example\n         * const root = postcss.parse('a {\\n  color:black\\n}')\n         * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n         */\n\n\n        return Node;\n      }();\n\n      var _default = Node;\n      /**\n       * @typedef {object} position\n       * @property {number} line   Source line in file.\n       * @property {number} column Source column in file.\n       */\n\n      /**\n       * @typedef {object} source\n       * @property {Input} input    {@link Input} with input file\n       * @property {position} start The starting position of the nodes source.\n       * @property {position} end   The ending position of the nodes source.\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      var _node = __webpack_require__(22);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a comment between declarations or statements (rule and at-rules).\n       *\n       * Comments inside selectors, at-rule parameters, or declaration values\n       * will be stored in the `raws` properties explained above.\n       *\n       * @extends Node\n       */\n\n\n      var Comment = function (_Node) {\n        _inherits(Comment, _Node);\n\n        function Comment(defaults) {\n          _classCallCheck(this, Comment);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));\n\n          _this.type = 'comment';\n          return _this;\n        }\n\n        _createClass(Comment, [{\n          key: 'left',\n          get: function get() {\n            (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');\n            return this.raws.left;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Comment#left was deprecated. Use Comment#raws.left');\n            this.raws.left = val;\n          }\n        }, {\n          key: 'right',\n          get: function get() {\n            (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');\n            return this.raws.right;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Comment#right was deprecated. Use Comment#raws.right');\n            this.raws.right = val;\n          }\n          /**\n           * @memberof Comment#\n           * @member {string} text - the comments text\n           */\n\n          /**\n           * @memberof Comment#\n           * @member {object} raws - Information to generate byte-to-byte equal\n           *                         node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node.\n           * * `left`: the space symbols between `/*` and the comments text.\n           * * `right`: the space symbols between the comments text.\n           */\n\n        }]);\n\n        return Comment;\n      }(_node2.default);\n\n      exports.default = Comment;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _cssSyntaxError = __webpack_require__(73);\n\n      var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);\n\n      var _stringifier = __webpack_require__(24);\n\n      var _stringifier2 = _interopRequireDefault(_stringifier);\n\n      var _stringify = __webpack_require__(82);\n\n      var _stringify2 = _interopRequireDefault(_stringify);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var cloneNode = function cloneNode(obj, parent) {\n        var cloned = new obj.constructor();\n\n        for (var i in obj) {\n          if (!obj.hasOwnProperty(i)) continue;\n          var value = obj[i];\n          var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n          if (i === 'parent' && type === 'object') {\n            if (parent) cloned[i] = parent;\n          } else if (i === 'source') {\n            cloned[i] = value;\n          } else if (value instanceof Array) {\n            cloned[i] = value.map(function (j) {\n              return cloneNode(j, cloned);\n            });\n          } else if (i !== 'before' && i !== 'after' && i !== 'between' && i !== 'semicolon') {\n            if (type === 'object' && value !== null) value = cloneNode(value);\n            cloned[i] = value;\n          }\n        }\n\n        return cloned;\n      };\n      /**\n       * All node classes inherit the following common methods.\n       *\n       * @abstract\n       */\n\n\n      var Node = function () {\n        /**\n         * @param {object} [defaults] - value for node properties\n         */\n        function Node() {\n          var defaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          _classCallCheck(this, Node);\n\n          this.raws = {};\n\n          if ((typeof defaults === 'undefined' ? 'undefined' : _typeof(defaults)) !== 'object' && typeof defaults !== 'undefined') {\n            throw new Error('PostCSS nodes constructor accepts object, not ' + JSON.stringify(defaults));\n          }\n\n          for (var name in defaults) {\n            this[name] = defaults[name];\n          }\n        }\n        /**\n         * Returns a CssSyntaxError instance containing the original position\n         * of the node in the source, showing line and column numbers and also\n         * a small excerpt to facilitate debugging.\n         *\n         * If present, an input source map will be used to get the original position\n         * of the source, even from a previous compilation step\n         * (e.g., from Sass compilation).\n         *\n         * This method produces very useful error messages.\n         *\n         * @param {string} message     - error description\n         * @param {object} [opts]      - options\n         * @param {string} opts.plugin - plugin name that created this error.\n         *                               PostCSS will set it automatically.\n         * @param {string} opts.word   - a word inside a nodes string that should\n         *                               be highlighted as the source of the error\n         * @param {number} opts.index  - an index inside a nodes string that should\n         *                               be highlighted as the source of the error\n         *\n         * @return {CssSyntaxError} error object to throw it\n         *\n         * @example\n         * if ( !variables[name] ) {\n         *   throw decl.error('Unknown variable ' + name, { word: name });\n         *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black\n         *   //   color: $black\n         *   // a\n         *   //          ^\n         *   //   background: white\n         * }\n         */\n\n\n        Node.prototype.error = function error(message) {\n          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (this.source) {\n            var pos = this.positionBy(opts);\n            return this.source.input.error(message, pos.line, pos.column, opts);\n          } else {\n            return new _cssSyntaxError2.default(message);\n          }\n        };\n        /**\n         * This method is provided as a convenience wrapper for {@link Result#warn}.\n         *\n         * @param {Result} result      - the {@link Result} instance\n         *                               that will receive the warning\n         * @param {string} text        - warning message\n         * @param {object} [opts]      - options\n         * @param {string} opts.plugin - plugin name that created this warning.\n         *                               PostCSS will set it automatically.\n         * @param {string} opts.word   - a word inside a nodes string that should\n         *                               be highlighted as the source of the warning\n         * @param {number} opts.index  - an index inside a nodes string that should\n         *                               be highlighted as the source of the warning\n         *\n         * @return {Warning} created warning object\n         *\n         * @example\n         * const plugin = postcss.plugin('postcss-deprecated', () => {\n         *   return (root, result) => {\n         *     root.walkDecls('bad', decl => {\n         *       decl.warn(result, 'Deprecated property bad');\n         *     });\n         *   };\n         * });\n         */\n\n\n        Node.prototype.warn = function warn(result, text, opts) {\n          var data = {\n            node: this\n          };\n\n          for (var i in opts) {\n            data[i] = opts[i];\n          }\n\n          return result.warn(text, data);\n        };\n        /**\n         * Removes the node from its parent and cleans the parent properties\n         * from the node and its children.\n         *\n         * @example\n         * if ( decl.prop.match(/^-webkit-/) ) {\n         *   decl.remove();\n         * }\n         *\n         * @return {Node} node to make calls chain\n         */\n\n\n        Node.prototype.remove = function remove() {\n          if (this.parent) {\n            this.parent.removeChild(this);\n          }\n\n          this.parent = undefined;\n          return this;\n        };\n        /**\n         * Returns a CSS string representing the node.\n         *\n         * @param {stringifier|syntax} [stringifier] - a syntax to use\n         *                                             in string generation\n         *\n         * @return {string} CSS string of this node\n         *\n         * @example\n         * postcss.rule({ selector: 'a' }).toString() //=> \"a {}\"\n         */\n\n\n        Node.prototype.toString = function toString() {\n          var stringifier = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _stringify2.default;\n          if (stringifier.stringify) stringifier = stringifier.stringify;\n          var result = '';\n          stringifier(this, function (i) {\n            result += i;\n          });\n          return result;\n        };\n        /**\n         * Returns a clone of the node.\n         *\n         * The resulting cloned node and its (cloned) children will have\n         * a clean parent and code style properties.\n         *\n         * @param {object} [overrides] - new properties to override in the clone.\n         *\n         * @example\n         * const cloned = decl.clone({ prop: '-moz-' + decl.prop });\n         * cloned.raws.before  //=> undefined\n         * cloned.parent       //=> undefined\n         * cloned.toString()   //=> -moz-transform: scale(0)\n         *\n         * @return {Node} clone of the node\n         */\n\n\n        Node.prototype.clone = function clone() {\n          var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var cloned = cloneNode(this);\n\n          for (var name in overrides) {\n            cloned[name] = overrides[name];\n          }\n\n          return cloned;\n        };\n        /**\n         * Shortcut to clone the node and insert the resulting cloned node\n         * before the current node.\n         *\n         * @param {object} [overrides] - new properties to override in the clone.\n         *\n         * @example\n         * decl.cloneBefore({ prop: '-moz-' + decl.prop });\n         *\n         * @return {Node} - new node\n         */\n\n\n        Node.prototype.cloneBefore = function cloneBefore() {\n          var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var cloned = this.clone(overrides);\n          this.parent.insertBefore(this, cloned);\n          return cloned;\n        };\n        /**\n         * Shortcut to clone the node and insert the resulting cloned node\n         * after the current node.\n         *\n         * @param {object} [overrides] - new properties to override in the clone.\n         *\n         * @return {Node} - new node\n         */\n\n\n        Node.prototype.cloneAfter = function cloneAfter() {\n          var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var cloned = this.clone(overrides);\n          this.parent.insertAfter(this, cloned);\n          return cloned;\n        };\n        /**\n         * Inserts node(s) before the current node and removes the current node.\n         *\n         * @param {...Node} nodes - node(s) to replace current one\n         *\n         * @example\n         * if ( atrule.name == 'mixin' ) {\n         *   atrule.replaceWith(mixinRules[atrule.params]);\n         * }\n         *\n         * @return {Node} current node to methods chain\n         */\n\n\n        Node.prototype.replaceWith = function replaceWith() {\n          if (this.parent) {\n            for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {\n              nodes[_key] = arguments[_key];\n            }\n\n            for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n              var _ref;\n\n              if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n              } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n              }\n\n              var node = _ref;\n              this.parent.insertBefore(this, node);\n            }\n\n            this.remove();\n          }\n\n          return this;\n        };\n        /**\n         * Removes the node from its current parent and inserts it\n         * at the end of `newParent`.\n         *\n         * This will clean the `before` and `after` code {@link Node#raws} data\n         * from the node and replace them with the indentation style of `newParent`.\n         * It will also clean the `between` property\n         * if `newParent` is in another {@link Root}.\n         *\n         * @param {Container} newParent - container node where the current node\n         *                                will be moved\n         *\n         * @example\n         * atrule.moveTo(atrule.root());\n         *\n         * @return {Node} current node to methods chain\n         */\n\n\n        Node.prototype.moveTo = function moveTo(newParent) {\n          this.cleanRaws(this.root() === newParent.root());\n          this.remove();\n          newParent.append(this);\n          return this;\n        };\n        /**\n         * Removes the node from its current parent and inserts it into\n         * a new parent before `otherNode`.\n         *\n         * This will also clean the nodes code style properties just as it would\n         * in {@link Node#moveTo}.\n         *\n         * @param {Node} otherNode - node that will be before current node\n         *\n         * @return {Node} current node to methods chain\n         */\n\n\n        Node.prototype.moveBefore = function moveBefore(otherNode) {\n          this.cleanRaws(this.root() === otherNode.root());\n          this.remove();\n          otherNode.parent.insertBefore(otherNode, this);\n          return this;\n        };\n        /**\n         * Removes the node from its current parent and inserts it into\n         * a new parent after `otherNode`.\n         *\n         * This will also clean the nodes code style properties just as it would\n         * in {@link Node#moveTo}.\n         *\n         * @param {Node} otherNode - node that will be after current node\n         *\n         * @return {Node} current node to methods chain\n         */\n\n\n        Node.prototype.moveAfter = function moveAfter(otherNode) {\n          this.cleanRaws(this.root() === otherNode.root());\n          this.remove();\n          otherNode.parent.insertAfter(otherNode, this);\n          return this;\n        };\n        /**\n         * Returns the next child of the nodes parent.\n         * Returns `undefined` if the current node is the last child.\n         *\n         * @return {Node|undefined} next node\n         *\n         * @example\n         * if ( comment.text === 'delete next' ) {\n         *   const next = comment.next();\n         *   if ( next ) {\n         *     next.remove();\n         *   }\n         * }\n         */\n\n\n        Node.prototype.next = function next() {\n          var index = this.parent.index(this);\n          return this.parent.nodes[index + 1];\n        };\n        /**\n         * Returns the previous child of the nodes parent.\n         * Returns `undefined` if the current node is the first child.\n         *\n         * @return {Node|undefined} previous node\n         *\n         * @example\n         * const annotation = decl.prev();\n         * if ( annotation.type == 'comment' ) {\n         *  readAnnotation(annotation.text);\n         * }\n         */\n\n\n        Node.prototype.prev = function prev() {\n          var index = this.parent.index(this);\n          return this.parent.nodes[index - 1];\n        };\n\n        Node.prototype.toJSON = function toJSON() {\n          var fixed = {};\n\n          for (var name in this) {\n            if (!this.hasOwnProperty(name)) continue;\n            if (name === 'parent') continue;\n            var value = this[name];\n\n            if (value instanceof Array) {\n              fixed[name] = value.map(function (i) {\n                if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && i.toJSON) {\n                  return i.toJSON();\n                } else {\n                  return i;\n                }\n              });\n            } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.toJSON) {\n              fixed[name] = value.toJSON();\n            } else {\n              fixed[name] = value;\n            }\n          }\n\n          return fixed;\n        };\n        /**\n         * Returns a {@link Node#raws} value. If the node is missing\n         * the code style property (because the node was manually built or cloned),\n         * PostCSS will try to autodetect the code style property by looking\n         * at other nodes in the tree.\n         *\n         * @param {string} prop          - name of code style property\n         * @param {string} [defaultType] - name of default value, it can be missed\n         *                                 if the value is the same as prop\n         *\n         * @example\n         * const root = postcss.parse('a { background: white }');\n         * root.nodes[0].append({ prop: 'color', value: 'black' });\n         * root.nodes[0].nodes[1].raws.before   //=> undefined\n         * root.nodes[0].nodes[1].raw('before') //=> ' '\n         *\n         * @return {string} code style value\n         */\n\n\n        Node.prototype.raw = function raw(prop, defaultType) {\n          var str = new _stringifier2.default();\n          return str.raw(this, prop, defaultType);\n        };\n        /**\n         * Finds the Root instance of the nodes tree.\n         *\n         * @example\n         * root.nodes[0].nodes[0].root() === root\n         *\n         * @return {Root} root parent\n         */\n\n\n        Node.prototype.root = function root() {\n          var result = this;\n\n          while (result.parent) {\n            result = result.parent;\n          }\n\n          return result;\n        };\n\n        Node.prototype.cleanRaws = function cleanRaws(keepBetween) {\n          delete this.raws.before;\n          delete this.raws.after;\n          if (!keepBetween) delete this.raws.between;\n        };\n\n        Node.prototype.positionInside = function positionInside(index) {\n          var string = this.toString();\n          var column = this.source.start.column;\n          var line = this.source.start.line;\n\n          for (var i = 0; i < index; i++) {\n            if (string[i] === '\\n') {\n              column = 1;\n              line += 1;\n            } else {\n              column += 1;\n            }\n          }\n\n          return {\n            line: line,\n            column: column\n          };\n        };\n\n        Node.prototype.positionBy = function positionBy(opts) {\n          var pos = this.source.start;\n\n          if (opts.index) {\n            pos = this.positionInside(opts.index);\n          } else if (opts.word) {\n            var index = this.toString().indexOf(opts.word);\n            if (index !== -1) pos = this.positionInside(index);\n          }\n\n          return pos;\n        };\n\n        Node.prototype.removeSelf = function removeSelf() {\n          (0, _warnOnce2.default)('Node#removeSelf is deprecated. Use Node#remove.');\n          return this.remove();\n        };\n\n        Node.prototype.replace = function replace(nodes) {\n          (0, _warnOnce2.default)('Node#replace is deprecated. Use Node#replaceWith');\n          return this.replaceWith(nodes);\n        };\n\n        Node.prototype.style = function style(own, detect) {\n          (0, _warnOnce2.default)('Node#style() is deprecated. Use Node#raw()');\n          return this.raw(own, detect);\n        };\n\n        Node.prototype.cleanStyles = function cleanStyles(keepBetween) {\n          (0, _warnOnce2.default)('Node#cleanStyles() is deprecated. Use Node#cleanRaws()');\n          return this.cleanRaws(keepBetween);\n        };\n\n        _createClass(Node, [{\n          key: 'before',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');\n            return this.raws.before;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#before is deprecated. Use Node#raws.before');\n            this.raws.before = val;\n          }\n        }, {\n          key: 'between',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');\n            return this.raws.between;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#between is deprecated. Use Node#raws.between');\n            this.raws.between = val;\n          }\n          /**\n           * @memberof Node#\n           * @member {string} type - String representing the nodes type.\n           *                         Possible values are `root`, `atrule`, `rule`,\n           *                         `decl`, or `comment`.\n           *\n           * @example\n           * postcss.decl({ prop: 'color', value: 'black' }).type //=> 'decl'\n           */\n\n          /**\n           * @memberof Node#\n           * @member {Container} parent - the nodes parent node.\n           *\n           * @example\n           * root.nodes[0].parent == root;\n           */\n\n          /**\n           * @memberof Node#\n           * @member {source} source - the input source of the node\n           *\n           * The property is used in source map generation.\n           *\n           * If you create a node manually (e.g., with `postcss.decl()`),\n           * that node will not have a `source` property and will be absent\n           * from the source map. For this reason, the plugin developer should\n           * consider cloning nodes to create new ones (in which case the new nodes\n           * source will reference the original, cloned node) or setting\n           * the `source` property manually.\n           *\n           * ```js\n           * // Bad\n           * const prefixed = postcss.decl({\n           *   prop: '-moz-' + decl.prop,\n           *   value: decl.value\n           * });\n           *\n           * // Good\n           * const prefixed = decl.clone({ prop: '-moz-' + decl.prop });\n           * ```\n           *\n           * ```js\n           * if ( atrule.name == 'add-link' ) {\n           *   const rule = postcss.rule({ selector: 'a', source: atrule.source });\n           *   atrule.parent.insertBefore(atrule, rule);\n           * }\n           * ```\n           *\n           * @example\n           * decl.source.input.from //=> '/home/ai/a.sass'\n           * decl.source.start      //=> { line: 10, column: 2 }\n           * decl.source.end        //=> { line: 10, column: 12 }\n           */\n\n          /**\n           * @memberof Node#\n           * @member {object} raws - Information to generate byte-to-byte equal\n           *                         node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node. It also stores `*`\n           *   and `_` symbols before the declaration (IE hack).\n           * * `after`: the space symbols after the last child of the node\n           *   to the end of the node.\n           * * `between`: the symbols between the property and value\n           *   for declarations, selector and `{` for rules, or last parameter\n           *   and `{` for at-rules.\n           * * `semicolon`: contains true if the last child has\n           *   an (optional) semicolon.\n           * * `afterName`: the space between the at-rule name and its parameters.\n           * * `left`: the space symbols between `/*` and the comments text.\n           * * `right`: the space symbols between the comments text\n           *   and <code>*&#47;</code>.\n           * * `important`: the content of the important statement,\n           *   if it is not just `!important`.\n           *\n           * PostCSS cleans selectors, declaration values and at-rule parameters\n           * from comments and extra spaces, but it stores origin content in raws\n           * properties. As such, if you dont change a declarations value,\n           * PostCSS will use the raw value with comments.\n           *\n           * @example\n           * const root = postcss.parse('a {\\n  color:black\\n}')\n           * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n           */\n\n        }]);\n\n        return Node;\n      }();\n\n      exports.default = Node;\n      /**\n       * @typedef {object} position\n       * @property {number} line   - source line in file\n       * @property {number} column - source column in file\n       */\n\n      /**\n       * @typedef {object} source\n       * @property {Input} input    - {@link Input} with input file\n       * @property {position} start - The starting position of the nodes source\n       * @property {position} end   - The ending position of the nodes source\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _cssSyntaxError = __webpack_require__(73);\n\n      var _cssSyntaxError2 = _interopRequireDefault(_cssSyntaxError);\n\n      var _previousMap = __webpack_require__(149);\n\n      var _previousMap2 = _interopRequireDefault(_previousMap);\n\n      var _path = __webpack_require__(6);\n\n      var _path2 = _interopRequireDefault(_path);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var sequence = 0;\n      /**\n       * Represents the source CSS.\n       *\n       * @example\n       * const root  = postcss.parse(css, { from: file });\n       * const input = root.source.input;\n       */\n\n      var Input = function () {\n        /**\n         * @param {string} css    - input CSS source\n         * @param {object} [opts] - {@link Processor#process} options\n         */\n        function Input(css) {\n          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          _classCallCheck(this, Input);\n          /**\n           * @member {string} - input CSS source\n           *\n           * @example\n           * const input = postcss.parse('a{}', { from: file }).input;\n           * input.css //=> \"a{}\";\n           */\n\n\n          this.css = css.toString();\n\n          if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\\uFFFE\") {\n            this.css = this.css.slice(1);\n          }\n\n          if (opts.from) {\n            if (/^\\w+:\\/\\//.test(opts.from)) {\n              /**\n               * @member {string} - The absolute path to the CSS source file\n               *                    defined with the `from` option.\n               *\n               * @example\n               * const root = postcss.parse(css, { from: 'a.css' });\n               * root.source.input.file //=> '/home/ai/a.css'\n               */\n              this.file = opts.from;\n            } else {\n              this.file = _path2.default.resolve(opts.from);\n            }\n          }\n\n          var map = new _previousMap2.default(this.css, opts);\n\n          if (map.text) {\n            /**\n             * @member {PreviousMap} - The input source map passed from\n             *                         a compilation step before PostCSS\n             *                         (for example, from Sass compiler).\n             *\n             * @example\n             * root.source.input.map.consumer().sources //=> ['a.sass']\n             */\n            this.map = map;\n            var file = map.consumer().file;\n            if (!this.file && file) this.file = this.mapResolve(file);\n          }\n\n          if (!this.file) {\n            sequence += 1;\n            /**\n             * @member {string} - The unique ID of the CSS source. It will be\n             *                    created if `from` option is not provided\n             *                    (because PostCSS does not know the file path).\n             *\n             * @example\n             * const root = postcss.parse(css);\n             * root.source.input.file //=> undefined\n             * root.source.input.id   //=> \"<input css 1>\"\n             */\n\n            this.id = '<input css ' + sequence + '>';\n          }\n\n          if (this.map) this.map.file = this.from;\n        }\n\n        Input.prototype.error = function error(message, line, column) {\n          var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n          var result = void 0;\n          var origin = this.origin(line, column);\n\n          if (origin) {\n            result = new _cssSyntaxError2.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);\n          } else {\n            result = new _cssSyntaxError2.default(message, line, column, this.css, this.file, opts.plugin);\n          }\n\n          result.input = {\n            line: line,\n            column: column,\n            source: this.css\n          };\n          if (this.file) result.input.file = this.file;\n          return result;\n        };\n        /**\n         * Reads the input source map and returns a symbol position\n         * in the input source (e.g., in a Sass file that was compiled\n         * to CSS before being passed to PostCSS).\n         *\n         * @param {number} line   - line in input CSS\n         * @param {number} column - column in input CSS\n         *\n         * @return {filePosition} position in input source\n         *\n         * @example\n         * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }\n         */\n\n\n        Input.prototype.origin = function origin(line, column) {\n          if (!this.map) return false;\n          var consumer = this.map.consumer();\n          var from = consumer.originalPositionFor({\n            line: line,\n            column: column\n          });\n          if (!from.source) return false;\n          var result = {\n            file: this.mapResolve(from.source),\n            line: from.line,\n            column: from.column\n          };\n          var source = consumer.sourceContentFor(from.source);\n          if (source) result.source = source;\n          return result;\n        };\n\n        Input.prototype.mapResolve = function mapResolve(file) {\n          if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n          } else {\n            return _path2.default.resolve(this.map.consumer().sourceRoot || '.', file);\n          }\n        };\n        /**\n         * The CSS source identifier. Contains {@link Input#file} if the user\n         * set the `from` option, or {@link Input#id} if they did not.\n         * @type {string}\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.css' });\n         * root.source.input.from //=> \"/home/ai/a.css\"\n         *\n         * const root = postcss.parse(css);\n         * root.source.input.from //=> \"<input css 1>\"\n         */\n\n\n        _createClass(Input, [{\n          key: 'from',\n          get: function get() {\n            return this.file || this.id;\n          }\n        }]);\n\n        return Input;\n      }();\n\n      exports.default = Input;\n      /**\n       * @typedef  {object} filePosition\n       * @property {string} file   - path to file\n       * @property {number} line   - source line in file\n       * @property {number} column - source column in file\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var defaultRaw = {\n        colon: ': ',\n        indent: '    ',\n        beforeDecl: '\\n',\n        beforeRule: '\\n',\n        beforeOpen: ' ',\n        beforeClose: '\\n',\n        beforeComment: '\\n',\n        after: '\\n',\n        emptyBody: '',\n        commentLeft: ' ',\n        commentRight: ' '\n      };\n\n      function capitalize(str) {\n        return str[0].toUpperCase() + str.slice(1);\n      }\n\n      var Stringifier = function () {\n        function Stringifier(builder) {\n          _classCallCheck(this, Stringifier);\n\n          this.builder = builder;\n        }\n\n        Stringifier.prototype.stringify = function stringify(node, semicolon) {\n          this[node.type](node, semicolon);\n        };\n\n        Stringifier.prototype.root = function root(node) {\n          this.body(node);\n          if (node.raws.after) this.builder(node.raws.after);\n        };\n\n        Stringifier.prototype.comment = function comment(node) {\n          var left = this.raw(node, 'left', 'commentLeft');\n          var right = this.raw(node, 'right', 'commentRight');\n          this.builder('/*' + left + node.text + right + '*/', node);\n        };\n\n        Stringifier.prototype.decl = function decl(node, semicolon) {\n          var between = this.raw(node, 'between', 'colon');\n          var string = node.prop + between + this.rawValue(node, 'value');\n\n          if (node.important) {\n            string += node.raws.important || ' !important';\n          }\n\n          if (semicolon) string += ';';\n          this.builder(string, node);\n        };\n\n        Stringifier.prototype.rule = function rule(node) {\n          this.block(node, this.rawValue(node, 'selector'));\n        };\n\n        Stringifier.prototype.atrule = function atrule(node, semicolon) {\n          var name = '@' + node.name;\n          var params = node.params ? this.rawValue(node, 'params') : '';\n\n          if (typeof node.raws.afterName !== 'undefined') {\n            name += node.raws.afterName;\n          } else if (params) {\n            name += ' ';\n          }\n\n          if (node.nodes) {\n            this.block(node, name + params);\n          } else {\n            var end = (node.raws.between || '') + (semicolon ? ';' : '');\n            this.builder(name + params + end, node);\n          }\n        };\n\n        Stringifier.prototype.body = function body(node) {\n          var last = node.nodes.length - 1;\n\n          while (last > 0) {\n            if (node.nodes[last].type !== 'comment') break;\n            last -= 1;\n          }\n\n          var semicolon = this.raw(node, 'semicolon');\n\n          for (var i = 0; i < node.nodes.length; i++) {\n            var child = node.nodes[i];\n            var before = this.raw(child, 'before');\n            if (before) this.builder(before);\n            this.stringify(child, last !== i || semicolon);\n          }\n        };\n\n        Stringifier.prototype.block = function block(node, start) {\n          var between = this.raw(node, 'between', 'beforeOpen');\n          this.builder(start + between + '{', node, 'start');\n          var after = void 0;\n\n          if (node.nodes && node.nodes.length) {\n            this.body(node);\n            after = this.raw(node, 'after');\n          } else {\n            after = this.raw(node, 'after', 'emptyBody');\n          }\n\n          if (after) this.builder(after);\n          this.builder('}', node, 'end');\n        };\n\n        Stringifier.prototype.raw = function raw(node, own, detect) {\n          var value = void 0;\n          if (!detect) detect = own; // Already had\n\n          if (own) {\n            value = node.raws[own];\n            if (typeof value !== 'undefined') return value;\n          }\n\n          var parent = node.parent; // Hack for first rule in CSS\n\n          if (detect === 'before') {\n            if (!parent || parent.type === 'root' && parent.first === node) {\n              return '';\n            }\n          } // Floating child without parent\n\n\n          if (!parent) return defaultRaw[detect]; // Detect style by other nodes\n\n          var root = node.root();\n          if (!root.rawCache) root.rawCache = {};\n\n          if (typeof root.rawCache[detect] !== 'undefined') {\n            return root.rawCache[detect];\n          }\n\n          if (detect === 'before' || detect === 'after') {\n            return this.beforeAfter(node, detect);\n          } else {\n            var method = 'raw' + capitalize(detect);\n\n            if (this[method]) {\n              value = this[method](root, node);\n            } else {\n              root.walk(function (i) {\n                value = i.raws[own];\n                if (typeof value !== 'undefined') return false;\n              });\n            }\n          }\n\n          if (typeof value === 'undefined') value = defaultRaw[detect];\n          root.rawCache[detect] = value;\n          return value;\n        };\n\n        Stringifier.prototype.rawSemicolon = function rawSemicolon(root) {\n          var value = void 0;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length && i.last.type === 'decl') {\n              value = i.raws.semicolon;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawEmptyBody = function rawEmptyBody(root) {\n          var value = void 0;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length === 0) {\n              value = i.raws.after;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawIndent = function rawIndent(root) {\n          if (root.raws.indent) return root.raws.indent;\n          var value = void 0;\n          root.walk(function (i) {\n            var p = i.parent;\n\n            if (p && p !== root && p.parent && p.parent === root) {\n              if (typeof i.raws.before !== 'undefined') {\n                var parts = i.raws.before.split('\\n');\n                value = parts[parts.length - 1];\n                value = value.replace(/[^\\s]/g, '');\n                return false;\n              }\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawBeforeComment = function rawBeforeComment(root, node) {\n          var value = void 0;\n          root.walkComments(function (i) {\n            if (typeof i.raws.before !== 'undefined') {\n              value = i.raws.before;\n\n              if (value.indexOf('\\n') !== -1) {\n                value = value.replace(/[^\\n]+$/, '');\n              }\n\n              return false;\n            }\n          });\n\n          if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeDecl');\n          }\n\n          return value;\n        };\n\n        Stringifier.prototype.rawBeforeDecl = function rawBeforeDecl(root, node) {\n          var value = void 0;\n          root.walkDecls(function (i) {\n            if (typeof i.raws.before !== 'undefined') {\n              value = i.raws.before;\n\n              if (value.indexOf('\\n') !== -1) {\n                value = value.replace(/[^\\n]+$/, '');\n              }\n\n              return false;\n            }\n          });\n\n          if (typeof value === 'undefined') {\n            value = this.raw(node, null, 'beforeRule');\n          }\n\n          return value;\n        };\n\n        Stringifier.prototype.rawBeforeRule = function rawBeforeRule(root) {\n          var value = void 0;\n          root.walk(function (i) {\n            if (i.nodes && (i.parent !== root || root.first !== i)) {\n              if (typeof i.raws.before !== 'undefined') {\n                value = i.raws.before;\n\n                if (value.indexOf('\\n') !== -1) {\n                  value = value.replace(/[^\\n]+$/, '');\n                }\n\n                return false;\n              }\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawBeforeClose = function rawBeforeClose(root) {\n          var value = void 0;\n          root.walk(function (i) {\n            if (i.nodes && i.nodes.length > 0) {\n              if (typeof i.raws.after !== 'undefined') {\n                value = i.raws.after;\n\n                if (value.indexOf('\\n') !== -1) {\n                  value = value.replace(/[^\\n]+$/, '');\n                }\n\n                return false;\n              }\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawBeforeOpen = function rawBeforeOpen(root) {\n          var value = void 0;\n          root.walk(function (i) {\n            if (i.type !== 'decl') {\n              value = i.raws.between;\n              if (typeof value !== 'undefined') return false;\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.rawColon = function rawColon(root) {\n          var value = void 0;\n          root.walkDecls(function (i) {\n            if (typeof i.raws.between !== 'undefined') {\n              value = i.raws.between.replace(/[^\\s:]/g, '');\n              return false;\n            }\n          });\n          return value;\n        };\n\n        Stringifier.prototype.beforeAfter = function beforeAfter(node, detect) {\n          var value = void 0;\n\n          if (node.type === 'decl') {\n            value = this.raw(node, null, 'beforeDecl');\n          } else if (node.type === 'comment') {\n            value = this.raw(node, null, 'beforeComment');\n          } else if (detect === 'before') {\n            value = this.raw(node, null, 'beforeRule');\n          } else {\n            value = this.raw(node, null, 'beforeClose');\n          }\n\n          var buf = node.parent;\n          var depth = 0;\n\n          while (buf && buf.type !== 'root') {\n            depth += 1;\n            buf = buf.parent;\n          }\n\n          if (value.indexOf('\\n') !== -1) {\n            var indent = this.raw(node, null, 'indent');\n\n            if (indent.length) {\n              for (var step = 0; step < depth; step++) {\n                value += indent;\n              }\n            }\n          }\n\n          return value;\n        };\n\n        Stringifier.prototype.rawValue = function rawValue(node, prop) {\n          var value = node[prop];\n          var raw = node.raws[prop];\n\n          if (raw && raw.value === value) {\n            return raw.raw;\n          } else {\n            return value;\n          }\n        };\n\n        return Stringifier;\n      }();\n\n      exports.default = Stringifier;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _declaration = __webpack_require__(83);\n\n      var _declaration2 = _interopRequireDefault(_declaration);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      var _comment = __webpack_require__(21);\n\n      var _comment2 = _interopRequireDefault(_comment);\n\n      var _node = __webpack_require__(22);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      function cleanSource(nodes) {\n        return nodes.map(function (i) {\n          if (i.nodes) i.nodes = cleanSource(i.nodes);\n          delete i.source;\n          return i;\n        });\n      }\n      /**\n       * The {@link Root}, {@link AtRule}, and {@link Rule} container nodes\n       * inherit some common methods to help work with their children.\n       *\n       * Note that all containers can store any content. If you write a rule inside\n       * a rule, PostCSS will parse it.\n       *\n       * @extends Node\n       * @abstract\n       */\n\n\n      var Container = function (_Node) {\n        _inherits(Container, _Node);\n\n        function Container() {\n          _classCallCheck(this, Container);\n\n          return _possibleConstructorReturn(this, _Node.apply(this, arguments));\n        }\n\n        Container.prototype.push = function push(child) {\n          child.parent = this;\n          this.nodes.push(child);\n          return this;\n        };\n        /**\n         * Iterates through the containers immediate children,\n         * calling `callback` for each child.\n         *\n         * Returning `false` in the callback will break iteration.\n         *\n         * This method only iterates through the containers immediate children.\n         * If you need to recursively iterate through all the containers descendant\n         * nodes, use {@link Container#walk}.\n         *\n         * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe\n         * if you are mutating the array of child nodes during iteration.\n         * PostCSS will adjust the current index to match the mutations.\n         *\n         * @param {childIterator} callback - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * const root = postcss.parse('a { color: black; z-index: 1 }');\n         * const rule = root.first;\n         *\n         * for ( let decl of rule.nodes ) {\n         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n         *     // Cycle will be infinite, because cloneBefore moves the current node\n         *     // to the next index\n         * }\n         *\n         * rule.each(decl => {\n         *     decl.cloneBefore({ prop: '-webkit-' + decl.prop });\n         *     // Will be executed only for color and z-index\n         * });\n         */\n\n\n        Container.prototype.each = function each(callback) {\n          if (!this.lastEach) this.lastEach = 0;\n          if (!this.indexes) this.indexes = {};\n          this.lastEach += 1;\n          var id = this.lastEach;\n          this.indexes[id] = 0;\n          if (!this.nodes) return undefined;\n          var index = void 0,\n              result = void 0;\n\n          while (this.indexes[id] < this.nodes.length) {\n            index = this.indexes[id];\n            result = callback(this.nodes[index], index);\n            if (result === false) break;\n            this.indexes[id] += 1;\n          }\n\n          delete this.indexes[id];\n          return result;\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each node.\n         *\n         * Like container.each(), this method is safe to use\n         * if you are mutating arrays during iteration.\n         *\n         * If you only need to iterate through the containers immediate children,\n         * use {@link Container#each}.\n         *\n         * @param {childIterator} callback - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * root.walk(node => {\n         *   // Traverses all descendant nodes.\n         * });\n         */\n\n\n        Container.prototype.walk = function walk(callback) {\n          return this.each(function (child, i) {\n            var result = callback(child, i);\n\n            if (result !== false && child.walk) {\n              result = child.walk(callback);\n            }\n\n            return result;\n          });\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each declaration node.\n         *\n         * If you pass a filter, iteration will only happen over declarations\n         * with matching properties.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [prop]   - string or regular expression\n         *                                   to filter declarations by property name\n         * @param {childIterator} callback - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * root.walkDecls(decl => {\n         *   checkPropertySupport(decl.prop);\n         * });\n         *\n         * root.walkDecls('border-radius', decl => {\n         *   decl.remove();\n         * });\n         *\n         * root.walkDecls(/^background/, decl => {\n         *   decl.value = takeFirstColorFromGradient(decl.value);\n         * });\n         */\n\n\n        Container.prototype.walkDecls = function walkDecls(prop, callback) {\n          if (!callback) {\n            callback = prop;\n            return this.walk(function (child, i) {\n              if (child.type === 'decl') {\n                return callback(child, i);\n              }\n            });\n          } else if (prop instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'decl' && prop.test(child.prop)) {\n                return callback(child, i);\n              }\n            });\n          } else {\n            return this.walk(function (child, i) {\n              if (child.type === 'decl' && child.prop === prop) {\n                return callback(child, i);\n              }\n            });\n          }\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each rule node.\n         *\n         * If you pass a filter, iteration will only happen over rules\n         * with matching selectors.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [selector] - string or regular expression\n         *                                     to filter rules by selector\n         * @param {childIterator} callback   - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * const selectors = [];\n         * root.walkRules(rule => {\n         *   selectors.push(rule.selector);\n         * });\n         * console.log(`Your CSS uses ${selectors.length} selectors`);\n         */\n\n\n        Container.prototype.walkRules = function walkRules(selector, callback) {\n          if (!callback) {\n            callback = selector;\n            return this.walk(function (child, i) {\n              if (child.type === 'rule') {\n                return callback(child, i);\n              }\n            });\n          } else if (selector instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'rule' && selector.test(child.selector)) {\n                return callback(child, i);\n              }\n            });\n          } else {\n            return this.walk(function (child, i) {\n              if (child.type === 'rule' && child.selector === selector) {\n                return callback(child, i);\n              }\n            });\n          }\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each at-rule node.\n         *\n         * If you pass a filter, iteration will only happen over at-rules\n         * that have matching names.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {string|RegExp} [name]   - string or regular expression\n         *                                   to filter at-rules by name\n         * @param {childIterator} callback - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * root.walkAtRules(rule => {\n         *   if ( isOld(rule.name) ) rule.remove();\n         * });\n         *\n         * let first = false;\n         * root.walkAtRules('charset', rule => {\n         *   if ( !first ) {\n         *     first = true;\n         *   } else {\n         *     rule.remove();\n         *   }\n         * });\n         */\n\n\n        Container.prototype.walkAtRules = function walkAtRules(name, callback) {\n          if (!callback) {\n            callback = name;\n            return this.walk(function (child, i) {\n              if (child.type === 'atrule') {\n                return callback(child, i);\n              }\n            });\n          } else if (name instanceof RegExp) {\n            return this.walk(function (child, i) {\n              if (child.type === 'atrule' && name.test(child.name)) {\n                return callback(child, i);\n              }\n            });\n          } else {\n            return this.walk(function (child, i) {\n              if (child.type === 'atrule' && child.name === name) {\n                return callback(child, i);\n              }\n            });\n          }\n        };\n        /**\n         * Traverses the containers descendant nodes, calling callback\n         * for each comment node.\n         *\n         * Like {@link Container#each}, this method is safe\n         * to use if you are mutating arrays during iteration.\n         *\n         * @param {childIterator} callback - iterator receives each node and index\n         *\n         * @return {false|undefined} returns `false` if iteration was broke\n         *\n         * @example\n         * root.walkComments(comment => {\n         *   comment.remove();\n         * });\n         */\n\n\n        Container.prototype.walkComments = function walkComments(callback) {\n          return this.walk(function (child, i) {\n            if (child.type === 'comment') {\n              return callback(child, i);\n            }\n          });\n        };\n        /**\n         * Inserts new nodes to the end of the container.\n         *\n         * @param {...(Node|object|string|Node[])} children - new nodes\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n         * rule.append(decl1, decl2);\n         *\n         * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n         * root.append({ selector: 'a' });                       // rule\n         * rule.append({ prop: 'color', value: 'black' });       // declaration\n         * rule.append({ text: 'Comment' })                      // comment\n         *\n         * root.append('a {}');\n         * root.first.append('color: black; z-index: 1');\n         */\n\n\n        Container.prototype.append = function append() {\n          for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n            children[_key] = arguments[_key];\n          }\n\n          for (var _iterator = children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var child = _ref;\n            var nodes = this.normalize(child, this.last);\n\n            for (var _iterator2 = nodes, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n              var _ref2;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref2 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref2 = _i2.value;\n              }\n\n              var node = _ref2;\n              this.nodes.push(node);\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Inserts new nodes to the start of the container.\n         *\n         * @param {...(Node|object|string|Node[])} children - new nodes\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * const decl1 = postcss.decl({ prop: 'color', value: 'black' });\n         * const decl2 = postcss.decl({ prop: 'background-color', value: 'white' });\n         * rule.prepend(decl1, decl2);\n         *\n         * root.append({ name: 'charset', params: '\"UTF-8\"' });  // at-rule\n         * root.append({ selector: 'a' });                       // rule\n         * rule.append({ prop: 'color', value: 'black' });       // declaration\n         * rule.append({ text: 'Comment' })                      // comment\n         *\n         * root.append('a {}');\n         * root.first.append('color: black; z-index: 1');\n         */\n\n\n        Container.prototype.prepend = function prepend() {\n          for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            children[_key2] = arguments[_key2];\n          }\n\n          children = children.reverse();\n\n          for (var _iterator3 = children, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n            var _ref3;\n\n            if (_isArray3) {\n              if (_i3 >= _iterator3.length) break;\n              _ref3 = _iterator3[_i3++];\n            } else {\n              _i3 = _iterator3.next();\n              if (_i3.done) break;\n              _ref3 = _i3.value;\n            }\n\n            var child = _ref3;\n            var nodes = this.normalize(child, this.first, 'prepend').reverse();\n\n            for (var _iterator4 = nodes, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n              var _ref4;\n\n              if (_isArray4) {\n                if (_i4 >= _iterator4.length) break;\n                _ref4 = _iterator4[_i4++];\n              } else {\n                _i4 = _iterator4.next();\n                if (_i4.done) break;\n                _ref4 = _i4.value;\n              }\n\n              var node = _ref4;\n              this.nodes.unshift(node);\n            }\n\n            for (var id in this.indexes) {\n              this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n          }\n\n          return this;\n        };\n\n        Container.prototype.cleanRaws = function cleanRaws(keepBetween) {\n          _Node.prototype.cleanRaws.call(this, keepBetween);\n\n          if (this.nodes) {\n            for (var _iterator5 = this.nodes, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n              var _ref5;\n\n              if (_isArray5) {\n                if (_i5 >= _iterator5.length) break;\n                _ref5 = _iterator5[_i5++];\n              } else {\n                _i5 = _iterator5.next();\n                if (_i5.done) break;\n                _ref5 = _i5.value;\n              }\n\n              var node = _ref5;\n              node.cleanRaws(keepBetween);\n            }\n          }\n        };\n        /**\n         * Insert new node before old node within the container.\n         *\n         * @param {Node|number} exist             - child or childs index.\n         * @param {Node|object|string|Node[]} add - new node\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }));\n         */\n\n\n        Container.prototype.insertBefore = function insertBefore(exist, add) {\n          exist = this.index(exist);\n          var type = exist === 0 ? 'prepend' : false;\n          var nodes = this.normalize(add, this.nodes[exist], type).reverse();\n\n          for (var _iterator6 = nodes, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n            var _ref6;\n\n            if (_isArray6) {\n              if (_i6 >= _iterator6.length) break;\n              _ref6 = _iterator6[_i6++];\n            } else {\n              _i6 = _iterator6.next();\n              if (_i6.done) break;\n              _ref6 = _i6.value;\n            }\n\n            var node = _ref6;\n            this.nodes.splice(exist, 0, node);\n          }\n\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (exist <= index) {\n              this.indexes[id] = index + nodes.length;\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Insert new node after old node within the container.\n         *\n         * @param {Node|number} exist             - child or childs index\n         * @param {Node|object|string|Node[]} add - new node\n         *\n         * @return {Node} this node for methods chain\n         */\n\n\n        Container.prototype.insertAfter = function insertAfter(exist, add) {\n          exist = this.index(exist);\n          var nodes = this.normalize(add, this.nodes[exist]).reverse();\n\n          for (var _iterator7 = nodes, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n            var _ref7;\n\n            if (_isArray7) {\n              if (_i7 >= _iterator7.length) break;\n              _ref7 = _iterator7[_i7++];\n            } else {\n              _i7 = _iterator7.next();\n              if (_i7.done) break;\n              _ref7 = _i7.value;\n            }\n\n            var node = _ref7;\n            this.nodes.splice(exist + 1, 0, node);\n          }\n\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (exist < index) {\n              this.indexes[id] = index + nodes.length;\n            }\n          }\n\n          return this;\n        };\n\n        Container.prototype.remove = function remove(child) {\n          if (typeof child !== 'undefined') {\n            (0, _warnOnce2.default)('Container#remove is deprecated. ' + 'Use Container#removeChild');\n            this.removeChild(child);\n          } else {\n            _Node.prototype.remove.call(this);\n          }\n\n          return this;\n        };\n        /**\n         * Removes node from the container and cleans the parent properties\n         * from the node and its children.\n         *\n         * @param {Node|number} child - child or childs index\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * rule.nodes.length  //=> 5\n         * rule.removeChild(decl);\n         * rule.nodes.length  //=> 4\n         * decl.parent        //=> undefined\n         */\n\n\n        Container.prototype.removeChild = function removeChild(child) {\n          child = this.index(child);\n          this.nodes[child].parent = undefined;\n          this.nodes.splice(child, 1);\n          var index = void 0;\n\n          for (var id in this.indexes) {\n            index = this.indexes[id];\n\n            if (index >= child) {\n              this.indexes[id] = index - 1;\n            }\n          }\n\n          return this;\n        };\n        /**\n         * Removes all children from the container\n         * and cleans their parent properties.\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * rule.removeAll();\n         * rule.nodes.length //=> 0\n         */\n\n\n        Container.prototype.removeAll = function removeAll() {\n          for (var _iterator8 = this.nodes, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n            var _ref8;\n\n            if (_isArray8) {\n              if (_i8 >= _iterator8.length) break;\n              _ref8 = _iterator8[_i8++];\n            } else {\n              _i8 = _iterator8.next();\n              if (_i8.done) break;\n              _ref8 = _i8.value;\n            }\n\n            var node = _ref8;\n            node.parent = undefined;\n          }\n\n          this.nodes = [];\n          return this;\n        };\n        /**\n         * Passes all declaration values within the container that match pattern\n         * through callback, replacing those values with the returned result\n         * of callback.\n         *\n         * This method is useful if you are using a custom unit or function\n         * and need to iterate through all values.\n         *\n         * @param {string|RegExp} pattern      - replace pattern\n         * @param {object} opts                - options to speed up the search\n         * @param {string|string[]} opts.props - an array of property names\n         * @param {string} opts.fast           - string thats used\n         *                                       to narrow down values and speed up\n                                                 the regexp search\n         * @param {function|string} callback   - string to replace pattern\n         *                                       or callback that returns a new\n         *                                       value.\n         *                                       The callback will receive\n         *                                       the same arguments as those\n         *                                       passed to a function parameter\n         *                                       of `String#replace`.\n         *\n         * @return {Node} this node for methods chain\n         *\n         * @example\n         * root.replaceValues(/\\d+rem/, { fast: 'rem' }, string => {\n         *   return 15 * parseInt(string) + 'px';\n         * });\n         */\n\n\n        Container.prototype.replaceValues = function replaceValues(pattern, opts, callback) {\n          if (!callback) {\n            callback = opts;\n            opts = {};\n          }\n\n          this.walkDecls(function (decl) {\n            if (opts.props && opts.props.indexOf(decl.prop) === -1) return;\n            if (opts.fast && decl.value.indexOf(opts.fast) === -1) return;\n            decl.value = decl.value.replace(pattern, callback);\n          });\n          return this;\n        };\n        /**\n         * Returns `true` if callback returns `true`\n         * for all of the containers children.\n         *\n         * @param {childCondition} condition - iterator returns true or false.\n         *\n         * @return {boolean} is every child pass condition\n         *\n         * @example\n         * const noPrefixes = rule.every(i => i.prop[0] !== '-');\n         */\n\n\n        Container.prototype.every = function every(condition) {\n          return this.nodes.every(condition);\n        };\n        /**\n         * Returns `true` if callback returns `true` for (at least) one\n         * of the containers children.\n         *\n         * @param {childCondition} condition - iterator returns true or false.\n         *\n         * @return {boolean} is some child pass condition\n         *\n         * @example\n         * const hasPrefix = rule.some(i => i.prop[0] === '-');\n         */\n\n\n        Container.prototype.some = function some(condition) {\n          return this.nodes.some(condition);\n        };\n        /**\n         * Returns a `child`s index within the {@link Container#nodes} array.\n         *\n         * @param {Node} child - child of the current container.\n         *\n         * @return {number} child index\n         *\n         * @example\n         * rule.index( rule.nodes[2] ) //=> 2\n         */\n\n\n        Container.prototype.index = function index(child) {\n          if (typeof child === 'number') {\n            return child;\n          } else {\n            return this.nodes.indexOf(child);\n          }\n        };\n        /**\n         * The containers first child.\n         *\n         * @type {Node}\n         *\n         * @example\n         * rule.first == rules.nodes[0];\n         */\n\n\n        Container.prototype.normalize = function normalize(nodes, sample) {\n          var _this2 = this;\n\n          if (typeof nodes === 'string') {\n            var parse = __webpack_require__(84);\n\n            nodes = cleanSource(parse(nodes).nodes);\n          } else if (!Array.isArray(nodes)) {\n            if (nodes.type === 'root') {\n              nodes = nodes.nodes;\n            } else if (nodes.type) {\n              nodes = [nodes];\n            } else if (nodes.prop) {\n              if (typeof nodes.value === 'undefined') {\n                throw new Error('Value field is missed in node creation');\n              } else if (typeof nodes.value !== 'string') {\n                nodes.value = String(nodes.value);\n              }\n\n              nodes = [new _declaration2.default(nodes)];\n            } else if (nodes.selector) {\n              var Rule = __webpack_require__(10);\n\n              nodes = [new Rule(nodes)];\n            } else if (nodes.name) {\n              var AtRule = __webpack_require__(26);\n\n              nodes = [new AtRule(nodes)];\n            } else if (nodes.text) {\n              nodes = [new _comment2.default(nodes)];\n            } else {\n              throw new Error('Unknown node type in node creation');\n            }\n          }\n\n          var processed = nodes.map(function (i) {\n            if (typeof i.raws === 'undefined') i = _this2.rebuild(i);\n            if (i.parent) i = i.clone();\n\n            if (typeof i.raws.before === 'undefined') {\n              if (sample && typeof sample.raws.before !== 'undefined') {\n                i.raws.before = sample.raws.before.replace(/[^\\s]/g, '');\n              }\n            }\n\n            i.parent = _this2;\n            return i;\n          });\n          return processed;\n        };\n\n        Container.prototype.rebuild = function rebuild(node, parent) {\n          var _this3 = this;\n\n          var fix = void 0;\n\n          if (node.type === 'root') {\n            var Root = __webpack_require__(27);\n\n            fix = new Root();\n          } else if (node.type === 'atrule') {\n            var AtRule = __webpack_require__(26);\n\n            fix = new AtRule();\n          } else if (node.type === 'rule') {\n            var Rule = __webpack_require__(10);\n\n            fix = new Rule();\n          } else if (node.type === 'decl') {\n            fix = new _declaration2.default();\n          } else if (node.type === 'comment') {\n            fix = new _comment2.default();\n          }\n\n          for (var i in node) {\n            if (i === 'nodes') {\n              fix.nodes = node.nodes.map(function (j) {\n                return _this3.rebuild(j, fix);\n              });\n            } else if (i === 'parent' && parent) {\n              fix.parent = parent;\n            } else if (node.hasOwnProperty(i)) {\n              fix[i] = node[i];\n            }\n          }\n\n          return fix;\n        };\n\n        Container.prototype.eachInside = function eachInside(callback) {\n          (0, _warnOnce2.default)('Container#eachInside is deprecated. ' + 'Use Container#walk instead.');\n          return this.walk(callback);\n        };\n\n        Container.prototype.eachDecl = function eachDecl(prop, callback) {\n          (0, _warnOnce2.default)('Container#eachDecl is deprecated. ' + 'Use Container#walkDecls instead.');\n          return this.walkDecls(prop, callback);\n        };\n\n        Container.prototype.eachRule = function eachRule(selector, callback) {\n          (0, _warnOnce2.default)('Container#eachRule is deprecated. ' + 'Use Container#walkRules instead.');\n          return this.walkRules(selector, callback);\n        };\n\n        Container.prototype.eachAtRule = function eachAtRule(name, callback) {\n          (0, _warnOnce2.default)('Container#eachAtRule is deprecated. ' + 'Use Container#walkAtRules instead.');\n          return this.walkAtRules(name, callback);\n        };\n\n        Container.prototype.eachComment = function eachComment(callback) {\n          (0, _warnOnce2.default)('Container#eachComment is deprecated. ' + 'Use Container#walkComments instead.');\n          return this.walkComments(callback);\n        };\n\n        _createClass(Container, [{\n          key: 'first',\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[0];\n          }\n          /**\n           * The containers last child.\n           *\n           * @type {Node}\n           *\n           * @example\n           * rule.last == rule.nodes[rule.nodes.length - 1];\n           */\n\n        }, {\n          key: 'last',\n          get: function get() {\n            if (!this.nodes) return undefined;\n            return this.nodes[this.nodes.length - 1];\n          }\n        }, {\n          key: 'semicolon',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n            return this.raws.semicolon;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#semicolon is deprecated. Use Node#raws.semicolon');\n            this.raws.semicolon = val;\n          }\n        }, {\n          key: 'after',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n            return this.raws.after;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#after is deprecated. Use Node#raws.after');\n            this.raws.after = val;\n          }\n          /**\n           * @memberof Container#\n           * @member {Node[]} nodes - an array containing the containers children\n           *\n           * @example\n           * const root = postcss.parse('a { color: black }');\n           * root.nodes.length           //=> 1\n           * root.nodes[0].selector      //=> 'a'\n           * root.nodes[0].nodes[0].prop //=> 'color'\n           */\n\n        }]);\n\n        return Container;\n      }(_node2.default);\n\n      exports.default = Container;\n      /**\n       * @callback childCondition\n       * @param {Node} node    - container child\n       * @param {number} index - child index\n       * @param {Node[]} nodes - all container children\n       * @return {boolean}\n       */\n\n      /**\n       * @callback childIterator\n       * @param {Node} node    - container child\n       * @param {number} index - child index\n       * @return {false|undefined} returning `false` will break iteration\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _container = __webpack_require__(25);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents an at-rule.\n       *\n       * If its followed in the CSS by a {} block, this node will have\n       * a nodes property representing its children.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('@charset \"UTF-8\"; @media print {}');\n       *\n       * const charset = root.first;\n       * charset.type  //=> 'atrule'\n       * charset.nodes //=> undefined\n       *\n       * const media = root.last;\n       * media.nodes   //=> []\n       */\n\n\n      var AtRule = function (_Container) {\n        _inherits(AtRule, _Container);\n\n        function AtRule(defaults) {\n          _classCallCheck(this, AtRule);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));\n\n          _this.type = 'atrule';\n          return _this;\n        }\n\n        AtRule.prototype.append = function append() {\n          var _Container$prototype$;\n\n          if (!this.nodes) this.nodes = [];\n\n          for (var _len = arguments.length, children = Array(_len), _key = 0; _key < _len; _key++) {\n            children[_key] = arguments[_key];\n          }\n\n          return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));\n        };\n\n        AtRule.prototype.prepend = function prepend() {\n          var _Container$prototype$2;\n\n          if (!this.nodes) this.nodes = [];\n\n          for (var _len2 = arguments.length, children = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            children[_key2] = arguments[_key2];\n          }\n\n          return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));\n        };\n\n        _createClass(AtRule, [{\n          key: 'afterName',\n          get: function get() {\n            (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');\n            return this.raws.afterName;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('AtRule#afterName was deprecated. Use AtRule#raws.afterName');\n            this.raws.afterName = val;\n          }\n        }, {\n          key: '_params',\n          get: function get() {\n            (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');\n            return this.raws.params;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('AtRule#_params was deprecated. Use AtRule#raws.params');\n            this.raws.params = val;\n          }\n          /**\n           * @memberof AtRule#\n           * @member {string} name - the at-rules name immediately follows the `@`\n           *\n           * @example\n           * const root  = postcss.parse('@media print {}');\n           * media.name //=> 'media'\n           * const media = root.first;\n           */\n\n          /**\n           * @memberof AtRule#\n           * @member {string} params - the at-rules parameters, the values\n           *                           that follow the at-rules name but precede\n           *                           any {} block\n           *\n           * @example\n           * const root  = postcss.parse('@media print, screen {}');\n           * const media = root.first;\n           * media.params //=> 'print, screen'\n           */\n\n          /**\n           * @memberof AtRule#\n           * @member {object} raws - Information to generate byte-to-byte equal\n           *                         node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node. It also stores `*`\n           *   and `_` symbols before the declaration (IE hack).\n           * * `after`: the space symbols after the last child of the node\n           *   to the end of the node.\n           * * `between`: the symbols between the property and value\n           *   for declarations, selector and `{` for rules, or last parameter\n           *   and `{` for at-rules.\n           * * `semicolon`: contains true if the last child has\n           *   an (optional) semicolon.\n           * * `afterName`: the space between the at-rule name and its parameters.\n           *\n           * PostCSS cleans at-rule parameters from comments and extra spaces,\n           * but it stores origin content in raws properties.\n           * As such, if you dont change a declarations value,\n           * PostCSS will use the raw value with comments.\n           *\n           * @example\n           * const root = postcss.parse('  @media\\nprint {\\n}')\n           * root.first.first.raws //=> { before: '  ',\n           *                       //     between: ' ',\n           *                       //     afterName: '\\n',\n           *                       //     after: '\\n' }\n           */\n\n        }]);\n\n        return AtRule;\n      }(_container2.default);\n\n      exports.default = AtRule;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 27 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _container = __webpack_require__(25);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS file and contains all its parsed nodes.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('a{color:black} b{z-index:2}');\n       * root.type         //=> 'root'\n       * root.nodes.length //=> 2\n       */\n\n\n      var Root = function (_Container) {\n        _inherits(Root, _Container);\n\n        function Root(defaults) {\n          _classCallCheck(this, Root);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));\n\n          _this.type = 'root';\n          if (!_this.nodes) _this.nodes = [];\n          return _this;\n        }\n\n        Root.prototype.removeChild = function removeChild(child) {\n          child = this.index(child);\n\n          if (child === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[child].raws.before;\n          }\n\n          return _Container.prototype.removeChild.call(this, child);\n        };\n\n        Root.prototype.normalize = function normalize(child, sample, type) {\n          var nodes = _Container.prototype.normalize.call(this, child);\n\n          if (sample) {\n            if (type === 'prepend') {\n              if (this.nodes.length > 1) {\n                sample.raws.before = this.nodes[1].raws.before;\n              } else {\n                delete sample.raws.before;\n              }\n            } else if (this.first !== sample) {\n              for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n                var _ref;\n\n                if (_isArray) {\n                  if (_i >= _iterator.length) break;\n                  _ref = _iterator[_i++];\n                } else {\n                  _i = _iterator.next();\n                  if (_i.done) break;\n                  _ref = _i.value;\n                }\n\n                var node = _ref;\n                node.raws.before = sample.raws.before;\n              }\n            }\n          }\n\n          return nodes;\n        };\n        /**\n         * Returns a {@link Result} instance representing the roots CSS.\n         *\n         * @param {processOptions} [opts] - options with only `to` and `map` keys\n         *\n         * @return {Result} result with current roots CSS\n         *\n         * @example\n         * const root1 = postcss.parse(css1, { from: 'a.css' });\n         * const root2 = postcss.parse(css2, { from: 'b.css' });\n         * root1.append(root2);\n         * const result = root1.toResult({ to: 'all.css', map: true });\n         */\n\n\n        Root.prototype.toResult = function toResult() {\n          var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          var LazyResult = __webpack_require__(86);\n\n          var Processor = __webpack_require__(161);\n\n          var lazy = new LazyResult(new Processor(), this, opts);\n          return lazy.stringify();\n        };\n\n        Root.prototype.remove = function remove(child) {\n          (0, _warnOnce2.default)('Root#remove is deprecated. Use Root#removeChild');\n          this.removeChild(child);\n        };\n\n        Root.prototype.prevMap = function prevMap() {\n          (0, _warnOnce2.default)('Root#prevMap is deprecated. Use Root#source.input.map');\n          return this.source.input.map;\n        };\n        /**\n         * @memberof Root#\n         * @member {object} raws - Information to generate byte-to-byte equal\n         *                         node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `after`: the space symbols after the last child to the end of file.\n         * * `semicolon`: is the last child has an (optional) semicolon.\n         *\n         * @example\n         * postcss.parse('a {}\\n').raws //=> { after: '\\n' }\n         * postcss.parse('a {}').raws   //=> { after: '' }\n         */\n\n\n        return Root;\n      }(_container2.default);\n\n      exports.default = Root;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 28 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var escape = __webpack_require__(29);\n\n      var DELIMITER_MAP = {\n        \"---\": \"yaml\",\n        \"+++\": \"toml\"\n      };\n\n      function parse(text) {\n        var delimiterRegex = Object.keys(DELIMITER_MAP).map(escape).join(\"|\");\n        var match = text.match( // trailing spaces after delimiters are allowed\n        new RegExp(\"^(\".concat(delimiterRegex, \")[^\\\\n\\\\S]*\\\\n(?:([\\\\s\\\\S]*?)\\\\n)?\\\\1[^\\\\n\\\\S]*(\\\\n|$)\")));\n\n        if (match === null) {\n          return {\n            frontMatter: null,\n            content: text\n          };\n        }\n\n        var raw = match[0].replace(/\\n$/, \"\");\n        var delimiter = match[1];\n        var value = match[2];\n        return {\n          frontMatter: {\n            type: DELIMITER_MAP[delimiter],\n            value: value,\n            raw: raw\n          },\n          content: match[0].replace(/[^\\n]/g, \" \") + text.slice(match[0].length)\n        };\n      }\n\n      module.exports = parse;\n      /***/\n    },\n    /* 29 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\n      module.exports = function (str) {\n        if (typeof str !== 'string') {\n          throw new TypeError('Expected a string');\n        }\n\n        return str.replace(matchOperatorsRe, '\\\\$&');\n      };\n      /***/\n\n    },\n    /* 30 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      module.exports =\n      /*#__PURE__*/\n      function (_Container) {\n        _inherits(Value, _Container);\n\n        function Value(opts) {\n          var _this;\n\n          _classCallCheck(this, Value);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Value).call(this, opts));\n          _this.type = 'value';\n          _this.unbalanced = 0;\n          return _this;\n        }\n\n        return Value;\n      }(Container);\n      /***/\n\n    },\n    /* 31 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var AtWord =\n      /*#__PURE__*/\n      function (_Container) {\n        _inherits(AtWord, _Container);\n\n        function AtWord(opts) {\n          var _this;\n\n          _classCallCheck(this, AtWord);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(AtWord).call(this, opts));\n          _this.type = 'atword';\n          return _this;\n        }\n\n        _createClass(AtWord, [{\n          key: \"toString\",\n          value: function toString() {\n            var quote = this.quoted ? this.raws.quote : '';\n            return [this.raws.before, '@', // we can't use String() here because it'll try using itself\n            // as the constructor\n            String.prototype.toString.call(this.value), this.raws.after].join('');\n          }\n        }]);\n\n        return AtWord;\n      }(Container);\n\n      Container.registerWalker(AtWord);\n      module.exports = AtWord;\n      /***/\n    },\n    /* 32 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Colon =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Colon, _Node);\n\n        function Colon(opts) {\n          var _this;\n\n          _classCallCheck(this, Colon);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Colon).call(this, opts));\n          _this.type = 'colon';\n          return _this;\n        }\n\n        return Colon;\n      }(Node);\n\n      Container.registerWalker(Colon);\n      module.exports = Colon;\n      /***/\n    },\n    /* 33 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Comma =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Comma, _Node);\n\n        function Comma(opts) {\n          var _this;\n\n          _classCallCheck(this, Comma);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Comma).call(this, opts));\n          _this.type = 'comma';\n          return _this;\n        }\n\n        return Comma;\n      }(Node);\n\n      Container.registerWalker(Comma);\n      module.exports = Comma;\n      /***/\n    },\n    /* 34 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Comment =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Comment, _Node);\n\n        function Comment(opts) {\n          var _this;\n\n          _classCallCheck(this, Comment);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Comment).call(this, opts));\n          _this.type = 'comment';\n          _this.inline = opts.inline || false;\n          return _this;\n        }\n\n        _createClass(Comment, [{\n          key: \"toString\",\n          value: function toString() {\n            return [this.raws.before, this.inline ? '//' : '/*', String(this.value), this.inline ? '' : '*/', this.raws.after].join('');\n          }\n        }]);\n\n        return Comment;\n      }(Node);\n\n      ;\n      Container.registerWalker(Comment);\n      module.exports = Comment;\n      /***/\n    },\n    /* 35 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var FunctionNode =\n      /*#__PURE__*/\n      function (_Container) {\n        _inherits(FunctionNode, _Container);\n\n        function FunctionNode(opts) {\n          var _this;\n\n          _classCallCheck(this, FunctionNode);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(FunctionNode).call(this, opts));\n          _this.type = 'func'; // start off at -1 so we know there haven't been any parens added\n\n          _this.unbalanced = -1;\n          return _this;\n        }\n\n        return FunctionNode;\n      }(Container);\n\n      ;\n      Container.registerWalker(FunctionNode);\n      module.exports = FunctionNode;\n      /***/\n    },\n    /* 36 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var NumberNode =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(NumberNode, _Node);\n\n        function NumberNode(opts) {\n          var _this;\n\n          _classCallCheck(this, NumberNode);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(NumberNode).call(this, opts));\n          _this.type = 'number';\n          _this.unit = opts.unit || '';\n          return _this;\n        }\n\n        _createClass(NumberNode, [{\n          key: \"toString\",\n          value: function toString() {\n            return [this.raws.before, String(this.value), this.unit, this.raws.after].join('');\n          }\n        }]);\n\n        return NumberNode;\n      }(Node);\n\n      ;\n      Container.registerWalker(NumberNode);\n      module.exports = NumberNode;\n      /***/\n    },\n    /* 37 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Operator =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Operator, _Node);\n\n        function Operator(opts) {\n          var _this;\n\n          _classCallCheck(this, Operator);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Operator).call(this, opts));\n          _this.type = 'operator';\n          return _this;\n        }\n\n        return Operator;\n      }(Node);\n\n      Container.registerWalker(Operator);\n      module.exports = Operator;\n      /***/\n    },\n    /* 38 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Parenthesis =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Parenthesis, _Node);\n\n        function Parenthesis(opts) {\n          var _this;\n\n          _classCallCheck(this, Parenthesis);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Parenthesis).call(this, opts));\n          _this.type = 'paren';\n          _this.parenType = '';\n          return _this;\n        }\n\n        return Parenthesis;\n      }(Node);\n\n      Container.registerWalker(Parenthesis);\n      module.exports = Parenthesis;\n      /***/\n    },\n    /* 39 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var StringNode =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(StringNode, _Node);\n\n        function StringNode(opts) {\n          var _this;\n\n          _classCallCheck(this, StringNode);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(StringNode).call(this, opts));\n          _this.type = 'string';\n          return _this;\n        }\n\n        _createClass(StringNode, [{\n          key: \"toString\",\n          value: function toString() {\n            var quote = this.quoted ? this.raws.quote : '';\n            return [this.raws.before, quote, // we can't use String() here because it'll try using itself\n            // as the constructor\n            this.value + '', quote, this.raws.after].join('');\n          }\n        }]);\n\n        return StringNode;\n      }(Node);\n\n      Container.registerWalker(StringNode);\n      module.exports = StringNode;\n      /***/\n    },\n    /* 40 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var Word =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(Word, _Node);\n\n        function Word(opts) {\n          var _this;\n\n          _classCallCheck(this, Word);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Word).call(this, opts));\n          _this.type = 'word';\n          return _this;\n        }\n\n        return Word;\n      }(Node);\n\n      Container.registerWalker(Word);\n      module.exports = Word;\n      /***/\n    },\n    /* 41 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      var Node = __webpack_require__(3);\n\n      var UnicodeRange =\n      /*#__PURE__*/\n      function (_Node) {\n        _inherits(UnicodeRange, _Node);\n\n        function UnicodeRange(opts) {\n          var _this;\n\n          _classCallCheck(this, UnicodeRange);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(UnicodeRange).call(this, opts));\n          _this.type = 'unicode-range';\n          return _this;\n        }\n\n        return UnicodeRange;\n      }(Node);\n\n      Container.registerWalker(UnicodeRange);\n      module.exports = UnicodeRange;\n      /***/\n    },\n    /* 42 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function flatten(list, depth) {\n        depth = typeof depth == 'number' ? depth : Infinity;\n\n        if (!depth) {\n          if (Array.isArray(list)) {\n            return list.map(function (i) {\n              return i;\n            });\n          }\n\n          return list;\n        }\n\n        return _flatten(list, 1);\n\n        function _flatten(list, d) {\n          return list.reduce(function (acc, item) {\n            if (Array.isArray(item) && d < depth) {\n              return acc.concat(_flatten(item, d + 1));\n            } else {\n              return acc.concat(item);\n            }\n          }, []);\n        }\n      };\n      /***/\n\n    },\n    /* 43 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (ary, item) {\n        var i = -1,\n            indexes = [];\n\n        while ((i = ary.indexOf(item, i + 1)) !== -1) {\n          indexes.push(i);\n        }\n\n        return indexes;\n      };\n      /***/\n\n    },\n    /* 44 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function unique_pred(list, compare) {\n        var ptr = 1,\n            len = list.length,\n            a = list[0],\n            b = list[0];\n\n        for (var i = 1; i < len; ++i) {\n          b = a;\n          a = list[i];\n\n          if (compare(a, b)) {\n            if (i === ptr) {\n              ptr++;\n              continue;\n            }\n\n            list[ptr++] = a;\n          }\n        }\n\n        list.length = ptr;\n        return list;\n      }\n\n      function unique_eq(list) {\n        var ptr = 1,\n            len = list.length,\n            a = list[0],\n            b = list[0];\n\n        for (var i = 1; i < len; ++i, b = a) {\n          b = a;\n          a = list[i];\n\n          if (a !== b) {\n            if (i === ptr) {\n              ptr++;\n              continue;\n            }\n\n            list[ptr++] = a;\n          }\n        }\n\n        list.length = ptr;\n        return list;\n      }\n\n      function unique(list, compare, sorted) {\n        if (list.length === 0) {\n          return list;\n        }\n\n        if (compare) {\n          if (!sorted) {\n            list.sort(compare);\n          }\n\n          return unique_pred(list, compare);\n        }\n\n        if (!sorted) {\n          list.sort();\n        }\n\n        return unique_eq(list);\n      }\n\n      module.exports = unique;\n      /***/\n    },\n    /* 45 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _container = __webpack_require__(16);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Root = function (_Container) {\n        _inherits(Root, _Container);\n\n        function Root(opts) {\n          _classCallCheck(this, Root);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, opts));\n\n          _this.type = _types.ROOT;\n          return _this;\n        }\n\n        Root.prototype.toString = function toString() {\n          var str = this.reduce(function (memo, selector) {\n            var sel = String(selector);\n            return sel ? memo + sel + ',' : '';\n          }, '').slice(0, -1);\n          return this.trailingComma ? str + ',' : str;\n        };\n\n        return Root;\n      }(_container2.default);\n\n      exports.default = Root;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 46 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _container = __webpack_require__(16);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Selector = function (_Container) {\n        _inherits(Selector, _Container);\n\n        function Selector(opts) {\n          _classCallCheck(this, Selector);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, opts));\n\n          _this.type = _types.SELECTOR;\n          return _this;\n        }\n\n        return Selector;\n      }(_container2.default);\n\n      exports.default = Selector;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 47 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _namespace = __webpack_require__(7);\n\n      var _namespace2 = _interopRequireDefault(_namespace);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var ClassName = function (_Namespace) {\n        _inherits(ClassName, _Namespace);\n\n        function ClassName(opts) {\n          _classCallCheck(this, ClassName);\n\n          var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));\n\n          _this.type = _types.CLASS;\n          return _this;\n        }\n\n        ClassName.prototype.toString = function toString() {\n          return [this.spaces.before, this.ns, String('.' + this.value), this.spaces.after].join('');\n        };\n\n        return ClassName;\n      }(_namespace2.default);\n\n      exports.default = ClassName;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 48 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Comment = function (_Node) {\n        _inherits(Comment, _Node);\n\n        function Comment(opts) {\n          _classCallCheck(this, Comment);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, opts));\n\n          _this.type = _types.COMMENT;\n          return _this;\n        }\n\n        return Comment;\n      }(_node2.default);\n\n      exports.default = Comment;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 49 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _namespace = __webpack_require__(7);\n\n      var _namespace2 = _interopRequireDefault(_namespace);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var ID = function (_Namespace) {\n        _inherits(ID, _Namespace);\n\n        function ID(opts) {\n          _classCallCheck(this, ID);\n\n          var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));\n\n          _this.type = _types.ID;\n          return _this;\n        }\n\n        ID.prototype.toString = function toString() {\n          return [this.spaces.before, this.ns, String('#' + this.value), this.spaces.after].join('');\n        };\n\n        return ID;\n      }(_namespace2.default);\n\n      exports.default = ID;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 50 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _namespace = __webpack_require__(7);\n\n      var _namespace2 = _interopRequireDefault(_namespace);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Tag = function (_Namespace) {\n        _inherits(Tag, _Namespace);\n\n        function Tag(opts) {\n          _classCallCheck(this, Tag);\n\n          var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));\n\n          _this.type = _types.TAG;\n          return _this;\n        }\n\n        return Tag;\n      }(_namespace2.default);\n\n      exports.default = Tag;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 51 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var String = function (_Node) {\n        _inherits(String, _Node);\n\n        function String(opts) {\n          _classCallCheck(this, String);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, opts));\n\n          _this.type = _types.STRING;\n          return _this;\n        }\n\n        return String;\n      }(_node2.default);\n\n      exports.default = String;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 52 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _container = __webpack_require__(16);\n\n      var _container2 = _interopRequireDefault(_container);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Pseudo = function (_Container) {\n        _inherits(Pseudo, _Container);\n\n        function Pseudo(opts) {\n          _classCallCheck(this, Pseudo);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, opts));\n\n          _this.type = _types.PSEUDO;\n          return _this;\n        }\n\n        Pseudo.prototype.toString = function toString() {\n          var params = this.length ? '(' + this.map(String).join(',') + ')' : '';\n          return [this.spaces.before, String(this.value), params, this.spaces.after].join('');\n        };\n\n        return Pseudo;\n      }(_container2.default);\n\n      exports.default = Pseudo;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 53 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _namespace = __webpack_require__(7);\n\n      var _namespace2 = _interopRequireDefault(_namespace);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Attribute = function (_Namespace) {\n        _inherits(Attribute, _Namespace);\n\n        function Attribute(opts) {\n          _classCallCheck(this, Attribute);\n\n          var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));\n\n          _this.type = _types.ATTRIBUTE;\n          _this.raws = {};\n          return _this;\n        }\n\n        Attribute.prototype.toString = function toString() {\n          var selector = [this.spaces.before, '[', this.ns, this.attribute];\n\n          if (this.operator) {\n            selector.push(this.operator);\n          }\n\n          if (this.value) {\n            selector.push(this.value);\n          }\n\n          if (this.raws.insensitive) {\n            selector.push(this.raws.insensitive);\n          } else if (this.insensitive) {\n            selector.push(' i');\n          }\n\n          selector.push(']');\n          return selector.concat(this.spaces.after).join('');\n        };\n\n        return Attribute;\n      }(_namespace2.default);\n\n      exports.default = Attribute;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 54 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _namespace = __webpack_require__(7);\n\n      var _namespace2 = _interopRequireDefault(_namespace);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Universal = function (_Namespace) {\n        _inherits(Universal, _Namespace);\n\n        function Universal(opts) {\n          _classCallCheck(this, Universal);\n\n          var _this = _possibleConstructorReturn(this, _Namespace.call(this, opts));\n\n          _this.type = _types.UNIVERSAL;\n          _this.value = '*';\n          return _this;\n        }\n\n        return Universal;\n      }(_namespace2.default);\n\n      exports.default = Universal;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 55 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Combinator = function (_Node) {\n        _inherits(Combinator, _Node);\n\n        function Combinator(opts) {\n          _classCallCheck(this, Combinator);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, opts));\n\n          _this.type = _types.COMBINATOR;\n          return _this;\n        }\n\n        return Combinator;\n      }(_node2.default);\n\n      exports.default = Combinator;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 56 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _node = __webpack_require__(5);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      var _types = __webpack_require__(0);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Nesting = function (_Node) {\n        _inherits(Nesting, _Node);\n\n        function Nesting(opts) {\n          _classCallCheck(this, Nesting);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, opts));\n\n          _this.type = _types.NESTING;\n          _this.value = '&';\n          return _this;\n        }\n\n        return Nesting;\n      }(_node2.default);\n\n      exports.default = Nesting;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 57 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _Node = __webpack_require__(58);\n\n      var _Node2 = _interopRequireDefault(_Node);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function Container(opts) {\n        var _this = this;\n\n        this.constructor(opts);\n        this.nodes = opts.nodes;\n\n        if (this.after === undefined) {\n          this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : '';\n        }\n\n        if (this.before === undefined) {\n          this.before = this.nodes.length > 0 ? this.nodes[0].before : '';\n        }\n\n        if (this.sourceIndex === undefined) {\n          this.sourceIndex = this.before.length;\n        }\n\n        this.nodes.forEach(function (node) {\n          node.parent = _this; // eslint-disable-line no-param-reassign\n        });\n      }\n      /**\r\n       * A node that contains other nodes and support traversing over them\r\n       */\n\n\n      Container.prototype = Object.create(_Node2.default.prototype);\n      Container.constructor = _Node2.default;\n      /**\r\n       * Iterate over descendant nodes of the node\r\n       *\r\n       * @param {RegExp|string} filter - Optional. Only nodes with node.type that\r\n       *    satisfies the filter will be traversed over\r\n       * @param {function} cb - callback to call on each node. Takes theese params:\r\n       *    node - the node being processed, i - it's index, nodes - the array\r\n       *    of all nodes\r\n       *    If false is returned, the iteration breaks\r\n       *\r\n       * @return (boolean) false, if the iteration was broken\r\n       */\n\n      Container.prototype.walk = function walk(filter, cb) {\n        var hasFilter = typeof filter === 'string' || filter instanceof RegExp;\n        var callback = hasFilter ? cb : filter;\n        var filterReg = typeof filter === 'string' ? new RegExp(filter) : filter;\n\n        for (var i = 0; i < this.nodes.length; i++) {\n          var node = this.nodes[i];\n          var filtered = hasFilter ? filterReg.test(node.type) : true;\n\n          if (filtered && callback && callback(node, i, this.nodes) === false) {\n            return false;\n          }\n\n          if (node.nodes && node.walk(filter, cb) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n      /**\r\n       * Iterate over immediate children of the node\r\n       *\r\n       * @param {function} cb - callback to call on each node. Takes theese params:\r\n       *    node - the node being processed, i - it's index, nodes - the array\r\n       *    of all nodes\r\n       *    If false is returned, the iteration breaks\r\n       *\r\n       * @return (boolean) false, if the iteration was broken\r\n       */\n\n\n      Container.prototype.each = function each() {\n        var cb = arguments.length <= 0 || arguments[0] === undefined ? function () {} : arguments[0];\n\n        for (var i = 0; i < this.nodes.length; i++) {\n          var node = this.nodes[i];\n\n          if (cb(node, i, this.nodes) === false) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      exports.default = Container;\n      /***/\n    },\n    /* 58 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      /**\r\n       * A very generic node. Pretty much any element of a media query\r\n       */\n\n      function Node(opts) {\n        this.after = opts.after;\n        this.before = opts.before;\n        this.type = opts.type;\n        this.value = opts.value;\n        this.sourceIndex = opts.sourceIndex;\n      }\n\n      exports.default = Node;\n      /***/\n    },\n    /* 59 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _cssSyntaxError = _interopRequireDefault(__webpack_require__(60));\n\n      var _previousMap = _interopRequireDefault(__webpack_require__(120));\n\n      var _path = _interopRequireDefault(__webpack_require__(6));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      var sequence = 0;\n      /**\n       * Represents the source CSS.\n       *\n       * @example\n       * const root  = postcss.parse(css, { from: file })\n       * const input = root.source.input\n       */\n\n      var Input =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {string} css    Input CSS source.\n         * @param {object} [opts] {@link Processor#process} options.\n         */\n        function Input(css, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          if (css === null || _typeof(css) === 'object' && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n          }\n          /**\n           * Input CSS source\n           *\n           * @type {string}\n           *\n           * @example\n           * const input = postcss.parse('a{}', { from: file }).input\n           * input.css //=> \"a{}\"\n           */\n\n\n          this.css = css.toString();\n\n          if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\\uFFFE\") {\n            this.css = this.css.slice(1);\n          }\n\n          if (opts.from) {\n            if (/^\\w+:\\/\\//.test(opts.from)) {\n              /**\n               * The absolute path to the CSS source file defined\n               * with the `from` option.\n               *\n               * @type {string}\n               *\n               * @example\n               * const root = postcss.parse(css, { from: 'a.css' })\n               * root.source.input.file //=> '/home/ai/a.css'\n               */\n              this.file = opts.from;\n            } else {\n              this.file = _path.default.resolve(opts.from);\n            }\n          }\n\n          var map = new _previousMap.default(this.css, opts);\n\n          if (map.text) {\n            /**\n             * The input source map passed from a compilation step before PostCSS\n             * (for example, from Sass compiler).\n             *\n             * @type {PreviousMap}\n             *\n             * @example\n             * root.source.input.map.consumer().sources //=> ['a.sass']\n             */\n            this.map = map;\n            var file = map.consumer().file;\n            if (!this.file && file) this.file = this.mapResolve(file);\n          }\n\n          if (!this.file) {\n            sequence += 1;\n            /**\n             * The unique ID of the CSS source. It will be created if `from` option\n             * is not provided (because PostCSS does not know the file path).\n             *\n             * @type {string}\n             *\n             * @example\n             * const root = postcss.parse(css)\n             * root.source.input.file //=> undefined\n             * root.source.input.id   //=> \"<input css 1>\"\n             */\n\n            this.id = '<input css ' + sequence + '>';\n          }\n\n          if (this.map) this.map.file = this.from;\n        }\n\n        var _proto = Input.prototype;\n\n        _proto.error = function error(message, line, column, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          var result;\n          var origin = this.origin(line, column);\n\n          if (origin) {\n            result = new _cssSyntaxError.default(message, origin.line, origin.column, origin.source, origin.file, opts.plugin);\n          } else {\n            result = new _cssSyntaxError.default(message, line, column, this.css, this.file, opts.plugin);\n          }\n\n          result.input = {\n            line: line,\n            column: column,\n            source: this.css\n          };\n          if (this.file) result.input.file = this.file;\n          return result;\n        };\n        /**\n         * Reads the input source map and returns a symbol position\n         * in the input source (e.g., in a Sass file that was compiled\n         * to CSS before being passed to PostCSS).\n         *\n         * @param {number} line   Line in input CSS.\n         * @param {number} column Column in input CSS.\n         *\n         * @return {filePosition} Position in input source.\n         *\n         * @example\n         * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }\n         */\n\n\n        _proto.origin = function origin(line, column) {\n          if (!this.map) return false;\n          var consumer = this.map.consumer();\n          var from = consumer.originalPositionFor({\n            line: line,\n            column: column\n          });\n          if (!from.source) return false;\n          var result = {\n            file: this.mapResolve(from.source),\n            line: from.line,\n            column: from.column\n          };\n          var source = consumer.sourceContentFor(from.source);\n          if (source) result.source = source;\n          return result;\n        };\n\n        _proto.mapResolve = function mapResolve(file) {\n          if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n          }\n\n          return _path.default.resolve(this.map.consumer().sourceRoot || '.', file);\n        };\n        /**\n         * The CSS source identifier. Contains {@link Input#file} if the user\n         * set the `from` option, or {@link Input#id} if they did not.\n         *\n         * @type {string}\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.css' })\n         * root.source.input.from //=> \"/home/ai/a.css\"\n         *\n         * const root = postcss.parse(css)\n         * root.source.input.from //=> \"<input css 1>\"\n         */\n\n\n        _createClass(Input, [{\n          key: \"from\",\n          get: function get() {\n            return this.file || this.id;\n          }\n        }]);\n\n        return Input;\n      }();\n\n      var _default = Input;\n      /**\n       * @typedef  {object} filePosition\n       * @property {string} file   Path to file.\n       * @property {number} line   Source line in file.\n       * @property {number} column Source column in file.\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 60 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _supportsColor = _interopRequireDefault(__webpack_require__(117));\n\n      var _chalk = _interopRequireDefault(__webpack_require__(118));\n\n      var _terminalHighlight = _interopRequireDefault(__webpack_require__(119));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      /**\n       * The CSS parser throws this error for broken CSS.\n       *\n       * Custom parsers can throw this error for broken custom syntax using\n       * the {@link Node#error} method.\n       *\n       * PostCSS will use the input source map to detect the original error location.\n       * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n       * PostCSS will show the original position in the Sass file.\n       *\n       * If you need the position in the PostCSS input\n       * (e.g., to debug the previous compiler), use `error.input.file`.\n       *\n       * @example\n       * // Catching and checking syntax error\n       * try {\n       *   postcss.parse('a{')\n       * } catch (error) {\n       *   if (error.name === 'CssSyntaxError') {\n       *     error //=> CssSyntaxError\n       *   }\n       * }\n       *\n       * @example\n       * // Raising error from plugin\n       * throw node.error('Unknown variable', { plugin: 'postcss-vars' })\n       */\n\n\n      var CssSyntaxError =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {string} message  Error message.\n         * @param {number} [line]   Source line of the error.\n         * @param {number} [column] Source column of the error.\n         * @param {string} [source] Source code of the broken file.\n         * @param {string} [file]   Absolute path to the broken file.\n         * @param {string} [plugin] PostCSS plugin name, if error came from plugin.\n         */\n        function CssSyntaxError(message, line, column, source, file, plugin) {\n          /**\n           * Always equal to `'CssSyntaxError'`. You should always check error type\n           * by `error.name === 'CssSyntaxError'`\n           * instead of `error instanceof CssSyntaxError`,\n           * because npm could have several PostCSS versions.\n           *\n           * @type {string}\n           *\n           * @example\n           * if (error.name === 'CssSyntaxError') {\n           *   error //=> CssSyntaxError\n           * }\n           */\n          this.name = 'CssSyntaxError';\n          /**\n           * Error message.\n           *\n           * @type {string}\n           *\n           * @example\n           * error.message //=> 'Unclosed block'\n           */\n\n          this.reason = message;\n\n          if (file) {\n            /**\n             * Absolute path to the broken file.\n             *\n             * @type {string}\n             *\n             * @example\n             * error.file       //=> 'a.sass'\n             * error.input.file //=> 'a.css'\n             */\n            this.file = file;\n          }\n\n          if (source) {\n            /**\n             * Source code of the broken file.\n             *\n             * @type {string}\n             *\n             * @example\n             * error.source       //=> 'a { b {} }'\n             * error.input.column //=> 'a b { }'\n             */\n            this.source = source;\n          }\n\n          if (plugin) {\n            /**\n             * Plugin name, if error came from plugin.\n             *\n             * @type {string}\n             *\n             * @example\n             * error.plugin //=> 'postcss-vars'\n             */\n            this.plugin = plugin;\n          }\n\n          if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n            /**\n             * Source line of the error.\n             *\n             * @type {number}\n             *\n             * @example\n             * error.line       //=> 2\n             * error.input.line //=> 4\n             */\n            this.line = line;\n            /**\n             * Source column of the error.\n             *\n             * @type {number}\n             *\n             * @example\n             * error.column       //=> 1\n             * error.input.column //=> 4\n             */\n\n            this.column = column;\n          }\n\n          this.setMessage();\n\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CssSyntaxError);\n          }\n        }\n\n        var _proto = CssSyntaxError.prototype;\n\n        _proto.setMessage = function setMessage() {\n          /**\n           * Full error text in the GNU error format\n           * with plugin, file, line and column.\n           *\n           * @type {string}\n           *\n           * @example\n           * error.message //=> 'a.css:1:1: Unclosed block'\n           */\n          this.message = this.plugin ? this.plugin + ': ' : '';\n          this.message += this.file ? this.file : '<css input>';\n\n          if (typeof this.line !== 'undefined') {\n            this.message += ':' + this.line + ':' + this.column;\n          }\n\n          this.message += ': ' + this.reason;\n        };\n        /**\n         * Returns a few lines of CSS source that caused the error.\n         *\n         * If the CSS has an input source map without `sourceContent`,\n         * this method will return an empty string.\n         *\n         * @param {boolean} [color] Whether arrow will be colored red by terminal\n         *                          color codes. By default, PostCSS will detect\n         *                          color support by `process.stdout.isTTY`\n         *                          and `process.env.NODE_DISABLE_COLORS`.\n         *\n         * @example\n         * error.showSourceCode() //=> \"  4 | }\n         *                        //      5 | a {\n         *                        //    > 6 |   bad\n         *                        //        |   ^\n         *                        //      7 | }\n         *                        //      8 | b {\"\n         *\n         * @return {string} Few lines of CSS source that caused the error.\n         */\n\n\n        _proto.showSourceCode = function showSourceCode(color) {\n          var _this = this;\n\n          if (!this.source) return '';\n          var css = this.source;\n\n          if (_terminalHighlight.default) {\n            if (typeof color === 'undefined') color = _supportsColor.default.stdout;\n            if (color) css = (0, _terminalHighlight.default)(css);\n          }\n\n          var lines = css.split(/\\r?\\n/);\n          var start = Math.max(this.line - 3, 0);\n          var end = Math.min(this.line + 2, lines.length);\n          var maxWidth = String(end).length;\n\n          function mark(text) {\n            if (color && _chalk.default.red) {\n              return _chalk.default.red.bold(text);\n            }\n\n            return text;\n          }\n\n          function aside(text) {\n            if (color && _chalk.default.gray) {\n              return _chalk.default.gray(text);\n            }\n\n            return text;\n          }\n\n          return lines.slice(start, end).map(function (line, index) {\n            var number = start + 1 + index;\n            var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n\n            if (number === _this.line) {\n              var spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, ' ');\n              return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^');\n            }\n\n            return ' ' + aside(gutter) + line;\n          }).join('\\n');\n        };\n        /**\n         * Returns error position, message and source code of the broken part.\n         *\n         * @example\n         * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n         *                  //    > 1 | a {\n         *                  //        | ^\"\n         *\n         * @return {string} Error position, message and source code.\n         */\n\n\n        _proto.toString = function toString() {\n          var code = this.showSourceCode();\n\n          if (code) {\n            code = '\\n\\n' + code + '\\n';\n          }\n\n          return this.name + ': ' + this.message + code;\n        };\n        /**\n         * @memberof CssSyntaxError#\n         * @member {Input} input Input object with PostCSS internal information\n         *                       about input file. If input has source map\n         *                       from previous tool, PostCSS will use origin\n         *                       (for example, Sass) source. You can use this\n         *                       object to get PostCSS input source.\n         *\n         * @example\n         * error.input.file //=> 'a.css'\n         * error.file       //=> 'a.sass'\n         */\n\n\n        return CssSyntaxError;\n      }();\n\n      var _default = CssSyntaxError;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 61 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /*\n       * Copyright 2009-2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE.txt or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.SourceMapGenerator = __webpack_require__(62).SourceMapGenerator;\n      exports.SourceMapConsumer = __webpack_require__(126).SourceMapConsumer;\n      exports.SourceNode = __webpack_require__(129).SourceNode;\n      /***/\n    },\n    /* 62 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var base64VLQ = __webpack_require__(63);\n\n      var util = __webpack_require__(8);\n\n      var ArraySet = __webpack_require__(64).ArraySet;\n\n      var MappingList = __webpack_require__(125).MappingList;\n      /**\n       * An instance of the SourceMapGenerator represents a source map which is\n       * being built incrementally. You may pass an object with the following\n       * properties:\n       *\n       *   - file: The filename of the generated source.\n       *   - sourceRoot: A root for all relative URLs in this source map.\n       */\n\n\n      function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n          aArgs = {};\n        }\n\n        this._file = util.getArg(aArgs, 'file', null);\n        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        this._mappings = new MappingList();\n        this._sourcesContents = null;\n      }\n\n      SourceMapGenerator.prototype._version = 3;\n      /**\n       * Creates a new SourceMapGenerator based on a SourceMapConsumer\n       *\n       * @param aSourceMapConsumer The SourceMap.\n       */\n\n      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n          file: aSourceMapConsumer.file,\n          sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          var newMapping = {\n            generated: {\n              line: mapping.generatedLine,\n              column: mapping.generatedColumn\n            }\n          };\n\n          if (mapping.source != null) {\n            newMapping.source = mapping.source;\n\n            if (sourceRoot != null) {\n              newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n\n            newMapping.original = {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            };\n\n            if (mapping.name != null) {\n              newMapping.name = mapping.name;\n            }\n          }\n\n          generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var sourceRelative = sourceFile;\n\n          if (sourceRoot !== null) {\n            sourceRelative = util.relative(sourceRoot, sourceFile);\n          }\n\n          if (!generator._sources.has(sourceRelative)) {\n            generator._sources.add(sourceRelative);\n          }\n\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n          }\n        });\n        return generator;\n      };\n      /**\n       * Add a single mapping from original source line and column to the generated\n       * source's line and column for this source map being created. The mapping\n       * object should have the following properties:\n       *\n       *   - generated: An object with the generated line and column positions.\n       *   - original: An object with the original line and column positions.\n       *   - source: The original source file (relative to the sourceRoot).\n       *   - name: An optional original token name for this mapping.\n       */\n\n\n      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n\n        if (!this._skipValidation) {\n          this._validateMapping(generated, original, source, name);\n        }\n\n        if (source != null) {\n          source = String(source);\n\n          if (!this._sources.has(source)) {\n            this._sources.add(source);\n          }\n        }\n\n        if (name != null) {\n          name = String(name);\n\n          if (!this._names.has(name)) {\n            this._names.add(name);\n          }\n        }\n\n        this._mappings.add({\n          generatedLine: generated.line,\n          generatedColumn: generated.column,\n          originalLine: original != null && original.line,\n          originalColumn: original != null && original.column,\n          source: source,\n          name: name\n        });\n      };\n      /**\n       * Set the source content for a source file.\n       */\n\n\n      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n\n        if (this._sourceRoot != null) {\n          source = util.relative(this._sourceRoot, source);\n        }\n\n        if (aSourceContent != null) {\n          // Add the source content to the _sourcesContents map.\n          // Create a new _sourcesContents map if the property is null.\n          if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n          }\n\n          this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n          // Remove the source file from the _sourcesContents map.\n          // If the _sourcesContents map is empty, set the property to null.\n          delete this._sourcesContents[util.toSetString(source)];\n\n          if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n          }\n        }\n      };\n      /**\n       * Applies the mappings of a sub-source-map for a specific source file to the\n       * source map being generated. Each mapping to the supplied source file is\n       * rewritten using the supplied source map. Note: The resolution for the\n       * resulting mappings is the minimium of this map and the supplied map.\n       *\n       * @param aSourceMapConsumer The source map to be applied.\n       * @param aSourceFile Optional. The filename of the source file.\n       *        If omitted, SourceMapConsumer's file property will be used.\n       * @param aSourceMapPath Optional. The dirname of the path to the source map\n       *        to be applied. If relative, it is relative to the SourceMapConsumer.\n       *        This parameter is needed when the two source maps aren't in the same\n       *        directory, and the source map to be applied contains relative source\n       *        paths. If so, those relative source paths need to be rewritten\n       *        relative to the SourceMapGenerator.\n       */\n\n\n      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap\n\n        if (aSourceFile == null) {\n          if (aSourceMapConsumer.file == null) {\n            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n          }\n\n          sourceFile = aSourceMapConsumer.file;\n        }\n\n        var sourceRoot = this._sourceRoot; // Make \"sourceFile\" relative if an absolute Url is passed.\n\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        } // Applying the SourceMap can add and remove items from the sources and\n        // the names array.\n\n\n        var newSources = new ArraySet();\n        var newNames = new ArraySet(); // Find mappings for the \"sourceFile\"\n\n        this._mappings.unsortedForEach(function (mapping) {\n          if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            });\n\n            if (original.source != null) {\n              // Copy mapping\n              mapping.source = original.source;\n\n              if (aSourceMapPath != null) {\n                mapping.source = util.join(aSourceMapPath, mapping.source);\n              }\n\n              if (sourceRoot != null) {\n                mapping.source = util.relative(sourceRoot, mapping.source);\n              }\n\n              mapping.originalLine = original.line;\n              mapping.originalColumn = original.column;\n\n              if (original.name != null) {\n                mapping.name = original.name;\n              }\n            }\n          }\n\n          var source = mapping.source;\n\n          if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n          }\n\n          var name = mapping.name;\n\n          if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n          }\n        }, this);\n\n        this._sources = newSources;\n        this._names = newNames; // Copy sourcesContents of applied map.\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aSourceMapPath != null) {\n              sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n\n            if (sourceRoot != null) {\n              sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n\n            this.setSourceContent(sourceFile, content);\n          }\n        }, this);\n      };\n      /**\n       * A mapping can have one of the three levels of data:\n       *\n       *   1. Just the generated position.\n       *   2. The Generated position, original position, and original source.\n       *   3. Generated and original position, original source, as well as a name\n       *      token.\n       *\n       * To maintain consistency, we validate that any new mapping being added falls\n       * in to one of these categories.\n       */\n\n\n      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n        // When aOriginal is truthy but has empty values for .line and .column,\n        // it is most likely a programmer error. In this case we throw a very\n        // specific error message to try to guide them the right way.\n        // For example: https://github.com/Polymer/polymer-bundler/pull/519\n        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n          throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');\n        }\n\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n          // Case 1.\n          return;\n        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n          // Cases 2 and 3.\n          return;\n        } else {\n          throw new Error('Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n          }));\n        }\n      };\n      /**\n       * Serialize the accumulated mappings in to the stream of base 64 VLQs\n       * specified by the source map format.\n       */\n\n\n      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n\n        var mappings = this._mappings.toArray();\n\n        for (var i = 0, len = mappings.length; i < len; i++) {\n          mapping = mappings[i];\n          next = '';\n\n          if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n\n            while (mapping.generatedLine !== previousGeneratedLine) {\n              next += ';';\n              previousGeneratedLine++;\n            }\n          } else {\n            if (i > 0) {\n              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                continue;\n              }\n\n              next += ',';\n            }\n          }\n\n          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n          previousGeneratedColumn = mapping.generatedColumn;\n\n          if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3\n\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n\n            if (mapping.name != null) {\n              nameIdx = this._names.indexOf(mapping.name);\n              next += base64VLQ.encode(nameIdx - previousName);\n              previousName = nameIdx;\n            }\n          }\n\n          result += next;\n        }\n\n        return result;\n      };\n\n      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n          if (!this._sourcesContents) {\n            return null;\n          }\n\n          if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n          }\n\n          var key = util.toSetString(source);\n          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n      };\n      /**\n       * Externalize the source map.\n       */\n\n\n      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n        var map = {\n          version: this._version,\n          sources: this._sources.toArray(),\n          names: this._names.toArray(),\n          mappings: this._serializeMappings()\n        };\n\n        if (this._file != null) {\n          map.file = this._file;\n        }\n\n        if (this._sourceRoot != null) {\n          map.sourceRoot = this._sourceRoot;\n        }\n\n        if (this._sourcesContents) {\n          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n\n        return map;\n      };\n      /**\n       * Render the source map being generated to a string.\n       */\n\n\n      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n        return JSON.stringify(this.toJSON());\n      };\n\n      exports.SourceMapGenerator = SourceMapGenerator;\n      /***/\n    },\n    /* 63 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       *\n       * Based on the Base 64 VLQ implementation in Closure Compiler:\n       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n       *\n       * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n       * Redistribution and use in source and binary forms, with or without\n       * modification, are permitted provided that the following conditions are\n       * met:\n       *\n       *  * Redistributions of source code must retain the above copyright\n       *    notice, this list of conditions and the following disclaimer.\n       *  * Redistributions in binary form must reproduce the above\n       *    copyright notice, this list of conditions and the following\n       *    disclaimer in the documentation and/or other materials provided\n       *    with the distribution.\n       *  * Neither the name of Google Inc. nor the names of its\n       *    contributors may be used to endorse or promote products derived\n       *    from this software without specific prior written permission.\n       *\n       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n       * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n      var base64 = __webpack_require__(124); // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n      // length quantities we use in the source map spec, the first bit is the sign,\n      // the next four bits are the actual value, and the 6th bit is the\n      // continuation bit. The continuation bit tells us whether there are more\n      // digits in this value following this digit.\n      //\n      //   Continuation\n      //   |    Sign\n      //   |    |\n      //   V    V\n      //   101011\n\n\n      var VLQ_BASE_SHIFT = 5; // binary: 100000\n\n      var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111\n\n      var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000\n\n      var VLQ_CONTINUATION_BIT = VLQ_BASE;\n      /**\n       * Converts from a two-complement value to a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n       */\n\n      function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n      }\n      /**\n       * Converts to a two-complement value from a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n       */\n\n\n      function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n      }\n      /**\n       * Returns the base 64 VLQ encoded value.\n       */\n\n\n      exports.encode = function base64VLQ_encode(aValue) {\n        var encoded = \"\";\n        var digit;\n        var vlq = toVLQSigned(aValue);\n\n        do {\n          digit = vlq & VLQ_BASE_MASK;\n          vlq >>>= VLQ_BASE_SHIFT;\n\n          if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n          }\n\n          encoded += base64.encode(digit);\n        } while (vlq > 0);\n\n        return encoded;\n      };\n      /**\n       * Decodes the next base 64 VLQ value from the given string and returns the\n       * value and the rest of the string via the out parameter.\n       */\n\n\n      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n\n        do {\n          if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n          }\n\n          digit = base64.decode(aStr.charCodeAt(aIndex++));\n\n          if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n          }\n\n          continuation = !!(digit & VLQ_CONTINUATION_BIT);\n          digit &= VLQ_BASE_MASK;\n          result = result + (digit << shift);\n          shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aIndex;\n      };\n      /***/\n\n    },\n    /* 64 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(8);\n\n      var has = Object.prototype.hasOwnProperty;\n      var hasNativeMap = typeof Map !== \"undefined\";\n      /**\n       * A data structure which is a combination of an array and a set. Adding a new\n       * member is O(1), testing for membership is O(1), and finding the index of an\n       * element is O(1). Removing elements from the set is not supported. Only\n       * strings are supported for membership.\n       */\n\n      function ArraySet() {\n        this._array = [];\n        this._set = hasNativeMap ? new Map() : Object.create(null);\n      }\n      /**\n       * Static method for creating ArraySet instances from an existing array.\n       */\n\n\n      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n\n        for (var i = 0, len = aArray.length; i < len; i++) {\n          set.add(aArray[i], aAllowDuplicates);\n        }\n\n        return set;\n      };\n      /**\n       * Return how many unique items are in this ArraySet. If duplicates have been\n       * added, than those do not count towards the size.\n       *\n       * @returns Number\n       */\n\n\n      ArraySet.prototype.size = function ArraySet_size() {\n        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n      };\n      /**\n       * Add the given string to this set.\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n        var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n        var idx = this._array.length;\n\n        if (!isDuplicate || aAllowDuplicates) {\n          this._array.push(aStr);\n        }\n\n        if (!isDuplicate) {\n          if (hasNativeMap) {\n            this._set.set(aStr, idx);\n          } else {\n            this._set[sStr] = idx;\n          }\n        }\n      };\n      /**\n       * Is the given string a member of this set?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.has = function ArraySet_has(aStr) {\n        if (hasNativeMap) {\n          return this._set.has(aStr);\n        } else {\n          var sStr = util.toSetString(aStr);\n          return has.call(this._set, sStr);\n        }\n      };\n      /**\n       * What is the index of the given string in the array?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        if (hasNativeMap) {\n          var idx = this._set.get(aStr);\n\n          if (idx >= 0) {\n            return idx;\n          }\n        } else {\n          var sStr = util.toSetString(aStr);\n\n          if (has.call(this._set, sStr)) {\n            return this._set[sStr];\n          }\n        }\n\n        throw new Error('\"' + aStr + '\" is not in the set.');\n      };\n      /**\n       * What is the element at the given index?\n       *\n       * @param Number aIdx\n       */\n\n\n      ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n          return this._array[aIdx];\n        }\n\n        throw new Error('No element indexed by ' + aIdx);\n      };\n      /**\n       * Returns the array representation of this set (which has the proper indices\n       * indicated by indexOf). Note that this is a copy of the internal array used\n       * for storing the members so that no one can mess with internal state.\n       */\n\n\n      ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n      };\n\n      exports.ArraySet = ArraySet;\n      /***/\n    },\n    /* 65 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _stringifier = _interopRequireDefault(__webpack_require__(17));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function stringify(node, builder) {\n        var str = new _stringifier.default(builder);\n        str.stringify(node);\n      }\n\n      var _default = stringify;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 66 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _declaration = _interopRequireDefault(__webpack_require__(67));\n\n      var _tokenize = _interopRequireDefault(__webpack_require__(132));\n\n      var _comment = _interopRequireDefault(__webpack_require__(19));\n\n      var _atRule = _interopRequireDefault(__webpack_require__(68));\n\n      var _root = _interopRequireDefault(__webpack_require__(134));\n\n      var _rule = _interopRequireDefault(__webpack_require__(70));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var Parser =\n      /*#__PURE__*/\n      function () {\n        function Parser(input) {\n          this.input = input;\n          this.root = new _root.default();\n          this.current = this.root;\n          this.spaces = '';\n          this.semicolon = false;\n          this.createTokenizer();\n          this.root.source = {\n            input: input,\n            start: {\n              line: 1,\n              column: 1\n            }\n          };\n        }\n\n        var _proto = Parser.prototype;\n\n        _proto.createTokenizer = function createTokenizer() {\n          this.tokenizer = (0, _tokenize.default)(this.input);\n        };\n\n        _proto.parse = function parse() {\n          var token;\n\n          while (!this.tokenizer.endOfFile()) {\n            token = this.tokenizer.nextToken();\n\n            switch (token[0]) {\n              case 'space':\n                this.spaces += token[1];\n                break;\n\n              case ';':\n                this.freeSemicolon(token);\n                break;\n\n              case '}':\n                this.end(token);\n                break;\n\n              case 'comment':\n                this.comment(token);\n                break;\n\n              case 'at-word':\n                this.atrule(token);\n                break;\n\n              case '{':\n                this.emptyRule(token);\n                break;\n\n              default:\n                this.other(token);\n                break;\n            }\n          }\n\n          this.endFile();\n        };\n\n        _proto.comment = function comment(token) {\n          var node = new _comment.default();\n          this.init(node, token[2], token[3]);\n          node.source.end = {\n            line: token[4],\n            column: token[5]\n          };\n          var text = token[1].slice(2, -2);\n\n          if (/^\\s*$/.test(text)) {\n            node.text = '';\n            node.raws.left = text;\n            node.raws.right = '';\n          } else {\n            var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text = match[2];\n            node.raws.left = match[1];\n            node.raws.right = match[3];\n          }\n        };\n\n        _proto.emptyRule = function emptyRule(token) {\n          var node = new _rule.default();\n          this.init(node, token[2], token[3]);\n          node.selector = '';\n          node.raws.between = '';\n          this.current = node;\n        };\n\n        _proto.other = function other(start) {\n          var end = false;\n          var type = null;\n          var colon = false;\n          var bracket = null;\n          var brackets = [];\n          var tokens = [];\n          var token = start;\n\n          while (token) {\n            type = token[0];\n            tokens.push(token);\n\n            if (type === '(' || type === '[') {\n              if (!bracket) bracket = token;\n              brackets.push(type === '(' ? ')' : ']');\n            } else if (brackets.length === 0) {\n              if (type === ';') {\n                if (colon) {\n                  this.decl(tokens);\n                  return;\n                } else {\n                  break;\n                }\n              } else if (type === '{') {\n                this.rule(tokens);\n                return;\n              } else if (type === '}') {\n                this.tokenizer.back(tokens.pop());\n                end = true;\n                break;\n              } else if (type === ':') {\n                colon = true;\n              }\n            } else if (type === brackets[brackets.length - 1]) {\n              brackets.pop();\n              if (brackets.length === 0) bracket = null;\n            }\n\n            token = this.tokenizer.nextToken();\n          }\n\n          if (this.tokenizer.endOfFile()) end = true;\n          if (brackets.length > 0) this.unclosedBracket(bracket);\n\n          if (end && colon) {\n            while (tokens.length) {\n              token = tokens[tokens.length - 1][0];\n              if (token !== 'space' && token !== 'comment') break;\n              this.tokenizer.back(tokens.pop());\n            }\n\n            this.decl(tokens);\n          } else {\n            this.unknownWord(tokens);\n          }\n        };\n\n        _proto.rule = function rule(tokens) {\n          tokens.pop();\n          var node = new _rule.default();\n          this.init(node, tokens[0][2], tokens[0][3]);\n          node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n          this.raw(node, 'selector', tokens);\n          this.current = node;\n        };\n\n        _proto.decl = function decl(tokens) {\n          var node = new _declaration.default();\n          this.init(node);\n          var last = tokens[tokens.length - 1];\n\n          if (last[0] === ';') {\n            this.semicolon = true;\n            tokens.pop();\n          }\n\n          if (last[4]) {\n            node.source.end = {\n              line: last[4],\n              column: last[5]\n            };\n          } else {\n            node.source.end = {\n              line: last[2],\n              column: last[3]\n            };\n          }\n\n          while (tokens[0][0] !== 'word') {\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node.raws.before += tokens.shift()[1];\n          }\n\n          node.source.start = {\n            line: tokens[0][2],\n            column: tokens[0][3]\n          };\n          node.prop = '';\n\n          while (tokens.length) {\n            var type = tokens[0][0];\n\n            if (type === ':' || type === 'space' || type === 'comment') {\n              break;\n            }\n\n            node.prop += tokens.shift()[1];\n          }\n\n          node.raws.between = '';\n          var token;\n\n          while (tokens.length) {\n            token = tokens.shift();\n\n            if (token[0] === ':') {\n              node.raws.between += token[1];\n              break;\n            } else {\n              node.raws.between += token[1];\n            }\n          }\n\n          if (node.prop[0] === '_' || node.prop[0] === '*') {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n          }\n\n          node.raws.between += this.spacesAndCommentsFromStart(tokens);\n          this.precheckMissedSemicolon(tokens);\n\n          for (var i = tokens.length - 1; i > 0; i--) {\n            token = tokens[i];\n\n            if (token[1].toLowerCase() === '!important') {\n              node.important = true;\n              var string = this.stringFrom(tokens, i);\n              string = this.spacesFromEnd(tokens) + string;\n              if (string !== ' !important') node.raws.important = string;\n              break;\n            } else if (token[1].toLowerCase() === 'important') {\n              var cache = tokens.slice(0);\n              var str = '';\n\n              for (var j = i; j > 0; j--) {\n                var _type = cache[j][0];\n\n                if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n                  break;\n                }\n\n                str = cache.pop()[1] + str;\n              }\n\n              if (str.trim().indexOf('!') === 0) {\n                node.important = true;\n                node.raws.important = str;\n                tokens = cache;\n              }\n            }\n\n            if (token[0] !== 'space' && token[0] !== 'comment') {\n              break;\n            }\n          }\n\n          this.raw(node, 'value', tokens);\n          if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n        };\n\n        _proto.atrule = function atrule(token) {\n          var node = new _atRule.default();\n          node.name = token[1].slice(1);\n\n          if (node.name === '') {\n            this.unnamedAtrule(node, token);\n          }\n\n          this.init(node, token[2], token[3]);\n          var prev;\n          var shift;\n          var last = false;\n          var open = false;\n          var params = [];\n\n          while (!this.tokenizer.endOfFile()) {\n            token = this.tokenizer.nextToken();\n\n            if (token[0] === ';') {\n              node.source.end = {\n                line: token[2],\n                column: token[3]\n              };\n              this.semicolon = true;\n              break;\n            } else if (token[0] === '{') {\n              open = true;\n              break;\n            } else if (token[0] === '}') {\n              if (params.length > 0) {\n                shift = params.length - 1;\n                prev = params[shift];\n\n                while (prev && prev[0] === 'space') {\n                  prev = params[--shift];\n                }\n\n                if (prev) {\n                  node.source.end = {\n                    line: prev[4],\n                    column: prev[5]\n                  };\n                }\n              }\n\n              this.end(token);\n              break;\n            } else {\n              params.push(token);\n            }\n\n            if (this.tokenizer.endOfFile()) {\n              last = true;\n              break;\n            }\n          }\n\n          node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n          if (params.length) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n\n            if (last) {\n              token = params[params.length - 1];\n              node.source.end = {\n                line: token[4],\n                column: token[5]\n              };\n              this.spaces = node.raws.between;\n              node.raws.between = '';\n            }\n          } else {\n            node.raws.afterName = '';\n            node.params = '';\n          }\n\n          if (open) {\n            node.nodes = [];\n            this.current = node;\n          }\n        };\n\n        _proto.end = function end(token) {\n          if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n          }\n\n          this.semicolon = false;\n          this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n          this.spaces = '';\n\n          if (this.current.parent) {\n            this.current.source.end = {\n              line: token[2],\n              column: token[3]\n            };\n            this.current = this.current.parent;\n          } else {\n            this.unexpectedClose(token);\n          }\n        };\n\n        _proto.endFile = function endFile() {\n          if (this.current.parent) this.unclosedBlock();\n\n          if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n          }\n\n          this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        };\n\n        _proto.freeSemicolon = function freeSemicolon(token) {\n          this.spaces += token[1];\n\n          if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n\n            if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {\n              prev.raws.ownSemicolon = this.spaces;\n              this.spaces = '';\n            }\n          }\n        }; // Helpers\n\n\n        _proto.init = function init(node, line, column) {\n          this.current.push(node);\n          node.source = {\n            start: {\n              line: line,\n              column: column\n            },\n            input: this.input\n          };\n          node.raws.before = this.spaces;\n          this.spaces = '';\n          if (node.type !== 'comment') this.semicolon = false;\n        };\n\n        _proto.raw = function raw(node, prop, tokens) {\n          var token, type;\n          var length = tokens.length;\n          var value = '';\n          var clean = true;\n          var next, prev;\n          var pattern = /^([.|#])?([\\w])+/i;\n\n          for (var i = 0; i < length; i += 1) {\n            token = tokens[i];\n            type = token[0];\n\n            if (type === 'comment' && node.type === 'rule') {\n              prev = tokens[i - 1];\n              next = tokens[i + 1];\n\n              if (prev[0] !== 'space' && next[0] !== 'space' && pattern.test(prev[1]) && pattern.test(next[1])) {\n                value += token[1];\n              } else {\n                clean = false;\n              }\n\n              continue;\n            }\n\n            if (type === 'comment' || type === 'space' && i === length - 1) {\n              clean = false;\n            } else {\n              value += token[1];\n            }\n          }\n\n          if (!clean) {\n            var raw = tokens.reduce(function (all, i) {\n              return all + i[1];\n            }, '');\n            node.raws[prop] = {\n              value: value,\n              raw: raw\n            };\n          }\n\n          node[prop] = value;\n        };\n\n        _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n          var lastTokenType;\n          var spaces = '';\n\n          while (tokens.length) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n            spaces = tokens.pop()[1] + spaces;\n          }\n\n          return spaces;\n        };\n\n        _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n          var next;\n          var spaces = '';\n\n          while (tokens.length) {\n            next = tokens[0][0];\n            if (next !== 'space' && next !== 'comment') break;\n            spaces += tokens.shift()[1];\n          }\n\n          return spaces;\n        };\n\n        _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n          var lastTokenType;\n          var spaces = '';\n\n          while (tokens.length) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space') break;\n            spaces = tokens.pop()[1] + spaces;\n          }\n\n          return spaces;\n        };\n\n        _proto.stringFrom = function stringFrom(tokens, from) {\n          var result = '';\n\n          for (var i = from; i < tokens.length; i++) {\n            result += tokens[i][1];\n          }\n\n          tokens.splice(from, tokens.length - from);\n          return result;\n        };\n\n        _proto.colon = function colon(tokens) {\n          var brackets = 0;\n          var token, type, prev;\n\n          for (var i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            type = token[0];\n\n            if (type === '(') {\n              brackets += 1;\n            }\n\n            if (type === ')') {\n              brackets -= 1;\n            }\n\n            if (brackets === 0 && type === ':') {\n              if (!prev) {\n                this.doubleColon(token);\n              } else if (prev[0] === 'word' && prev[1] === 'progid') {\n                continue;\n              } else {\n                return i;\n              }\n            }\n\n            prev = token;\n          }\n\n          return false;\n        }; // Errors\n\n\n        _proto.unclosedBracket = function unclosedBracket(bracket) {\n          throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n        };\n\n        _proto.unknownWord = function unknownWord(tokens) {\n          throw this.input.error('Unknown word', tokens[0][2], tokens[0][3]);\n        };\n\n        _proto.unexpectedClose = function unexpectedClose(token) {\n          throw this.input.error('Unexpected }', token[2], token[3]);\n        };\n\n        _proto.unclosedBlock = function unclosedBlock() {\n          var pos = this.current.source.start;\n          throw this.input.error('Unclosed block', pos.line, pos.column);\n        };\n\n        _proto.doubleColon = function doubleColon(token) {\n          throw this.input.error('Double colon', token[2], token[3]);\n        };\n\n        _proto.unnamedAtrule = function unnamedAtrule(node, token) {\n          throw this.input.error('At-rule without name', token[2], token[3]);\n        };\n\n        _proto.precheckMissedSemicolon = function precheckMissedSemicolon()\n        /* tokens */\n        {// Hook for Safe Parser\n        };\n\n        _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n          var colon = this.colon(tokens);\n          if (colon === false) return;\n          var founded = 0;\n          var token;\n\n          for (var j = colon - 1; j >= 0; j--) {\n            token = tokens[j];\n\n            if (token[0] !== 'space') {\n              founded += 1;\n              if (founded === 2) break;\n            }\n          }\n\n          throw this.input.error('Missed semicolon', token[2], token[3]);\n        };\n\n        return Parser;\n      }();\n\n      exports.default = Parser;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 67 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _node = _interopRequireDefault(__webpack_require__(20));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS declaration.\n       *\n       * @extends Node\n       *\n       * @example\n       * const root = postcss.parse('a { color: black }')\n       * const decl = root.first.first\n       * decl.type       //=> 'decl'\n       * decl.toString() //=> ' color: black'\n       */\n\n\n      var Declaration =\n      /*#__PURE__*/\n      function (_Node) {\n        _inheritsLoose(Declaration, _Node);\n\n        function Declaration(defaults) {\n          var _this;\n\n          _this = _Node.call(this, defaults) || this;\n          _this.type = 'decl';\n          return _this;\n        }\n        /**\n         * @memberof Declaration#\n         * @member {string} prop The declarations property name.\n         *\n         * @example\n         * const root = postcss.parse('a { color: black }')\n         * const decl = root.first.first\n         * decl.prop //=> 'color'\n         */\n\n        /**\n         * @memberof Declaration#\n         * @member {string} value The declarations value.\n         *\n         * @example\n         * const root = postcss.parse('a { color: black }')\n         * const decl = root.first.first\n         * decl.value //=> 'black'\n         */\n\n        /**\n         * @memberof Declaration#\n         * @member {boolean} important `true` if the declaration\n         *                             has an !important annotation.\n         *\n         * @example\n         * const root = postcss.parse('a { color: black !important; color: red }')\n         * root.first.first.important //=> true\n         * root.first.last.important  //=> undefined\n         */\n\n        /**\n         * @memberof Declaration#\n         * @member {object} raws Information to generate byte-to-byte equal\n         *                       node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `before`: the space symbols before the node. It also stores `*`\n         *   and `_` symbols before the declaration (IE hack).\n         * * `between`: the symbols between the property and value\n         *   for declarations.\n         * * `important`: the content of the important statement,\n         *   if it is not just `!important`.\n         *\n         * PostCSS cleans declaration from comments and extra spaces,\n         * but it stores origin content in raws properties.\n         * As such, if you dont change a declarations value,\n         * PostCSS will use the raw value with comments.\n         *\n         * @example\n         * const root = postcss.parse('a {\\n  color:black\\n}')\n         * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n         */\n\n\n        return Declaration;\n      }(_node.default);\n\n      var _default = Declaration;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 68 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _container = _interopRequireDefault(__webpack_require__(13));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents an at-rule.\n       *\n       * If its followed in the CSS by a {} block, this node will have\n       * a nodes property representing its children.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('@charset \"UTF-8\"; @media print {}')\n       *\n       * const charset = root.first\n       * charset.type  //=> 'atrule'\n       * charset.nodes //=> undefined\n       *\n       * const media = root.last\n       * media.nodes   //=> []\n       */\n\n\n      var AtRule =\n      /*#__PURE__*/\n      function (_Container) {\n        _inheritsLoose(AtRule, _Container);\n\n        function AtRule(defaults) {\n          var _this;\n\n          _this = _Container.call(this, defaults) || this;\n          _this.type = 'atrule';\n          return _this;\n        }\n\n        var _proto = AtRule.prototype;\n\n        _proto.append = function append() {\n          var _Container$prototype$;\n\n          if (!this.nodes) this.nodes = [];\n\n          for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n            children[_key] = arguments[_key];\n          }\n\n          return (_Container$prototype$ = _Container.prototype.append).call.apply(_Container$prototype$, [this].concat(children));\n        };\n\n        _proto.prepend = function prepend() {\n          var _Container$prototype$2;\n\n          if (!this.nodes) this.nodes = [];\n\n          for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            children[_key2] = arguments[_key2];\n          }\n\n          return (_Container$prototype$2 = _Container.prototype.prepend).call.apply(_Container$prototype$2, [this].concat(children));\n        };\n        /**\n         * @memberof AtRule#\n         * @member {string} name The at-rules name immediately follows the `@`.\n         *\n         * @example\n         * const root  = postcss.parse('@media print {}')\n         * media.name //=> 'media'\n         * const media = root.first\n         */\n\n        /**\n         * @memberof AtRule#\n         * @member {string} params The at-rules parameters, the values\n         *                         that follow the at-rules name but precede\n         *                         any {} block.\n         *\n         * @example\n         * const root  = postcss.parse('@media print, screen {}')\n         * const media = root.first\n         * media.params //=> 'print, screen'\n         */\n\n        /**\n         * @memberof AtRule#\n         * @member {object} raws Information to generate byte-to-byte equal\n         *                        node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `before`: the space symbols before the node. It also stores `*`\n         *   and `_` symbols before the declaration (IE hack).\n         * * `after`: the space symbols after the last child of the node\n         *   to the end of the node.\n         * * `between`: the symbols between the property and value\n         *   for declarations, selector and `{` for rules, or last parameter\n         *   and `{` for at-rules.\n         * * `semicolon`: contains true if the last child has\n         *   an (optional) semicolon.\n         * * `afterName`: the space between the at-rule name and its parameters.\n         *\n         * PostCSS cleans at-rule parameters from comments and extra spaces,\n         * but it stores origin content in raws properties.\n         * As such, if you dont change a declarations value,\n         * PostCSS will use the raw value with comments.\n         *\n         * @example\n         * const root = postcss.parse('  @media\\nprint {\\n}')\n         * root.first.first.raws //=> { before: '  ',\n         *                       //     between: ' ',\n         *                       //     afterName: '\\n',\n         *                       //     after: '\\n' }\n         */\n\n\n        return AtRule;\n      }(_container.default);\n\n      var _default = AtRule;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 69 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _parser = _interopRequireDefault(__webpack_require__(66));\n\n      var _input = _interopRequireDefault(__webpack_require__(59));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function parse(css, opts) {\n        var input = new _input.default(css, opts);\n        var parser = new _parser.default(input);\n\n        try {\n          parser.parse();\n        } catch (e) {\n          if (false) {\n            if (e.name === 'CssSyntaxError' && opts && opts.from) {\n              if (/\\.scss$/i.test(opts.from)) {\n                e.message += '\\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';\n              } else if (/\\.sass/i.test(opts.from)) {\n                e.message += '\\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';\n              } else if (/\\.less$/i.test(opts.from)) {\n                e.message += '\\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';\n              }\n            }\n          }\n\n          throw e;\n        }\n\n        return parser.root;\n      }\n\n      var _default = parse;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 70 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _container = _interopRequireDefault(__webpack_require__(13));\n\n      var _list = _interopRequireDefault(__webpack_require__(133));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS rule: a selector followed by a declaration block.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('a{}')\n       * const rule = root.first\n       * rule.type       //=> 'rule'\n       * rule.toString() //=> 'a{}'\n       */\n\n\n      var Rule =\n      /*#__PURE__*/\n      function (_Container) {\n        _inheritsLoose(Rule, _Container);\n\n        function Rule(defaults) {\n          var _this;\n\n          _this = _Container.call(this, defaults) || this;\n          _this.type = 'rule';\n          if (!_this.nodes) _this.nodes = [];\n          return _this;\n        }\n        /**\n         * An array containing the rules individual selectors.\n         * Groups of selectors are split at commas.\n         *\n         * @type {string[]}\n         *\n         * @example\n         * const root = postcss.parse('a, b { }')\n         * const rule = root.first\n         *\n         * rule.selector  //=> 'a, b'\n         * rule.selectors //=> ['a', 'b']\n         *\n         * rule.selectors = ['a', 'strong']\n         * rule.selector //=> 'a, strong'\n         */\n\n\n        _createClass(Rule, [{\n          key: \"selectors\",\n          get: function get() {\n            return _list.default.comma(this.selector);\n          },\n          set: function set(values) {\n            var match = this.selector ? this.selector.match(/,\\s*/) : null;\n            var sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen');\n            this.selector = values.join(sep);\n          }\n          /**\n           * @memberof Rule#\n           * @member {string} selector The rules full selector represented\n           *                           as a string.\n           *\n           * @example\n           * const root = postcss.parse('a, b { }')\n           * const rule = root.first\n           * rule.selector //=> 'a, b'\n           */\n\n          /**\n           * @memberof Rule#\n           * @member {object} raws Information to generate byte-to-byte equal\n           *                       node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node. It also stores `*`\n           *   and `_` symbols before the declaration (IE hack).\n           * * `after`: the space symbols after the last child of the node\n           *   to the end of the node.\n           * * `between`: the symbols between the property and value\n           *   for declarations, selector and `{` for rules, or last parameter\n           *   and `{` for at-rules.\n           * * `semicolon`: contains `true` if the last child has\n           *   an (optional) semicolon.\n           * * `ownSemicolon`: contains `true` if there is semicolon after rule.\n           *\n           * PostCSS cleans selectors from comments and extra spaces,\n           * but it stores origin content in raws properties.\n           * As such, if you dont change a declarations value,\n           * PostCSS will use the raw value with comments.\n           *\n           * @example\n           * const root = postcss.parse('a {\\n  color:black\\n}')\n           * root.first.first.raws //=> { before: '', between: ' ', after: '\\n' }\n           */\n\n        }]);\n\n        return Rule;\n      }(_container.default);\n\n      var _default = Rule;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 71 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _mapGenerator = _interopRequireDefault(__webpack_require__(135));\n\n      var _stringify2 = _interopRequireDefault(__webpack_require__(65));\n\n      var _warnOnce = _interopRequireDefault(__webpack_require__(136));\n\n      var _result = _interopRequireDefault(__webpack_require__(137));\n\n      var _parse = _interopRequireDefault(__webpack_require__(69));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      function isPromise(obj) {\n        return _typeof(obj) === 'object' && typeof obj.then === 'function';\n      }\n      /**\n       * A Promise proxy for the result of PostCSS transformations.\n       *\n       * A `LazyResult` instance is returned by {@link Processor#process}.\n       *\n       * @example\n       * const lazy = postcss([autoprefixer]).process(css)\n       */\n\n\n      var LazyResult =\n      /*#__PURE__*/\n      function () {\n        function LazyResult(processor, css, opts) {\n          this.stringified = false;\n          this.processed = false;\n          var root;\n\n          if (_typeof(css) === 'object' && css !== null && css.type === 'root') {\n            root = css;\n          } else if (css instanceof LazyResult || css instanceof _result.default) {\n            root = css.root;\n\n            if (css.map) {\n              if (typeof opts.map === 'undefined') opts.map = {};\n              if (!opts.map.inline) opts.map.inline = false;\n              opts.map.prev = css.map;\n            }\n          } else {\n            var parser = _parse.default;\n            if (opts.syntax) parser = opts.syntax.parse;\n            if (opts.parser) parser = opts.parser;\n            if (parser.parse) parser = parser.parse;\n\n            try {\n              root = parser(css, opts);\n            } catch (error) {\n              this.error = error;\n            }\n          }\n\n          this.result = new _result.default(processor, root, opts);\n        }\n        /**\n         * Returns a {@link Processor} instance, which will be used\n         * for CSS transformations.\n         *\n         * @type {Processor}\n         */\n\n\n        var _proto = LazyResult.prototype;\n        /**\n         * Processes input CSS through synchronous plugins\n         * and calls {@link Result#warnings()}.\n         *\n         * @return {Warning[]} Warnings from plugins.\n         */\n\n        _proto.warnings = function warnings() {\n          return this.sync().warnings();\n        };\n        /**\n         * Alias for the {@link LazyResult#css} property.\n         *\n         * @example\n         * lazy + '' === lazy.css\n         *\n         * @return {string} Output CSS.\n         */\n\n\n        _proto.toString = function toString() {\n          return this.css;\n        };\n        /**\n         * Processes input CSS through synchronous and asynchronous plugins\n         * and calls `onFulfilled` with a Result instance. If a plugin throws\n         * an error, the `onRejected` callback will be executed.\n         *\n         * It implements standard Promise API.\n         *\n         * @param {onFulfilled} onFulfilled Callback will be executed\n         *                                  when all plugins will finish work.\n         * @param {onRejected}  onRejected  Callback will be executed on any error.\n         *\n         * @return {Promise} Promise API to make queue.\n         *\n         * @example\n         * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {\n         *   console.log(result.css)\n         * })\n         */\n\n\n        _proto.then = function then(onFulfilled, onRejected) {\n          if (false) {\n            if (!('from' in this.opts)) {\n              (0, _warnOnce.default)('Without `from` option PostCSS could generate wrong source map ' + 'and will not find Browserslist config. Set it to CSS file path ' + 'or to `undefined` to prevent this warning.');\n            }\n          }\n\n          return this.async().then(onFulfilled, onRejected);\n        };\n        /**\n         * Processes input CSS through synchronous and asynchronous plugins\n         * and calls onRejected for each error thrown in any plugin.\n         *\n         * It implements standard Promise API.\n         *\n         * @param {onRejected} onRejected Callback will be executed on any error.\n         *\n         * @return {Promise} Promise API to make queue.\n         *\n         * @example\n         * postcss([autoprefixer]).process(css).then(result => {\n         *   console.log(result.css)\n         * }).catch(error => {\n         *   console.error(error)\n         * })\n         */\n\n\n        _proto.catch = function _catch(onRejected) {\n          return this.async().catch(onRejected);\n        };\n        /**\n         * Processes input CSS through synchronous and asynchronous plugins\n         * and calls onFinally on any error or when all plugins will finish work.\n         *\n         * It implements standard Promise API.\n         *\n         * @param {onFinally} onFinally Callback will be executed on any error or\n         *                              when all plugins will finish work.\n         *\n         * @return {Promise} Promise API to make queue.\n         *\n         * @example\n         * postcss([autoprefixer]).process(css).finally(() => {\n         *   console.log('processing ended')\n         * })\n         */\n\n\n        _proto.finally = function _finally(onFinally) {\n          return this.async().then(onFinally, onFinally);\n        };\n\n        _proto.handleError = function handleError(error, plugin) {\n          try {\n            this.error = error;\n\n            if (error.name === 'CssSyntaxError' && !error.plugin) {\n              error.plugin = plugin.postcssPlugin;\n              error.setMessage();\n            } else if (plugin.postcssVersion) {\n              if (false) {\n                var pluginName = plugin.postcssPlugin;\n                var pluginVer = plugin.postcssVersion;\n                var runtimeVer = this.result.processor.version;\n                var a = pluginVer.split('.');\n                var b = runtimeVer.split('.');\n\n                if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n                  console.error('Unknown error from PostCSS plugin. Your current PostCSS ' + 'version is ' + runtimeVer + ', but ' + pluginName + ' uses ' + pluginVer + '. Perhaps this is the source of the error below.');\n                }\n              }\n            }\n          } catch (err) {\n            if (console && console.error) console.error(err);\n          }\n        };\n\n        _proto.asyncTick = function asyncTick(resolve, reject) {\n          var _this = this;\n\n          if (this.plugin >= this.processor.plugins.length) {\n            this.processed = true;\n            return resolve();\n          }\n\n          try {\n            var plugin = this.processor.plugins[this.plugin];\n            var promise = this.run(plugin);\n            this.plugin += 1;\n\n            if (isPromise(promise)) {\n              promise.then(function () {\n                _this.asyncTick(resolve, reject);\n              }).catch(function (error) {\n                _this.handleError(error, plugin);\n\n                _this.processed = true;\n                reject(error);\n              });\n            } else {\n              this.asyncTick(resolve, reject);\n            }\n          } catch (error) {\n            this.processed = true;\n            reject(error);\n          }\n        };\n\n        _proto.async = function async() {\n          var _this2 = this;\n\n          if (this.processed) {\n            return new Promise(function (resolve, reject) {\n              if (_this2.error) {\n                reject(_this2.error);\n              } else {\n                resolve(_this2.stringify());\n              }\n            });\n          }\n\n          if (this.processing) {\n            return this.processing;\n          }\n\n          this.processing = new Promise(function (resolve, reject) {\n            if (_this2.error) return reject(_this2.error);\n            _this2.plugin = 0;\n\n            _this2.asyncTick(resolve, reject);\n          }).then(function () {\n            _this2.processed = true;\n            return _this2.stringify();\n          });\n          return this.processing;\n        };\n\n        _proto.sync = function sync() {\n          if (this.processed) return this.result;\n          this.processed = true;\n\n          if (this.processing) {\n            throw new Error('Use process(css).then(cb) to work with async plugins');\n          }\n\n          if (this.error) throw this.error;\n\n          for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var plugin = _ref;\n            var promise = this.run(plugin);\n\n            if (isPromise(promise)) {\n              throw new Error('Use process(css).then(cb) to work with async plugins');\n            }\n          }\n\n          return this.result;\n        };\n\n        _proto.run = function run(plugin) {\n          this.result.lastPlugin = plugin;\n\n          try {\n            return plugin(this.result.root, this.result);\n          } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n          }\n        };\n\n        _proto.stringify = function stringify() {\n          if (this.stringified) return this.result;\n          this.stringified = true;\n          this.sync();\n          var opts = this.result.opts;\n          var str = _stringify2.default;\n          if (opts.syntax) str = opts.syntax.stringify;\n          if (opts.stringifier) str = opts.stringifier;\n          if (str.stringify) str = str.stringify;\n          var map = new _mapGenerator.default(str, this.result.root, this.result.opts);\n          var data = map.generate();\n          this.result.css = data[0];\n          this.result.map = data[1];\n          return this.result;\n        };\n\n        _createClass(LazyResult, [{\n          key: \"processor\",\n          get: function get() {\n            return this.result.processor;\n          }\n          /**\n           * Options from the {@link Processor#process} call.\n           *\n           * @type {processOptions}\n           */\n\n        }, {\n          key: \"opts\",\n          get: function get() {\n            return this.result.opts;\n          }\n          /**\n           * Processes input CSS through synchronous plugins, converts `Root`\n           * to a CSS string and returns {@link Result#css}.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {string}\n           * @see Result#css\n           */\n\n        }, {\n          key: \"css\",\n          get: function get() {\n            return this.stringify().css;\n          }\n          /**\n           * An alias for the `css` property. Use it with syntaxes\n           * that generate non-CSS output.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {string}\n           * @see Result#content\n           */\n\n        }, {\n          key: \"content\",\n          get: function get() {\n            return this.stringify().content;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#map}.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {SourceMapGenerator}\n           * @see Result#map\n           */\n\n        }, {\n          key: \"map\",\n          get: function get() {\n            return this.stringify().map;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#root}.\n           *\n           * This property will only work with synchronous plugins. If the processor\n           * contains any asynchronous plugins it will throw an error.\n           *\n           * This is why this method is only for debug purpose,\n           * you should always use {@link LazyResult#then}.\n           *\n           * @type {Root}\n           * @see Result#root\n           */\n\n        }, {\n          key: \"root\",\n          get: function get() {\n            return this.sync().root;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#messages}.\n           *\n           * This property will only work with synchronous plugins. If the processor\n           * contains any asynchronous plugins it will throw an error.\n           *\n           * This is why this method is only for debug purpose,\n           * you should always use {@link LazyResult#then}.\n           *\n           * @type {Message[]}\n           * @see Result#messages\n           */\n\n        }, {\n          key: \"messages\",\n          get: function get() {\n            return this.sync().messages;\n          }\n        }]);\n\n        return LazyResult;\n      }();\n\n      var _default = LazyResult;\n      /**\n       * @callback onFulfilled\n       * @param {Result} result\n       */\n\n      /**\n       * @callback onRejected\n       * @param {Error} error\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 72 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(object);\n\n          if (parent === null) {\n            return undefined;\n          } else {\n            return get(parent, property, receiver);\n          }\n        } else if (\"value\" in desc) {\n          return desc.value;\n        } else {\n          var getter = desc.get;\n\n          if (getter === undefined) {\n            return undefined;\n          }\n\n          return getter.call(receiver);\n        }\n      };\n\n      var _comment = __webpack_require__(21);\n\n      var _comment2 = _interopRequireDefault(_comment);\n\n      var _import2 = __webpack_require__(157);\n\n      var _import3 = _interopRequireDefault(_import2);\n\n      var _parser = __webpack_require__(85);\n\n      var _parser2 = _interopRequireDefault(_parser);\n\n      var _rule = __webpack_require__(164);\n\n      var _rule2 = _interopRequireDefault(_rule);\n\n      var _root = __webpack_require__(165);\n\n      var _root2 = _interopRequireDefault(_root);\n\n      var _findExtendRule = __webpack_require__(166);\n\n      var _findExtendRule2 = _interopRequireDefault(_findExtendRule);\n\n      var _isMixinToken = __webpack_require__(167);\n\n      var _isMixinToken2 = _interopRequireDefault(_isMixinToken);\n\n      var _lessTokenize = __webpack_require__(168);\n\n      var _lessTokenize2 = _interopRequireDefault(_lessTokenize);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var blockCommentEndPattern = /\\*\\/$/;\n\n      var LessParser = function (_Parser) {\n        _inherits(LessParser, _Parser);\n\n        function LessParser(input) {\n          _classCallCheck(this, LessParser);\n\n          var _this = _possibleConstructorReturn(this, (LessParser.__proto__ || Object.getPrototypeOf(LessParser)).call(this, input));\n\n          _this.root = new _root2.default();\n          _this.current = _this.root;\n          _this.root.source = {\n            input: input,\n            start: {\n              line: 1,\n              column: 1\n            }\n          };\n          return _this;\n        }\n\n        _createClass(LessParser, [{\n          key: 'atrule',\n          value: function atrule(token) {\n            if (token[1] === '@import') {\n              this.import(token);\n            } else {\n              _get(LessParser.prototype.__proto__ || Object.getPrototypeOf(LessParser.prototype), 'atrule', this).call(this, token);\n            }\n          }\n        }, {\n          key: 'comment',\n          value: function comment(token) {\n            var node = new _comment2.default();\n            var content = token[1];\n            var text = content.slice(2).replace(blockCommentEndPattern, '');\n            this.init(node, token[2], token[3]);\n            node.source.end = {\n              line: token[4],\n              column: token[5]\n            };\n            node.raws.content = content;\n            node.raws.begin = content[0] + content[1];\n            node.inline = token[6] === 'inline';\n            node.block = !node.inline;\n\n            if (/^\\s*$/.test(text)) {\n              node.text = '';\n              node.raws.left = text;\n              node.raws.right = '';\n            } else {\n              var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n              node.text = match[2]; // Add extra spaces to generate a comment in a common style /*[space][text][space]*/\n\n              node.raws.left = match[1] || ' ';\n              node.raws.right = match[3] || ' ';\n            }\n          }\n          /**\n           * @description Create a Declaration\n           * @param options {{start: number}}\n           */\n\n        }, {\n          key: 'createDeclaration',\n          value: function createDeclaration(options) {\n            this.decl(this.tokens.slice(options.start, this.pos + 1));\n          }\n          /**\n           * @description Create a Rule node\n           * @param options {{start: number, params: Array}}\n           */\n\n        }, {\n          key: 'createRule',\n          value: function createRule(options) {\n            var semi = this.tokens[this.pos][0] === ';';\n            var end = this.pos + (options.empty && semi ? 2 : 1);\n            var tokens = this.tokens.slice(options.start, end);\n            var node = this.rule(tokens);\n            /**\n             * By default in PostCSS `Rule.params` is `undefined`.\n             * To preserve compability with PostCSS:\n             *  - Don't set empty params for a Rule.\n             *  - Set params for a Rule only if it can be a mixin or &:extend rule.\n             */\n\n            if (options.params[0] && (options.mixin || options.extend)) {\n              this.raw(node, 'params', options.params);\n            }\n\n            if (options.empty) {\n              // if it's an empty mixin or extend, it must have a semicolon\n              // (that's the only way we get to this point)\n              if (semi) {\n                node.raws.semicolon = this.semicolon = true;\n                node.selector = node.selector.replace(/;$/, '');\n              }\n\n              if (options.extend) {\n                node.extend = true;\n              }\n\n              if (options.mixin) {\n                node.mixin = true;\n              }\n              /**\n               * @description Mark mixin without declarations.\n               * @type {boolean}\n               */\n\n\n              node.empty = true; // eslint-disable-next-line\n\n              delete this.current.nodes;\n\n              if (/!\\s*important/i.test(node.selector)) {\n                node.important = true;\n\n                if (/\\s*!\\s*important/i.test(node.selector)) {\n                  node.raws.important = node.selector.match(/(\\s*!\\s*important)/i)[1];\n                }\n\n                node.selector = node.selector.replace(/\\s*!\\s*important/i, '');\n              } // rules don't have trailing semicolons in vanilla css, so they get\n              // added to this.spaces by the parser loop, so don't step back.\n\n\n              if (!semi) {\n                this.pos--;\n              }\n\n              this.end(this.tokens[this.pos]);\n            }\n          }\n        }, {\n          key: 'end',\n          value: function end(token) {\n            var node = this.current; // if a Rule contains other Rules (mixins, extends) and those have\n            // semicolons, assert that the parent Rule has a semicolon\n\n            if (node.nodes && node.nodes.length && node.last.raws.semicolon && !node.last.nodes) {\n              this.semicolon = true;\n            }\n\n            _get(LessParser.prototype.__proto__ || Object.getPrototypeOf(LessParser.prototype), 'end', this).call(this, token);\n          }\n        }, {\n          key: 'import',\n          value: function _import(token) {\n            /* eslint complexity: 0 */\n            var last = false,\n                open = false,\n                end = {\n              line: 0,\n              column: 0\n            };\n            var directives = [];\n            var node = new _import3.default();\n            node.name = token[1].slice(1);\n            this.init(node, token[2], token[3]);\n            this.pos += 1;\n\n            while (this.pos < this.tokens.length) {\n              var tokn = this.tokens[this.pos];\n\n              if (tokn[0] === ';') {\n                end = {\n                  line: tokn[2],\n                  column: tokn[3]\n                };\n                node.raws.semicolon = true;\n                break;\n              } else if (tokn[0] === '{') {\n                open = true;\n                break;\n              } else if (tokn[0] === '}') {\n                this.end(tokn);\n                break;\n              } else if (tokn[0] === 'brackets') {\n                if (node.urlFunc) {\n                  node.importPath = tokn[1].replace(/[()]/g, '');\n                } else {\n                  directives.push(tokn);\n                }\n              } else if (tokn[0] === 'space') {\n                if (directives.length) {\n                  node.raws.between = tokn[1];\n                } else if (node.urlFunc) {\n                  node.raws.beforeUrl = tokn[1];\n                } else if (node.importPath) {\n                  if (node.urlFunc) {\n                    node.raws.afterUrl = tokn[1];\n                  } else {\n                    node.raws.after = tokn[1];\n                  }\n                } else {\n                  node.raws.afterName = tokn[1];\n                }\n              } else if (tokn[0] === 'word' && tokn[1] === 'url') {\n                node.urlFunc = true;\n              } else {\n                if (tokn[0] !== '(' && tokn[0] !== ')') {\n                  node.importPath = tokn[1];\n                }\n              }\n\n              if (this.pos === this.tokens.length) {\n                last = true;\n                break;\n              }\n\n              this.pos += 1;\n            }\n\n            if (node.raws.between && !node.raws.afterName) {\n              node.raws.afterName = node.raws.between;\n              node.raws.between = '';\n            }\n\n            node.source.end = end;\n\n            if (directives.length) {\n              this.raw(node, 'directives', directives);\n\n              if (last) {\n                token = directives[directives.length - 1];\n                node.source.end = {\n                  line: token[4],\n                  column: token[5]\n                };\n                this.spaces = node.raws.between;\n                node.raws.between = '';\n              }\n            } else {\n              node.directives = '';\n            }\n\n            if (open) {\n              node.nodes = [];\n              this.current = node;\n            }\n          }\n          /* eslint-disable max-statements, complexity */\n\n        }, {\n          key: 'other',\n          value: function other() {\n            var brackets = [];\n            var params = [];\n            var start = this.pos;\n            var end = false,\n                colon = false,\n                bracket = null; // we need pass \"()\" as spaces\n            // However we can override method Parser.loop, but it seems less maintainable\n\n            if (this.tokens[start][0] === 'brackets') {\n              this.spaces += this.tokens[start][1];\n              return;\n            }\n\n            var mixin = (0, _isMixinToken2.default)(this.tokens[start]);\n            var extend = Boolean((0, _findExtendRule2.default)(this.tokens, start));\n\n            while (this.pos < this.tokens.length) {\n              var token = this.tokens[this.pos];\n              var type = token[0];\n\n              if (type === '(' || type === '[') {\n                if (!bracket) {\n                  bracket = token;\n                }\n\n                brackets.push(type === '(' ? ')' : ']');\n              } else if (brackets.length === 0) {\n                if (type === ';') {\n                  var foundEndOfRule = this.ruleEnd({\n                    start: start,\n                    params: params,\n                    colon: colon,\n                    mixin: mixin,\n                    extend: extend\n                  });\n\n                  if (foundEndOfRule) {\n                    return;\n                  }\n\n                  break;\n                } else if (type === '{') {\n                  this.createRule({\n                    start: start,\n                    params: params,\n                    mixin: mixin\n                  });\n                  return;\n                } else if (type === '}') {\n                  this.pos -= 1;\n                  end = true;\n                  break;\n                } else if (type === ':') {\n                  colon = true;\n                }\n              } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n\n                if (brackets.length === 0) {\n                  bracket = null;\n                }\n              } // we don't want to add params for pseudo-selectors that utilize parens (#56)\n              // if ((extend || !colon) && (brackets.length > 0 || type === 'brackets' || params[0])) {\n              //   params.push(token);\n              // }\n              // we don't want to add params for pseudo-selectors that utilize parens (#56) or bracket selectors (#96)\n\n\n              if ((extend || !colon) && (brackets.length > 0 || type === 'brackets' || params[0]) && brackets[0] !== ']') {\n                params.push(token);\n              }\n\n              this.pos += 1;\n            }\n\n            if (this.pos === this.tokens.length) {\n              this.pos -= 1;\n              end = true;\n            }\n\n            if (brackets.length > 0) {\n              this.unclosedBracket(bracket);\n            } // dont process an end of rule if there's only one token and it's unknown (#64)\n\n\n            if (end && this.tokens.length > 1) {\n              // Handle the case where the there is only a single token in the end rule.\n              if (start === this.pos) {\n                this.pos += 1;\n              }\n\n              var _foundEndOfRule = this.ruleEnd({\n                start: start,\n                params: params,\n                colon: colon,\n                mixin: mixin,\n                extend: extend,\n                isEndOfBlock: true\n              });\n\n              if (_foundEndOfRule) {\n                return;\n              }\n            }\n\n            this.unknownWord(start);\n          }\n        }, {\n          key: 'rule',\n          value: function rule(tokens) {\n            tokens.pop();\n            var node = new _rule2.default();\n            this.init(node, tokens[0][2], tokens[0][3]); //node.raws.between = this.spacesFromEnd(tokens);\n\n            node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n            this.raw(node, 'selector', tokens);\n            this.current = node;\n            return node;\n          }\n        }, {\n          key: 'ruleEnd',\n          value: function ruleEnd(options) {\n            var start = options.start;\n\n            if (options.extend || options.mixin) {\n              this.createRule(Object.assign(options, {\n                empty: true\n              }));\n              return true;\n            }\n\n            if (options.colon) {\n              if (options.isEndOfBlock) {\n                while (this.pos > start) {\n                  var token = this.tokens[this.pos][0];\n\n                  if (token !== 'space' && token !== 'comment') {\n                    break;\n                  }\n\n                  this.pos -= 1;\n                }\n              }\n\n              this.createDeclaration({\n                start: start\n              });\n              return true;\n            }\n\n            return false;\n          }\n        }, {\n          key: 'tokenize',\n          value: function tokenize() {\n            this.tokens = (0, _lessTokenize2.default)(this.input);\n          }\n          /* eslint-enable max-statements, complexity */\n\n        }]);\n\n        return LessParser;\n      }(_parser2.default);\n\n      exports.default = LessParser;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 73 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _supportsColor = __webpack_require__(142);\n\n      var _supportsColor2 = _interopRequireDefault(_supportsColor);\n\n      var _chalk = __webpack_require__(74);\n\n      var _chalk2 = _interopRequireDefault(_chalk);\n\n      var _terminalHighlight = __webpack_require__(148);\n\n      var _terminalHighlight2 = _interopRequireDefault(_terminalHighlight);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * The CSS parser throws this error for broken CSS.\n       *\n       * Custom parsers can throw this error for broken custom syntax using\n       * the {@link Node#error} method.\n       *\n       * PostCSS will use the input source map to detect the original error location.\n       * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,\n       * PostCSS will show the original position in the Sass file.\n       *\n       * If you need the position in the PostCSS input\n       * (e.g., to debug the previous compiler), use `error.input.file`.\n       *\n       * @example\n       * // Catching and checking syntax error\n       * try {\n       *   postcss.parse('a{')\n       * } catch (error) {\n       *   if ( error.name === 'CssSyntaxError' ) {\n       *     error //=> CssSyntaxError\n       *   }\n       * }\n       *\n       * @example\n       * // Raising error from plugin\n       * throw node.error('Unknown variable', { plugin: 'postcss-vars' });\n       */\n\n\n      var CssSyntaxError = function () {\n        /**\n         * @param {string} message  - error message\n         * @param {number} [line]   - source line of the error\n         * @param {number} [column] - source column of the error\n         * @param {string} [source] - source code of the broken file\n         * @param {string} [file]   - absolute path to the broken file\n         * @param {string} [plugin] - PostCSS plugin name, if error came from plugin\n         */\n        function CssSyntaxError(message, line, column, source, file, plugin) {\n          _classCallCheck(this, CssSyntaxError);\n          /**\n           * @member {string} - Always equal to `'CssSyntaxError'`. You should\n           *                    always check error type\n           *                    by `error.name === 'CssSyntaxError'` instead of\n           *                    `error instanceof CssSyntaxError`, because\n           *                    npm could have several PostCSS versions.\n           *\n           * @example\n           * if ( error.name === 'CssSyntaxError' ) {\n           *   error //=> CssSyntaxError\n           * }\n           */\n\n\n          this.name = 'CssSyntaxError';\n          /**\n           * @member {string} - Error message.\n           *\n           * @example\n           * error.message //=> 'Unclosed block'\n           */\n\n          this.reason = message;\n\n          if (file) {\n            /**\n             * @member {string} - Absolute path to the broken file.\n             *\n             * @example\n             * error.file       //=> 'a.sass'\n             * error.input.file //=> 'a.css'\n             */\n            this.file = file;\n          }\n\n          if (source) {\n            /**\n             * @member {string} - Source code of the broken file.\n             *\n             * @example\n             * error.source       //=> 'a { b {} }'\n             * error.input.column //=> 'a b { }'\n             */\n            this.source = source;\n          }\n\n          if (plugin) {\n            /**\n             * @member {string} - Plugin name, if error came from plugin.\n             *\n             * @example\n             * error.plugin //=> 'postcss-vars'\n             */\n            this.plugin = plugin;\n          }\n\n          if (typeof line !== 'undefined' && typeof column !== 'undefined') {\n            /**\n             * @member {number} - Source line of the error.\n             *\n             * @example\n             * error.line       //=> 2\n             * error.input.line //=> 4\n             */\n            this.line = line;\n            /**\n             * @member {number} - Source column of the error.\n             *\n             * @example\n             * error.column       //=> 1\n             * error.input.column //=> 4\n             */\n\n            this.column = column;\n          }\n\n          this.setMessage();\n\n          if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, CssSyntaxError);\n          }\n        }\n\n        CssSyntaxError.prototype.setMessage = function setMessage() {\n          /**\n           * @member {string} - Full error text in the GNU error format\n           *                    with plugin, file, line and column.\n           *\n           * @example\n           * error.message //=> 'a.css:1:1: Unclosed block'\n           */\n          this.message = this.plugin ? this.plugin + ': ' : '';\n          this.message += this.file ? this.file : '<css input>';\n\n          if (typeof this.line !== 'undefined') {\n            this.message += ':' + this.line + ':' + this.column;\n          }\n\n          this.message += ': ' + this.reason;\n        };\n        /**\n         * Returns a few lines of CSS source that caused the error.\n         *\n         * If the CSS has an input source map without `sourceContent`,\n         * this method will return an empty string.\n         *\n         * @param {boolean} [color] whether arrow will be colored red by terminal\n         *                          color codes. By default, PostCSS will detect\n         *                          color support by `process.stdout.isTTY`\n         *                          and `process.env.NODE_DISABLE_COLORS`.\n         *\n         * @example\n         * error.showSourceCode() //=> \"  4 | }\n         *                        //      5 | a {\n         *                        //    > 6 |   bad\n         *                        //        |   ^\n         *                        //      7 | }\n         *                        //      8 | b {\"\n         *\n         * @return {string} few lines of CSS source that caused the error\n         */\n\n\n        CssSyntaxError.prototype.showSourceCode = function showSourceCode(color) {\n          var _this = this;\n\n          if (!this.source) return '';\n          var css = this.source;\n          if (typeof color === 'undefined') color = _supportsColor2.default;\n          if (color) css = (0, _terminalHighlight2.default)(css);\n          var lines = css.split(/\\r?\\n/);\n          var start = Math.max(this.line - 3, 0);\n          var end = Math.min(this.line + 2, lines.length);\n          var maxWidth = String(end).length;\n          var colors = new _chalk2.default.constructor({\n            enabled: true\n          });\n\n          function mark(text) {\n            if (color) {\n              return colors.red.bold(text);\n            } else {\n              return text;\n            }\n          }\n\n          function aside(text) {\n            if (color) {\n              return colors.gray(text);\n            } else {\n              return text;\n            }\n          }\n\n          return lines.slice(start, end).map(function (line, index) {\n            var number = start + 1 + index;\n            var gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | ';\n\n            if (number === _this.line) {\n              var spacing = aside(gutter.replace(/\\d/g, ' ')) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, ' ');\n              return mark('>') + aside(gutter) + line + '\\n ' + spacing + mark('^');\n            } else {\n              return ' ' + aside(gutter) + line;\n            }\n          }).join('\\n');\n        };\n        /**\n         * Returns error position, message and source code of the broken part.\n         *\n         * @example\n         * error.toString() //=> \"CssSyntaxError: app.css:1:1: Unclosed block\n         *                  //    > 1 | a {\n         *                  //        | ^\"\n         *\n         * @return {string} error position, message and source code\n         */\n\n\n        CssSyntaxError.prototype.toString = function toString() {\n          var code = this.showSourceCode();\n\n          if (code) {\n            code = '\\n\\n' + code + '\\n';\n          }\n\n          return this.name + ': ' + this.message + code;\n        };\n\n        _createClass(CssSyntaxError, [{\n          key: 'generated',\n          get: function get() {\n            (0, _warnOnce2.default)('CssSyntaxError#generated is deprecated. Use input instead.');\n            return this.input;\n          }\n          /**\n           * @memberof CssSyntaxError#\n           * @member {Input} input - Input object with PostCSS internal information\n           *                         about input file. If input has source map\n           *                         from previous tool, PostCSS will use origin\n           *                         (for example, Sass) source. You can use this\n           *                         object to get PostCSS input source.\n           *\n           * @example\n           * error.input.file //=> 'a.css'\n           * error.file       //=> 'a.sass'\n           */\n\n        }]);\n\n        return CssSyntaxError;\n      }();\n\n      exports.default = CssSyntaxError;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 74 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (process) {\n        var escapeStringRegexp = __webpack_require__(29);\n\n        var ansiStyles = __webpack_require__(143);\n\n        var stripAnsi = __webpack_require__(145);\n\n        var hasAnsi = __webpack_require__(146);\n\n        var supportsColor = __webpack_require__(147);\n\n        var defineProps = Object.defineProperties;\n        var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);\n\n        function Chalk(options) {\n          // detect mode if not set manually\n          this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;\n        } // use bright blue on Windows as the normal blue color is illegible\n\n\n        if (isSimpleWindowsTerm) {\n          ansiStyles.blue.open = \"\\x1B[94m\";\n        }\n\n        var styles = function () {\n          var ret = {};\n          Object.keys(ansiStyles).forEach(function (key) {\n            ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n            ret[key] = {\n              get: function get() {\n                return build.call(this, this._styles.concat(key));\n              }\n            };\n          });\n          return ret;\n        }();\n\n        var proto = defineProps(function chalk() {}, styles);\n\n        function build(_styles) {\n          var builder = function builder() {\n            return applyStyle.apply(builder, arguments);\n          };\n\n          builder._styles = _styles;\n          builder.enabled = this.enabled; // __proto__ is used because we must return a function, but there is\n          // no way to create a function with a different prototype.\n\n          /* eslint-disable no-proto */\n\n          builder.__proto__ = proto;\n          return builder;\n        }\n\n        function applyStyle() {\n          // support varags, but simply cast to string in case there's only one arg\n          var args = arguments;\n          var argsLen = args.length;\n          var str = argsLen !== 0 && String(arguments[0]);\n\n          if (argsLen > 1) {\n            // don't slice `arguments`, it prevents v8 optimizations\n            for (var a = 1; a < argsLen; a++) {\n              str += ' ' + args[a];\n            }\n          }\n\n          if (!this.enabled || !str) {\n            return str;\n          }\n\n          var nestedStyles = this._styles;\n          var i = nestedStyles.length; // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,\n          // see https://github.com/chalk/chalk/issues/58\n          // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.\n\n          var originalDim = ansiStyles.dim.open;\n\n          if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {\n            ansiStyles.dim.open = '';\n          }\n\n          while (i--) {\n            var code = ansiStyles[nestedStyles[i]]; // Replace any instances already present with a re-opening code\n            // otherwise only the part of the string until said closing code\n            // will be colored, and the rest will simply be 'plain'.\n\n            str = code.open + str.replace(code.closeRe, code.open) + code.close;\n          } // Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.\n\n\n          ansiStyles.dim.open = originalDim;\n          return str;\n        }\n\n        function init() {\n          var ret = {};\n          Object.keys(styles).forEach(function (name) {\n            ret[name] = {\n              get: function get() {\n                return build.call(this, [name]);\n              }\n            };\n          });\n          return ret;\n        }\n\n        defineProps(Chalk.prototype, init());\n        module.exports = new Chalk();\n        module.exports.styles = ansiStyles;\n        module.exports.hasColor = hasAnsi;\n        module.exports.stripColor = stripAnsi;\n        module.exports.supportsColor = supportsColor;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(12));\n      /***/\n    },\n    /* 75 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function () {\n        return /[\\u001b\\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;\n      };\n      /***/\n\n    },\n    /* 76 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = tokenize;\n      var SINGLE_QUOTE = 39;\n      var DOUBLE_QUOTE = 34;\n      var BACKSLASH = 92;\n      var SLASH = 47;\n      var NEWLINE = 10;\n      var SPACE = 32;\n      var FEED = 12;\n      var TAB = 9;\n      var CR = 13;\n      var OPEN_SQUARE = 91;\n      var CLOSE_SQUARE = 93;\n      var OPEN_PARENTHESES = 40;\n      var CLOSE_PARENTHESES = 41;\n      var OPEN_CURLY = 123;\n      var CLOSE_CURLY = 125;\n      var SEMICOLON = 59;\n      var ASTERISK = 42;\n      var COLON = 58;\n      var AT = 64;\n      var RE_AT_END = /[ \\n\\t\\r\\f\\{\\(\\)'\"\\\\;/\\[\\]#]/g;\n      var RE_WORD_END = /[ \\n\\t\\r\\f\\(\\)\\{\\}:;@!'\"\\\\\\]\\[#]|\\/(?=\\*)/g;\n      var RE_BAD_BRACKET = /.[\\\\\\/\\(\"'\\n]/;\n\n      function tokenize(input) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var tokens = [];\n        var css = input.css.valueOf();\n        var ignore = options.ignoreErrors;\n        var code = void 0,\n            next = void 0,\n            quote = void 0,\n            lines = void 0,\n            last = void 0,\n            content = void 0,\n            escape = void 0,\n            nextLine = void 0,\n            nextOffset = void 0,\n            escaped = void 0,\n            escapePos = void 0,\n            prev = void 0,\n            n = void 0;\n        var length = css.length;\n        var offset = -1;\n        var line = 1;\n        var pos = 0;\n\n        function unclosed(what) {\n          throw input.error('Unclosed ' + what, line, pos - offset);\n        }\n\n        while (pos < length) {\n          code = css.charCodeAt(pos);\n\n          if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n            offset = pos;\n            line += 1;\n          }\n\n          switch (code) {\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n\n                if (code === NEWLINE) {\n                  offset = next;\n                  line += 1;\n                }\n              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n              tokens.push(['space', css.slice(pos, next)]);\n              pos = next - 1;\n              break;\n\n            case OPEN_SQUARE:\n              tokens.push(['[', '[', line, pos - offset]);\n              break;\n\n            case CLOSE_SQUARE:\n              tokens.push([']', ']', line, pos - offset]);\n              break;\n\n            case OPEN_CURLY:\n              tokens.push(['{', '{', line, pos - offset]);\n              break;\n\n            case CLOSE_CURLY:\n              tokens.push(['}', '}', line, pos - offset]);\n              break;\n\n            case COLON:\n              tokens.push([':', ':', line, pos - offset]);\n              break;\n\n            case SEMICOLON:\n              tokens.push([';', ';', line, pos - offset]);\n              break;\n\n            case OPEN_PARENTHESES:\n              prev = tokens.length ? tokens[tokens.length - 1][1] : '';\n              n = css.charCodeAt(pos + 1);\n\n              if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n                next = pos;\n\n                do {\n                  escaped = false;\n                  next = css.indexOf(')', next + 1);\n\n                  if (next === -1) {\n                    if (ignore) {\n                      next = pos;\n                      break;\n                    } else {\n                      unclosed('bracket');\n                    }\n                  }\n\n                  escapePos = next;\n\n                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                  }\n                } while (escaped);\n\n                tokens.push(['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n              } else {\n                next = css.indexOf(')', pos + 1);\n                content = css.slice(pos, next + 1);\n\n                if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                  tokens.push(['(', '(', line, pos - offset]);\n                } else {\n                  tokens.push(['brackets', content, line, pos - offset, line, next - offset]);\n                  pos = next;\n                }\n              }\n\n              break;\n\n            case CLOSE_PARENTHESES:\n              tokens.push([')', ')', line, pos - offset]);\n              break;\n\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n              quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n              next = pos;\n\n              do {\n                escaped = false;\n                next = css.indexOf(quote, next + 1);\n\n                if (next === -1) {\n                  if (ignore) {\n                    next = pos + 1;\n                    break;\n                  } else {\n                    unclosed('string');\n                  }\n                }\n\n                escapePos = next;\n\n                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n                  escapePos -= 1;\n                  escaped = !escaped;\n                }\n              } while (escaped);\n\n              content = css.slice(pos, next + 1);\n              lines = content.split('\\n');\n              last = lines.length - 1;\n\n              if (last > 0) {\n                nextLine = line + last;\n                nextOffset = next - lines[last].length;\n              } else {\n                nextLine = line;\n                nextOffset = offset;\n              }\n\n              tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset]);\n              offset = nextOffset;\n              line = nextLine;\n              pos = next;\n              break;\n\n            case AT:\n              RE_AT_END.lastIndex = pos + 1;\n              RE_AT_END.test(css);\n\n              if (RE_AT_END.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = RE_AT_END.lastIndex - 2;\n              }\n\n              tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n              pos = next;\n              break;\n\n            case BACKSLASH:\n              next = pos;\n              escape = true;\n\n              while (css.charCodeAt(next + 1) === BACKSLASH) {\n                next += 1;\n                escape = !escape;\n              }\n\n              code = css.charCodeAt(next + 1);\n\n              if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                next += 1;\n              }\n\n              tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n              pos = next;\n              break;\n\n            default:\n              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                next = css.indexOf('*/', pos + 2) + 1;\n\n                if (next === 0) {\n                  if (ignore) {\n                    next = css.length;\n                  } else {\n                    unclosed('comment');\n                  }\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset]);\n                offset = nextOffset;\n                line = nextLine;\n                pos = next;\n              } else {\n                RE_WORD_END.lastIndex = pos + 1;\n                RE_WORD_END.test(css);\n\n                if (RE_WORD_END.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = RE_WORD_END.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset]);\n                pos = next;\n              }\n\n              break;\n          }\n\n          pos++;\n        }\n\n        return tokens;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 77 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (global) {\n        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n        /*\n        * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $\n        *\n        *  Licensed under the BSD 3-Clause License.\n        *    http://opensource.org/licenses/BSD-3-Clause\n        *\n        *  References:\n        *    http://en.wikipedia.org/wiki/Base64\n        */\n\n\n        (function (global) {\n          'use strict'; // existing version for noConflict()\n\n          var _Base64 = global.Base64;\n          var version = \"2.3.2\"; // if node.js, we use Buffer\n\n          var buffer;\n\n          if (typeof module !== 'undefined' && module.exports) {\n            try {\n              buffer = __webpack_require__(18).Buffer;\n            } catch (err) {}\n          } // constants\n\n\n          var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n          var b64tab = function (bin) {\n            var t = {};\n\n            for (var i = 0, l = bin.length; i < l; i++) {\n              t[bin.charAt(i)] = i;\n            }\n\n            return t;\n          }(b64chars);\n\n          var fromCharCode = String.fromCharCode; // encoder stuff\n\n          var cb_utob = function cb_utob(c) {\n            if (c.length < 2) {\n              var cc = c.charCodeAt(0);\n              return cc < 0x80 ? c : cc < 0x800 ? fromCharCode(0xc0 | cc >>> 6) + fromCharCode(0x80 | cc & 0x3f) : fromCharCode(0xe0 | cc >>> 12 & 0x0f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n            } else {\n              var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);\n              return fromCharCode(0xf0 | cc >>> 18 & 0x07) + fromCharCode(0x80 | cc >>> 12 & 0x3f) + fromCharCode(0x80 | cc >>> 6 & 0x3f) + fromCharCode(0x80 | cc & 0x3f);\n            }\n          };\n\n          var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n\n          var utob = function utob(u) {\n            return u.replace(re_utob, cb_utob);\n          };\n\n          var cb_encode = function cb_encode(ccc) {\n            var padlen = [0, 2, 1][ccc.length % 3],\n                ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0),\n                chars = [b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? '=' : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)];\n            return chars.join('');\n          };\n\n          var btoa = global.btoa ? function (b) {\n            return global.btoa(b);\n          } : function (b) {\n            return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n          };\n\n          var _encode = buffer ? buffer.from && buffer.from !== Uint8Array.from ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u)).toString('base64');\n          } : function (u) {\n            return (u.constructor === buffer.constructor ? u : new buffer(u)).toString('base64');\n          } : function (u) {\n            return btoa(utob(u));\n          };\n\n          var encode = function encode(u, urisafe) {\n            return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\\/]/g, function (m0) {\n              return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n          };\n\n          var encodeURI = function encodeURI(u) {\n            return encode(u, true);\n          }; // decoder stuff\n\n\n          var re_btou = new RegExp(['[\\xC0-\\xDF][\\x80-\\xBF]', '[\\xE0-\\xEF][\\x80-\\xBF]{2}', '[\\xF0-\\xF7][\\x80-\\xBF]{3}'].join('|'), 'g');\n\n          var cb_btou = function cb_btou(cccc) {\n            switch (cccc.length) {\n              case 4:\n                var cp = (0x07 & cccc.charCodeAt(0)) << 18 | (0x3f & cccc.charCodeAt(1)) << 12 | (0x3f & cccc.charCodeAt(2)) << 6 | 0x3f & cccc.charCodeAt(3),\n                    offset = cp - 0x10000;\n                return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);\n\n              case 3:\n                return fromCharCode((0x0f & cccc.charCodeAt(0)) << 12 | (0x3f & cccc.charCodeAt(1)) << 6 | 0x3f & cccc.charCodeAt(2));\n\n              default:\n                return fromCharCode((0x1f & cccc.charCodeAt(0)) << 6 | 0x3f & cccc.charCodeAt(1));\n            }\n          };\n\n          var btou = function btou(b) {\n            return b.replace(re_btou, cb_btou);\n          };\n\n          var cb_decode = function cb_decode(cccc) {\n            var len = cccc.length,\n                padlen = len % 4,\n                n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),\n                chars = [fromCharCode(n >>> 16), fromCharCode(n >>> 8 & 0xff), fromCharCode(n & 0xff)];\n            chars.length -= [0, 0, 2, 1][padlen];\n            return chars.join('');\n          };\n\n          var atob = global.atob ? function (a) {\n            return global.atob(a);\n          } : function (a) {\n            return a.replace(/[\\s\\S]{1,4}/g, cb_decode);\n          };\n\n          var _decode = buffer ? buffer.from && buffer.from !== Uint8Array.from ? function (a) {\n            return (a.constructor === buffer.constructor ? a : buffer.from(a, 'base64')).toString();\n          } : function (a) {\n            return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString();\n          } : function (a) {\n            return btou(atob(a));\n          };\n\n          var decode = function decode(a) {\n            return _decode(String(a).replace(/[-_]/g, function (m0) {\n              return m0 == '-' ? '+' : '/';\n            }).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n          };\n\n          var noConflict = function noConflict() {\n            var Base64 = global.Base64;\n            global.Base64 = _Base64;\n            return Base64;\n          }; // export Base64\n\n\n          global.Base64 = {\n            VERSION: version,\n            atob: atob,\n            btoa: btoa,\n            fromBase64: decode,\n            toBase64: encode,\n            utob: utob,\n            encode: encode,\n            encodeURI: encodeURI,\n            btou: btou,\n            decode: decode,\n            noConflict: noConflict\n          }; // if ES5 is available, make Base64.extendString() available\n\n          if (typeof Object.defineProperty === 'function') {\n            var noEnum = function noEnum(v) {\n              return {\n                value: v,\n                enumerable: false,\n                writable: true,\n                configurable: true\n              };\n            };\n\n            global.Base64.extendString = function () {\n              Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () {\n                return decode(this);\n              }));\n              Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) {\n                return encode(this, urisafe);\n              }));\n              Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () {\n                return encode(this, true);\n              }));\n            };\n          } //\n          // export Base64 to the namespace\n          //\n\n\n          if (global['Meteor']) {\n            // Meteor.js\n            Base64 = global.Base64;\n          } // module.exports and AMD are mutually exclusive.\n          // module.exports has precedence.\n\n\n          if (typeof module !== 'undefined' && module.exports) {\n            module.exports.Base64 = global.Base64;\n          } else if (true) {\n            // AMD. Register as an anonymous module.\t\n            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n              return global.Base64;\n            }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n          } // that's it!\n\n        })(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this);\n        /* WEBPACK VAR INJECTION */\n\n      }).call(exports, __webpack_require__(15));\n      /***/\n    },\n    /* 78 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /*\n       * Copyright 2009-2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE.txt or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.SourceMapGenerator = __webpack_require__(79).SourceMapGenerator;\n      exports.SourceMapConsumer = __webpack_require__(152).SourceMapConsumer;\n      exports.SourceNode = __webpack_require__(155).SourceNode;\n      /***/\n    },\n    /* 79 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var base64VLQ = __webpack_require__(80);\n\n      var util = __webpack_require__(9);\n\n      var ArraySet = __webpack_require__(81).ArraySet;\n\n      var MappingList = __webpack_require__(151).MappingList;\n      /**\n       * An instance of the SourceMapGenerator represents a source map which is\n       * being built incrementally. You may pass an object with the following\n       * properties:\n       *\n       *   - file: The filename of the generated source.\n       *   - sourceRoot: A root for all relative URLs in this source map.\n       */\n\n\n      function SourceMapGenerator(aArgs) {\n        if (!aArgs) {\n          aArgs = {};\n        }\n\n        this._file = util.getArg(aArgs, 'file', null);\n        this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n        this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        this._mappings = new MappingList();\n        this._sourcesContents = null;\n      }\n\n      SourceMapGenerator.prototype._version = 3;\n      /**\n       * Creates a new SourceMapGenerator based on a SourceMapConsumer\n       *\n       * @param aSourceMapConsumer The SourceMap.\n       */\n\n      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n        var sourceRoot = aSourceMapConsumer.sourceRoot;\n        var generator = new SourceMapGenerator({\n          file: aSourceMapConsumer.file,\n          sourceRoot: sourceRoot\n        });\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          var newMapping = {\n            generated: {\n              line: mapping.generatedLine,\n              column: mapping.generatedColumn\n            }\n          };\n\n          if (mapping.source != null) {\n            newMapping.source = mapping.source;\n\n            if (sourceRoot != null) {\n              newMapping.source = util.relative(sourceRoot, newMapping.source);\n            }\n\n            newMapping.original = {\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            };\n\n            if (mapping.name != null) {\n              newMapping.name = mapping.name;\n            }\n          }\n\n          generator.addMapping(newMapping);\n        });\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            generator.setSourceContent(sourceFile, content);\n          }\n        });\n        return generator;\n      };\n      /**\n       * Add a single mapping from original source line and column to the generated\n       * source's line and column for this source map being created. The mapping\n       * object should have the following properties:\n       *\n       *   - generated: An object with the generated line and column positions.\n       *   - original: An object with the original line and column positions.\n       *   - source: The original source file (relative to the sourceRoot).\n       *   - name: An optional original token name for this mapping.\n       */\n\n\n      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {\n        var generated = util.getArg(aArgs, 'generated');\n        var original = util.getArg(aArgs, 'original', null);\n        var source = util.getArg(aArgs, 'source', null);\n        var name = util.getArg(aArgs, 'name', null);\n\n        if (!this._skipValidation) {\n          this._validateMapping(generated, original, source, name);\n        }\n\n        if (source != null) {\n          source = String(source);\n\n          if (!this._sources.has(source)) {\n            this._sources.add(source);\n          }\n        }\n\n        if (name != null) {\n          name = String(name);\n\n          if (!this._names.has(name)) {\n            this._names.add(name);\n          }\n        }\n\n        this._mappings.add({\n          generatedLine: generated.line,\n          generatedColumn: generated.column,\n          originalLine: original != null && original.line,\n          originalColumn: original != null && original.column,\n          source: source,\n          name: name\n        });\n      };\n      /**\n       * Set the source content for a source file.\n       */\n\n\n      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n        var source = aSourceFile;\n\n        if (this._sourceRoot != null) {\n          source = util.relative(this._sourceRoot, source);\n        }\n\n        if (aSourceContent != null) {\n          // Add the source content to the _sourcesContents map.\n          // Create a new _sourcesContents map if the property is null.\n          if (!this._sourcesContents) {\n            this._sourcesContents = Object.create(null);\n          }\n\n          this._sourcesContents[util.toSetString(source)] = aSourceContent;\n        } else if (this._sourcesContents) {\n          // Remove the source file from the _sourcesContents map.\n          // If the _sourcesContents map is empty, set the property to null.\n          delete this._sourcesContents[util.toSetString(source)];\n\n          if (Object.keys(this._sourcesContents).length === 0) {\n            this._sourcesContents = null;\n          }\n        }\n      };\n      /**\n       * Applies the mappings of a sub-source-map for a specific source file to the\n       * source map being generated. Each mapping to the supplied source file is\n       * rewritten using the supplied source map. Note: The resolution for the\n       * resulting mappings is the minimium of this map and the supplied map.\n       *\n       * @param aSourceMapConsumer The source map to be applied.\n       * @param aSourceFile Optional. The filename of the source file.\n       *        If omitted, SourceMapConsumer's file property will be used.\n       * @param aSourceMapPath Optional. The dirname of the path to the source map\n       *        to be applied. If relative, it is relative to the SourceMapConsumer.\n       *        This parameter is needed when the two source maps aren't in the same\n       *        directory, and the source map to be applied contains relative source\n       *        paths. If so, those relative source paths need to be rewritten\n       *        relative to the SourceMapGenerator.\n       */\n\n\n      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n        var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap\n\n        if (aSourceFile == null) {\n          if (aSourceMapConsumer.file == null) {\n            throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\\'s \"file\" property. Both were omitted.');\n          }\n\n          sourceFile = aSourceMapConsumer.file;\n        }\n\n        var sourceRoot = this._sourceRoot; // Make \"sourceFile\" relative if an absolute Url is passed.\n\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        } // Applying the SourceMap can add and remove items from the sources and\n        // the names array.\n\n\n        var newSources = new ArraySet();\n        var newNames = new ArraySet(); // Find mappings for the \"sourceFile\"\n\n        this._mappings.unsortedForEach(function (mapping) {\n          if (mapping.source === sourceFile && mapping.originalLine != null) {\n            // Check if it can be mapped by the source map, then update the mapping.\n            var original = aSourceMapConsumer.originalPositionFor({\n              line: mapping.originalLine,\n              column: mapping.originalColumn\n            });\n\n            if (original.source != null) {\n              // Copy mapping\n              mapping.source = original.source;\n\n              if (aSourceMapPath != null) {\n                mapping.source = util.join(aSourceMapPath, mapping.source);\n              }\n\n              if (sourceRoot != null) {\n                mapping.source = util.relative(sourceRoot, mapping.source);\n              }\n\n              mapping.originalLine = original.line;\n              mapping.originalColumn = original.column;\n\n              if (original.name != null) {\n                mapping.name = original.name;\n              }\n            }\n          }\n\n          var source = mapping.source;\n\n          if (source != null && !newSources.has(source)) {\n            newSources.add(source);\n          }\n\n          var name = mapping.name;\n\n          if (name != null && !newNames.has(name)) {\n            newNames.add(name);\n          }\n        }, this);\n\n        this._sources = newSources;\n        this._names = newNames; // Copy sourcesContents of applied map.\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aSourceMapPath != null) {\n              sourceFile = util.join(aSourceMapPath, sourceFile);\n            }\n\n            if (sourceRoot != null) {\n              sourceFile = util.relative(sourceRoot, sourceFile);\n            }\n\n            this.setSourceContent(sourceFile, content);\n          }\n        }, this);\n      };\n      /**\n       * A mapping can have one of the three levels of data:\n       *\n       *   1. Just the generated position.\n       *   2. The Generated position, original position, and original source.\n       *   3. Generated and original position, original source, as well as a name\n       *      token.\n       *\n       * To maintain consistency, we validate that any new mapping being added falls\n       * in to one of these categories.\n       */\n\n\n      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {\n        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {\n          // Case 1.\n          return;\n        } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {\n          // Cases 2 and 3.\n          return;\n        } else {\n          throw new Error('Invalid mapping: ' + JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName\n          }));\n        }\n      };\n      /**\n       * Serialize the accumulated mappings in to the stream of base 64 VLQs\n       * specified by the source map format.\n       */\n\n\n      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {\n        var previousGeneratedColumn = 0;\n        var previousGeneratedLine = 1;\n        var previousOriginalColumn = 0;\n        var previousOriginalLine = 0;\n        var previousName = 0;\n        var previousSource = 0;\n        var result = '';\n        var next;\n        var mapping;\n        var nameIdx;\n        var sourceIdx;\n\n        var mappings = this._mappings.toArray();\n\n        for (var i = 0, len = mappings.length; i < len; i++) {\n          mapping = mappings[i];\n          next = '';\n\n          if (mapping.generatedLine !== previousGeneratedLine) {\n            previousGeneratedColumn = 0;\n\n            while (mapping.generatedLine !== previousGeneratedLine) {\n              next += ';';\n              previousGeneratedLine++;\n            }\n          } else {\n            if (i > 0) {\n              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n                continue;\n              }\n\n              next += ',';\n            }\n          }\n\n          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);\n          previousGeneratedColumn = mapping.generatedColumn;\n\n          if (mapping.source != null) {\n            sourceIdx = this._sources.indexOf(mapping.source);\n            next += base64VLQ.encode(sourceIdx - previousSource);\n            previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3\n\n            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);\n            previousOriginalLine = mapping.originalLine - 1;\n            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);\n            previousOriginalColumn = mapping.originalColumn;\n\n            if (mapping.name != null) {\n              nameIdx = this._names.indexOf(mapping.name);\n              next += base64VLQ.encode(nameIdx - previousName);\n              previousName = nameIdx;\n            }\n          }\n\n          result += next;\n        }\n\n        return result;\n      };\n\n      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n        return aSources.map(function (source) {\n          if (!this._sourcesContents) {\n            return null;\n          }\n\n          if (aSourceRoot != null) {\n            source = util.relative(aSourceRoot, source);\n          }\n\n          var key = util.toSetString(source);\n          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;\n        }, this);\n      };\n      /**\n       * Externalize the source map.\n       */\n\n\n      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {\n        var map = {\n          version: this._version,\n          sources: this._sources.toArray(),\n          names: this._names.toArray(),\n          mappings: this._serializeMappings()\n        };\n\n        if (this._file != null) {\n          map.file = this._file;\n        }\n\n        if (this._sourceRoot != null) {\n          map.sourceRoot = this._sourceRoot;\n        }\n\n        if (this._sourcesContents) {\n          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n        }\n\n        return map;\n      };\n      /**\n       * Render the source map being generated to a string.\n       */\n\n\n      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {\n        return JSON.stringify(this.toJSON());\n      };\n\n      exports.SourceMapGenerator = SourceMapGenerator;\n      /***/\n    },\n    /* 80 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       *\n       * Based on the Base 64 VLQ implementation in Closure Compiler:\n       * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n       *\n       * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n       * Redistribution and use in source and binary forms, with or without\n       * modification, are permitted provided that the following conditions are\n       * met:\n       *\n       *  * Redistributions of source code must retain the above copyright\n       *    notice, this list of conditions and the following disclaimer.\n       *  * Redistributions in binary form must reproduce the above\n       *    copyright notice, this list of conditions and the following\n       *    disclaimer in the documentation and/or other materials provided\n       *    with the distribution.\n       *  * Neither the name of Google Inc. nor the names of its\n       *    contributors may be used to endorse or promote products derived\n       *    from this software without specific prior written permission.\n       *\n       * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n       * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n       * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n       * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n       * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n       * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n       * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n       * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n       * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n       * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n       * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n       */\n      var base64 = __webpack_require__(150); // A single base 64 digit can contain 6 bits of data. For the base 64 variable\n      // length quantities we use in the source map spec, the first bit is the sign,\n      // the next four bits are the actual value, and the 6th bit is the\n      // continuation bit. The continuation bit tells us whether there are more\n      // digits in this value following this digit.\n      //\n      //   Continuation\n      //   |    Sign\n      //   |    |\n      //   V    V\n      //   101011\n\n\n      var VLQ_BASE_SHIFT = 5; // binary: 100000\n\n      var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111\n\n      var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000\n\n      var VLQ_CONTINUATION_BIT = VLQ_BASE;\n      /**\n       * Converts from a two-complement value to a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n       *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n       */\n\n      function toVLQSigned(aValue) {\n        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n      }\n      /**\n       * Converts to a two-complement value from a value where the sign bit is\n       * placed in the least significant bit.  For example, as decimals:\n       *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n       *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n       */\n\n\n      function fromVLQSigned(aValue) {\n        var isNegative = (aValue & 1) === 1;\n        var shifted = aValue >> 1;\n        return isNegative ? -shifted : shifted;\n      }\n      /**\n       * Returns the base 64 VLQ encoded value.\n       */\n\n\n      exports.encode = function base64VLQ_encode(aValue) {\n        var encoded = \"\";\n        var digit;\n        var vlq = toVLQSigned(aValue);\n\n        do {\n          digit = vlq & VLQ_BASE_MASK;\n          vlq >>>= VLQ_BASE_SHIFT;\n\n          if (vlq > 0) {\n            // There are still more digits in this value, so we must make sure the\n            // continuation bit is marked.\n            digit |= VLQ_CONTINUATION_BIT;\n          }\n\n          encoded += base64.encode(digit);\n        } while (vlq > 0);\n\n        return encoded;\n      };\n      /**\n       * Decodes the next base 64 VLQ value from the given string and returns the\n       * value and the rest of the string via the out parameter.\n       */\n\n\n      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n        var strLen = aStr.length;\n        var result = 0;\n        var shift = 0;\n        var continuation, digit;\n\n        do {\n          if (aIndex >= strLen) {\n            throw new Error(\"Expected more digits in base 64 VLQ value.\");\n          }\n\n          digit = base64.decode(aStr.charCodeAt(aIndex++));\n\n          if (digit === -1) {\n            throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n          }\n\n          continuation = !!(digit & VLQ_CONTINUATION_BIT);\n          digit &= VLQ_BASE_MASK;\n          result = result + (digit << shift);\n          shift += VLQ_BASE_SHIFT;\n        } while (continuation);\n\n        aOutParam.value = fromVLQSigned(result);\n        aOutParam.rest = aIndex;\n      };\n      /***/\n\n    },\n    /* 81 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(9);\n\n      var has = Object.prototype.hasOwnProperty;\n      /**\n       * A data structure which is a combination of an array and a set. Adding a new\n       * member is O(1), testing for membership is O(1), and finding the index of an\n       * element is O(1). Removing elements from the set is not supported. Only\n       * strings are supported for membership.\n       */\n\n      function ArraySet() {\n        this._array = [];\n        this._set = Object.create(null);\n      }\n      /**\n       * Static method for creating ArraySet instances from an existing array.\n       */\n\n\n      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n        var set = new ArraySet();\n\n        for (var i = 0, len = aArray.length; i < len; i++) {\n          set.add(aArray[i], aAllowDuplicates);\n        }\n\n        return set;\n      };\n      /**\n       * Return how many unique items are in this ArraySet. If duplicates have been\n       * added, than those do not count towards the size.\n       *\n       * @returns Number\n       */\n\n\n      ArraySet.prototype.size = function ArraySet_size() {\n        return Object.getOwnPropertyNames(this._set).length;\n      };\n      /**\n       * Add the given string to this set.\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n        var sStr = util.toSetString(aStr);\n        var isDuplicate = has.call(this._set, sStr);\n        var idx = this._array.length;\n\n        if (!isDuplicate || aAllowDuplicates) {\n          this._array.push(aStr);\n        }\n\n        if (!isDuplicate) {\n          this._set[sStr] = idx;\n        }\n      };\n      /**\n       * Is the given string a member of this set?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.has = function ArraySet_has(aStr) {\n        var sStr = util.toSetString(aStr);\n        return has.call(this._set, sStr);\n      };\n      /**\n       * What is the index of the given string in the array?\n       *\n       * @param String aStr\n       */\n\n\n      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n        var sStr = util.toSetString(aStr);\n\n        if (has.call(this._set, sStr)) {\n          return this._set[sStr];\n        }\n\n        throw new Error('\"' + aStr + '\" is not in the set.');\n      };\n      /**\n       * What is the element at the given index?\n       *\n       * @param Number aIdx\n       */\n\n\n      ArraySet.prototype.at = function ArraySet_at(aIdx) {\n        if (aIdx >= 0 && aIdx < this._array.length) {\n          return this._array[aIdx];\n        }\n\n        throw new Error('No element indexed by ' + aIdx);\n      };\n      /**\n       * Returns the array representation of this set (which has the proper indices\n       * indicated by indexOf). Note that this is a copy of the internal array used\n       * for storing the members so that no one can mess with internal state.\n       */\n\n\n      ArraySet.prototype.toArray = function ArraySet_toArray() {\n        return this._array.slice();\n      };\n\n      exports.ArraySet = ArraySet;\n      /***/\n    },\n    /* 82 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = stringify;\n\n      var _stringifier = __webpack_require__(24);\n\n      var _stringifier2 = _interopRequireDefault(_stringifier);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function stringify(node, builder) {\n        var str = new _stringifier2.default(builder);\n        str.stringify(node);\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 83 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      var _node = __webpack_require__(22);\n\n      var _node2 = _interopRequireDefault(_node);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS declaration.\n       *\n       * @extends Node\n       *\n       * @example\n       * const root = postcss.parse('a { color: black }');\n       * const decl = root.first.first;\n       * decl.type       //=> 'decl'\n       * decl.toString() //=> ' color: black'\n       */\n\n\n      var Declaration = function (_Node) {\n        _inherits(Declaration, _Node);\n\n        function Declaration(defaults) {\n          _classCallCheck(this, Declaration);\n\n          var _this = _possibleConstructorReturn(this, _Node.call(this, defaults));\n\n          _this.type = 'decl';\n          return _this;\n        }\n\n        _createClass(Declaration, [{\n          key: '_value',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');\n            return this.raws.value;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#_value was deprecated. Use Node#raws.value');\n            this.raws.value = val;\n          }\n        }, {\n          key: '_important',\n          get: function get() {\n            (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');\n            return this.raws.important;\n          },\n          set: function set(val) {\n            (0, _warnOnce2.default)('Node#_important was deprecated. Use Node#raws.important');\n            this.raws.important = val;\n          }\n          /**\n           * @memberof Declaration#\n           * @member {string} prop - the declarations property name\n           *\n           * @example\n           * const root = postcss.parse('a { color: black }');\n           * const decl = root.first.first;\n           * decl.prop //=> 'color'\n           */\n\n          /**\n           * @memberof Declaration#\n           * @member {string} value - the declarations value\n           *\n           * @example\n           * const root = postcss.parse('a { color: black }');\n           * const decl = root.first.first;\n           * decl.value //=> 'black'\n           */\n\n          /**\n           * @memberof Declaration#\n           * @member {boolean} important - `true` if the declaration\n           *                               has an !important annotation.\n           *\n           * @example\n           * const root = postcss.parse('a { color: black !important; color: red }');\n           * root.first.first.important //=> true\n           * root.first.last.important  //=> undefined\n           */\n\n          /**\n           * @memberof Declaration#\n           * @member {object} raws - Information to generate byte-to-byte equal\n           *                         node string as it was in the origin input.\n           *\n           * Every parser saves its own properties,\n           * but the default CSS parser uses:\n           *\n           * * `before`: the space symbols before the node. It also stores `*`\n           *   and `_` symbols before the declaration (IE hack).\n           * * `between`: the symbols between the property and value\n           *   for declarations.\n           * * `important`: the content of the important statement,\n           *   if it is not just `!important`.\n           *\n           * PostCSS cleans declaration from comments and extra spaces,\n           * but it stores origin content in raws properties.\n           * As such, if you dont change a declarations value,\n           * PostCSS will use the raw value with comments.\n           *\n           * @example\n           * const root = postcss.parse('a {\\n  color:black\\n}')\n           * root.first.first.raws //=> { before: '\\n  ', between: ':' }\n           */\n\n        }]);\n\n        return Declaration;\n      }(_node2.default);\n\n      exports.default = Declaration;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 84 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = parse;\n\n      var _parser = __webpack_require__(85);\n\n      var _parser2 = _interopRequireDefault(_parser);\n\n      var _input = __webpack_require__(23);\n\n      var _input2 = _interopRequireDefault(_input);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function parse(css, opts) {\n        if (opts && opts.safe) {\n          throw new Error('Option safe was removed. ' + 'Use parser: require(\"postcss-safe-parser\")');\n        }\n\n        var input = new _input2.default(css, opts);\n        var parser = new _parser2.default(input);\n\n        try {\n          parser.tokenize();\n          parser.loop();\n        } catch (e) {\n          if (e.name === 'CssSyntaxError' && opts && opts.from) {\n            if (/\\.scss$/i.test(opts.from)) {\n              e.message += '\\nYou tried to parse SCSS with ' + 'the standard CSS parser; ' + 'try again with the postcss-scss parser';\n            } else if (/\\.sass/i.test(opts.from)) {\n              e.message += '\\nYou tried to parse Sass with ' + 'the standard CSS parser; ' + 'try again with the postcss-sass parser';\n            } else if (/\\.less$/i.test(opts.from)) {\n              e.message += '\\nYou tried to parse Less with ' + 'the standard CSS parser; ' + 'try again with the postcss-less parser';\n            }\n          }\n\n          throw e;\n        }\n\n        return parser.root;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 85 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _declaration = __webpack_require__(83);\n\n      var _declaration2 = _interopRequireDefault(_declaration);\n\n      var _tokenize = __webpack_require__(76);\n\n      var _tokenize2 = _interopRequireDefault(_tokenize);\n\n      var _comment = __webpack_require__(21);\n\n      var _comment2 = _interopRequireDefault(_comment);\n\n      var _atRule = __webpack_require__(26);\n\n      var _atRule2 = _interopRequireDefault(_atRule);\n\n      var _root = __webpack_require__(27);\n\n      var _root2 = _interopRequireDefault(_root);\n\n      var _rule = __webpack_require__(10);\n\n      var _rule2 = _interopRequireDefault(_rule);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Parser = function () {\n        function Parser(input) {\n          _classCallCheck(this, Parser);\n\n          this.input = input;\n          this.pos = 0;\n          this.root = new _root2.default();\n          this.current = this.root;\n          this.spaces = '';\n          this.semicolon = false;\n          this.root.source = {\n            input: input,\n            start: {\n              line: 1,\n              column: 1\n            }\n          };\n        }\n\n        Parser.prototype.tokenize = function tokenize() {\n          this.tokens = (0, _tokenize2.default)(this.input);\n        };\n\n        Parser.prototype.loop = function loop() {\n          var token = void 0;\n\n          while (this.pos < this.tokens.length) {\n            token = this.tokens[this.pos];\n\n            switch (token[0]) {\n              case 'space':\n              case ';':\n                this.spaces += token[1];\n                break;\n\n              case '}':\n                this.end(token);\n                break;\n\n              case 'comment':\n                this.comment(token);\n                break;\n\n              case 'at-word':\n                this.atrule(token);\n                break;\n\n              case '{':\n                this.emptyRule(token);\n                break;\n\n              default:\n                this.other();\n                break;\n            }\n\n            this.pos += 1;\n          }\n\n          this.endFile();\n        };\n\n        Parser.prototype.comment = function comment(token) {\n          var node = new _comment2.default();\n          this.init(node, token[2], token[3]);\n          node.source.end = {\n            line: token[4],\n            column: token[5]\n          };\n          var text = token[1].slice(2, -2);\n\n          if (/^\\s*$/.test(text)) {\n            node.text = '';\n            node.raws.left = text;\n            node.raws.right = '';\n          } else {\n            var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n            node.text = match[2];\n            node.raws.left = match[1];\n            node.raws.right = match[3];\n          }\n        };\n\n        Parser.prototype.emptyRule = function emptyRule(token) {\n          var node = new _rule2.default();\n          this.init(node, token[2], token[3]);\n          node.selector = '';\n          node.raws.between = '';\n          this.current = node;\n        };\n\n        Parser.prototype.other = function other() {\n          var token = void 0;\n          var end = false;\n          var type = null;\n          var colon = false;\n          var bracket = null;\n          var brackets = [];\n          var start = this.pos;\n\n          while (this.pos < this.tokens.length) {\n            token = this.tokens[this.pos];\n            type = token[0];\n\n            if (type === '(' || type === '[') {\n              if (!bracket) bracket = token;\n              brackets.push(type === '(' ? ')' : ']');\n            } else if (brackets.length === 0) {\n              if (type === ';') {\n                if (colon) {\n                  this.decl(this.tokens.slice(start, this.pos + 1));\n                  return;\n                } else {\n                  break;\n                }\n              } else if (type === '{') {\n                this.rule(this.tokens.slice(start, this.pos + 1));\n                return;\n              } else if (type === '}') {\n                this.pos -= 1;\n                end = true;\n                break;\n              } else if (type === ':') {\n                colon = true;\n              }\n            } else if (type === brackets[brackets.length - 1]) {\n              brackets.pop();\n              if (brackets.length === 0) bracket = null;\n            }\n\n            this.pos += 1;\n          }\n\n          if (this.pos === this.tokens.length) {\n            this.pos -= 1;\n            end = true;\n          }\n\n          if (brackets.length > 0) this.unclosedBracket(bracket);\n\n          if (end && colon) {\n            while (this.pos > start) {\n              token = this.tokens[this.pos][0];\n              if (token !== 'space' && token !== 'comment') break;\n              this.pos -= 1;\n            }\n\n            this.decl(this.tokens.slice(start, this.pos + 1));\n            return;\n          }\n\n          this.unknownWord(start);\n        };\n\n        Parser.prototype.rule = function rule(tokens) {\n          tokens.pop();\n          var node = new _rule2.default();\n          this.init(node, tokens[0][2], tokens[0][3]);\n          node.raws.between = this.spacesAndCommentsFromEnd(tokens);\n          this.raw(node, 'selector', tokens);\n          this.current = node;\n        };\n\n        Parser.prototype.decl = function decl(tokens) {\n          var node = new _declaration2.default();\n          this.init(node);\n          var last = tokens[tokens.length - 1];\n\n          if (last[0] === ';') {\n            this.semicolon = true;\n            tokens.pop();\n          }\n\n          if (last[4]) {\n            node.source.end = {\n              line: last[4],\n              column: last[5]\n            };\n          } else {\n            node.source.end = {\n              line: last[2],\n              column: last[3]\n            };\n          }\n\n          while (tokens[0][0] !== 'word') {\n            node.raws.before += tokens.shift()[1];\n          }\n\n          node.source.start = {\n            line: tokens[0][2],\n            column: tokens[0][3]\n          };\n          node.prop = '';\n\n          while (tokens.length) {\n            var type = tokens[0][0];\n\n            if (type === ':' || type === 'space' || type === 'comment') {\n              break;\n            }\n\n            node.prop += tokens.shift()[1];\n          }\n\n          node.raws.between = '';\n          var token = void 0;\n\n          while (tokens.length) {\n            token = tokens.shift();\n\n            if (token[0] === ':') {\n              node.raws.between += token[1];\n              break;\n            } else {\n              node.raws.between += token[1];\n            }\n          }\n\n          if (node.prop[0] === '_' || node.prop[0] === '*') {\n            node.raws.before += node.prop[0];\n            node.prop = node.prop.slice(1);\n          }\n\n          node.raws.between += this.spacesAndCommentsFromStart(tokens);\n          this.precheckMissedSemicolon(tokens);\n\n          for (var i = tokens.length - 1; i > 0; i--) {\n            token = tokens[i];\n\n            if (token[1] === '!important') {\n              node.important = true;\n              var string = this.stringFrom(tokens, i);\n              string = this.spacesFromEnd(tokens) + string;\n              if (string !== ' !important') node.raws.important = string;\n              break;\n            } else if (token[1] === 'important') {\n              var cache = tokens.slice(0);\n              var str = '';\n\n              for (var j = i; j > 0; j--) {\n                var _type = cache[j][0];\n\n                if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n                  break;\n                }\n\n                str = cache.pop()[1] + str;\n              }\n\n              if (str.trim().indexOf('!') === 0) {\n                node.important = true;\n                node.raws.important = str;\n                tokens = cache;\n              }\n            }\n\n            if (token[0] !== 'space' && token[0] !== 'comment') {\n              break;\n            }\n          }\n\n          this.raw(node, 'value', tokens);\n          if (node.value.indexOf(':') !== -1) this.checkMissedSemicolon(tokens);\n        };\n\n        Parser.prototype.atrule = function atrule(token) {\n          var node = new _atRule2.default();\n          node.name = token[1].slice(1);\n\n          if (node.name === '') {\n            this.unnamedAtrule(node, token);\n          }\n\n          this.init(node, token[2], token[3]);\n          var last = false;\n          var open = false;\n          var params = [];\n          this.pos += 1;\n\n          while (this.pos < this.tokens.length) {\n            token = this.tokens[this.pos];\n\n            if (token[0] === ';') {\n              node.source.end = {\n                line: token[2],\n                column: token[3]\n              };\n              this.semicolon = true;\n              break;\n            } else if (token[0] === '{') {\n              open = true;\n              break;\n            } else if (token[0] === '}') {\n              this.end(token);\n              break;\n            } else {\n              params.push(token);\n            }\n\n            this.pos += 1;\n          }\n\n          if (this.pos === this.tokens.length) {\n            last = true;\n          }\n\n          node.raws.between = this.spacesAndCommentsFromEnd(params);\n\n          if (params.length) {\n            node.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node, 'params', params);\n\n            if (last) {\n              token = params[params.length - 1];\n              node.source.end = {\n                line: token[4],\n                column: token[5]\n              };\n              this.spaces = node.raws.between;\n              node.raws.between = '';\n            }\n          } else {\n            node.raws.afterName = '';\n            node.params = '';\n          }\n\n          if (open) {\n            node.nodes = [];\n            this.current = node;\n          }\n        };\n\n        Parser.prototype.end = function end(token) {\n          if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n          }\n\n          this.semicolon = false;\n          this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n          this.spaces = '';\n\n          if (this.current.parent) {\n            this.current.source.end = {\n              line: token[2],\n              column: token[3]\n            };\n            this.current = this.current.parent;\n          } else {\n            this.unexpectedClose(token);\n          }\n        };\n\n        Parser.prototype.endFile = function endFile() {\n          if (this.current.parent) this.unclosedBlock();\n\n          if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n          }\n\n          this.current.raws.after = (this.current.raws.after || '') + this.spaces;\n        }; // Helpers\n\n\n        Parser.prototype.init = function init(node, line, column) {\n          this.current.push(node);\n          node.source = {\n            start: {\n              line: line,\n              column: column\n            },\n            input: this.input\n          };\n          node.raws.before = this.spaces;\n          this.spaces = '';\n          if (node.type !== 'comment') this.semicolon = false;\n        };\n\n        Parser.prototype.raw = function raw(node, prop, tokens) {\n          var token = void 0,\n              type = void 0;\n          var length = tokens.length;\n          var value = '';\n          var clean = true;\n\n          for (var i = 0; i < length; i += 1) {\n            token = tokens[i];\n            type = token[0];\n\n            if (type === 'comment' || type === 'space' && i === length - 1) {\n              clean = false;\n            } else {\n              value += token[1];\n            }\n          }\n\n          if (!clean) {\n            var raw = tokens.reduce(function (all, i) {\n              return all + i[1];\n            }, '');\n            node.raws[prop] = {\n              value: value,\n              raw: raw\n            };\n          }\n\n          node[prop] = value;\n        };\n\n        Parser.prototype.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n          var lastTokenType = void 0;\n          var spaces = '';\n\n          while (tokens.length) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space' && lastTokenType !== 'comment') break;\n            spaces = tokens.pop()[1] + spaces;\n          }\n\n          return spaces;\n        };\n\n        Parser.prototype.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n          var next = void 0;\n          var spaces = '';\n\n          while (tokens.length) {\n            next = tokens[0][0];\n            if (next !== 'space' && next !== 'comment') break;\n            spaces += tokens.shift()[1];\n          }\n\n          return spaces;\n        };\n\n        Parser.prototype.spacesFromEnd = function spacesFromEnd(tokens) {\n          var lastTokenType = void 0;\n          var spaces = '';\n\n          while (tokens.length) {\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== 'space') break;\n            spaces = tokens.pop()[1] + spaces;\n          }\n\n          return spaces;\n        };\n\n        Parser.prototype.stringFrom = function stringFrom(tokens, from) {\n          var result = '';\n\n          for (var i = from; i < tokens.length; i++) {\n            result += tokens[i][1];\n          }\n\n          tokens.splice(from, tokens.length - from);\n          return result;\n        };\n\n        Parser.prototype.colon = function colon(tokens) {\n          var brackets = 0;\n          var token = void 0,\n              type = void 0,\n              prev = void 0;\n\n          for (var i = 0; i < tokens.length; i++) {\n            token = tokens[i];\n            type = token[0];\n\n            if (type === '(') {\n              brackets += 1;\n            } else if (type === ')') {\n              brackets -= 1;\n            } else if (brackets === 0 && type === ':') {\n              if (!prev) {\n                this.doubleColon(token);\n              } else if (prev[0] === 'word' && prev[1] === 'progid') {\n                continue;\n              } else {\n                return i;\n              }\n            }\n\n            prev = token;\n          }\n\n          return false;\n        }; // Errors\n\n\n        Parser.prototype.unclosedBracket = function unclosedBracket(bracket) {\n          throw this.input.error('Unclosed bracket', bracket[2], bracket[3]);\n        };\n\n        Parser.prototype.unknownWord = function unknownWord(start) {\n          var token = this.tokens[start];\n          throw this.input.error('Unknown word', token[2], token[3]);\n        };\n\n        Parser.prototype.unexpectedClose = function unexpectedClose(token) {\n          throw this.input.error('Unexpected }', token[2], token[3]);\n        };\n\n        Parser.prototype.unclosedBlock = function unclosedBlock() {\n          var pos = this.current.source.start;\n          throw this.input.error('Unclosed block', pos.line, pos.column);\n        };\n\n        Parser.prototype.doubleColon = function doubleColon(token) {\n          throw this.input.error('Double colon', token[2], token[3]);\n        };\n\n        Parser.prototype.unnamedAtrule = function unnamedAtrule(node, token) {\n          throw this.input.error('At-rule without name', token[2], token[3]);\n        };\n\n        Parser.prototype.precheckMissedSemicolon = function precheckMissedSemicolon(tokens) {\n          // Hook for Safe Parser\n          tokens;\n        };\n\n        Parser.prototype.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n          var colon = this.colon(tokens);\n          if (colon === false) return;\n          var founded = 0;\n          var token = void 0;\n\n          for (var j = colon - 1; j >= 0; j--) {\n            token = tokens[j];\n\n            if (token[0] !== 'space') {\n              founded += 1;\n              if (founded === 2) break;\n            }\n          }\n\n          throw this.input.error('Missed semicolon', token[2], token[3]);\n        };\n\n        return Parser;\n      }();\n\n      exports.default = Parser;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 86 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _mapGenerator = __webpack_require__(158);\n\n      var _mapGenerator2 = _interopRequireDefault(_mapGenerator);\n\n      var _stringify2 = __webpack_require__(82);\n\n      var _stringify3 = _interopRequireDefault(_stringify2);\n\n      var _warnOnce = __webpack_require__(4);\n\n      var _warnOnce2 = _interopRequireDefault(_warnOnce);\n\n      var _result = __webpack_require__(159);\n\n      var _result2 = _interopRequireDefault(_result);\n\n      var _parse = __webpack_require__(84);\n\n      var _parse2 = _interopRequireDefault(_parse);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function isPromise(obj) {\n        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.then === 'function';\n      }\n      /**\n       * A Promise proxy for the result of PostCSS transformations.\n       *\n       * A `LazyResult` instance is returned by {@link Processor#process}.\n       *\n       * @example\n       * const lazy = postcss([cssnext]).process(css);\n       */\n\n\n      var LazyResult = function () {\n        function LazyResult(processor, css, opts) {\n          _classCallCheck(this, LazyResult);\n\n          this.stringified = false;\n          this.processed = false;\n          var root = void 0;\n\n          if ((typeof css === 'undefined' ? 'undefined' : _typeof(css)) === 'object' && css.type === 'root') {\n            root = css;\n          } else if (css instanceof LazyResult || css instanceof _result2.default) {\n            root = css.root;\n\n            if (css.map) {\n              if (typeof opts.map === 'undefined') opts.map = {};\n              if (!opts.map.inline) opts.map.inline = false;\n              opts.map.prev = css.map;\n            }\n          } else {\n            var parser = _parse2.default;\n            if (opts.syntax) parser = opts.syntax.parse;\n            if (opts.parser) parser = opts.parser;\n            if (parser.parse) parser = parser.parse;\n\n            try {\n              root = parser(css, opts);\n            } catch (error) {\n              this.error = error;\n            }\n          }\n\n          this.result = new _result2.default(processor, root, opts);\n        }\n        /**\n         * Returns a {@link Processor} instance, which will be used\n         * for CSS transformations.\n         * @type {Processor}\n         */\n\n        /**\n         * Processes input CSS through synchronous plugins\n         * and calls {@link Result#warnings()}.\n         *\n         * @return {Warning[]} warnings from plugins\n         */\n\n\n        LazyResult.prototype.warnings = function warnings() {\n          return this.sync().warnings();\n        };\n        /**\n         * Alias for the {@link LazyResult#css} property.\n         *\n         * @example\n         * lazy + '' === lazy.css;\n         *\n         * @return {string} output CSS\n         */\n\n\n        LazyResult.prototype.toString = function toString() {\n          return this.css;\n        };\n        /**\n         * Processes input CSS through synchronous and asynchronous plugins\n         * and calls `onFulfilled` with a Result instance. If a plugin throws\n         * an error, the `onRejected` callback will be executed.\n         *\n         * It implements standard Promise API.\n         *\n         * @param {onFulfilled} onFulfilled - callback will be executed\n         *                                    when all plugins will finish work\n         * @param {onRejected}  onRejected  - callback will be executed on any error\n         *\n         * @return {Promise} Promise API to make queue\n         *\n         * @example\n         * postcss([cssnext]).process(css).then(result => {\n         *   console.log(result.css);\n         * });\n         */\n\n\n        LazyResult.prototype.then = function then(onFulfilled, onRejected) {\n          return this.async().then(onFulfilled, onRejected);\n        };\n        /**\n         * Processes input CSS through synchronous and asynchronous plugins\n         * and calls onRejected for each error thrown in any plugin.\n         *\n         * It implements standard Promise API.\n         *\n         * @param {onRejected} onRejected - callback will be executed on any error\n         *\n         * @return {Promise} Promise API to make queue\n         *\n         * @example\n         * postcss([cssnext]).process(css).then(result => {\n         *   console.log(result.css);\n         * }).catch(error => {\n         *   console.error(error);\n         * });\n         */\n\n\n        LazyResult.prototype.catch = function _catch(onRejected) {\n          return this.async().catch(onRejected);\n        };\n\n        LazyResult.prototype.handleError = function handleError(error, plugin) {\n          try {\n            this.error = error;\n\n            if (error.name === 'CssSyntaxError' && !error.plugin) {\n              error.plugin = plugin.postcssPlugin;\n              error.setMessage();\n            } else if (plugin.postcssVersion) {\n              var pluginName = plugin.postcssPlugin;\n              var pluginVer = plugin.postcssVersion;\n              var runtimeVer = this.result.processor.version;\n              var a = pluginVer.split('.');\n              var b = runtimeVer.split('.');\n\n              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {\n                (0, _warnOnce2.default)('Your current PostCSS version ' + 'is ' + runtimeVer + ', but ' + pluginName + ' ' + 'uses ' + pluginVer + '. Perhaps this is ' + 'the source of the error below.');\n              }\n            }\n          } catch (err) {\n            if (console && console.error) console.error(err);\n          }\n        };\n\n        LazyResult.prototype.asyncTick = function asyncTick(resolve, reject) {\n          var _this = this;\n\n          if (this.plugin >= this.processor.plugins.length) {\n            this.processed = true;\n            return resolve();\n          }\n\n          try {\n            var plugin = this.processor.plugins[this.plugin];\n            var promise = this.run(plugin);\n            this.plugin += 1;\n\n            if (isPromise(promise)) {\n              promise.then(function () {\n                _this.asyncTick(resolve, reject);\n              }).catch(function (error) {\n                _this.handleError(error, plugin);\n\n                _this.processed = true;\n                reject(error);\n              });\n            } else {\n              this.asyncTick(resolve, reject);\n            }\n          } catch (error) {\n            this.processed = true;\n            reject(error);\n          }\n        };\n\n        LazyResult.prototype.async = function async() {\n          var _this2 = this;\n\n          if (this.processed) {\n            return new Promise(function (resolve, reject) {\n              if (_this2.error) {\n                reject(_this2.error);\n              } else {\n                resolve(_this2.stringify());\n              }\n            });\n          }\n\n          if (this.processing) {\n            return this.processing;\n          }\n\n          this.processing = new Promise(function (resolve, reject) {\n            if (_this2.error) return reject(_this2.error);\n            _this2.plugin = 0;\n\n            _this2.asyncTick(resolve, reject);\n          }).then(function () {\n            _this2.processed = true;\n            return _this2.stringify();\n          });\n          return this.processing;\n        };\n\n        LazyResult.prototype.sync = function sync() {\n          if (this.processed) return this.result;\n          this.processed = true;\n\n          if (this.processing) {\n            throw new Error('Use process(css).then(cb) to work with async plugins');\n          }\n\n          if (this.error) throw this.error;\n\n          for (var _iterator = this.result.processor.plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var plugin = _ref;\n            var promise = this.run(plugin);\n\n            if (isPromise(promise)) {\n              throw new Error('Use process(css).then(cb) to work with async plugins');\n            }\n          }\n\n          return this.result;\n        };\n\n        LazyResult.prototype.run = function run(plugin) {\n          this.result.lastPlugin = plugin;\n\n          try {\n            return plugin(this.result.root, this.result);\n          } catch (error) {\n            this.handleError(error, plugin);\n            throw error;\n          }\n        };\n\n        LazyResult.prototype.stringify = function stringify() {\n          if (this.stringified) return this.result;\n          this.stringified = true;\n          this.sync();\n          var opts = this.result.opts;\n          var str = _stringify3.default;\n          if (opts.syntax) str = opts.syntax.stringify;\n          if (opts.stringifier) str = opts.stringifier;\n          if (str.stringify) str = str.stringify;\n          var map = new _mapGenerator2.default(str, this.result.root, this.result.opts);\n          var data = map.generate();\n          this.result.css = data[0];\n          this.result.map = data[1];\n          return this.result;\n        };\n\n        _createClass(LazyResult, [{\n          key: 'processor',\n          get: function get() {\n            return this.result.processor;\n          }\n          /**\n           * Options from the {@link Processor#process} call.\n           * @type {processOptions}\n           */\n\n        }, {\n          key: 'opts',\n          get: function get() {\n            return this.result.opts;\n          }\n          /**\n           * Processes input CSS through synchronous plugins, converts `Root`\n           * to a CSS string and returns {@link Result#css}.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {string}\n           * @see Result#css\n           */\n\n        }, {\n          key: 'css',\n          get: function get() {\n            return this.stringify().css;\n          }\n          /**\n           * An alias for the `css` property. Use it with syntaxes\n           * that generate non-CSS output.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {string}\n           * @see Result#content\n           */\n\n        }, {\n          key: 'content',\n          get: function get() {\n            return this.stringify().content;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#map}.\n           *\n           * This property will only work with synchronous plugins.\n           * If the processor contains any asynchronous plugins\n           * it will throw an error. This is why this method is only\n           * for debug purpose, you should always use {@link LazyResult#then}.\n           *\n           * @type {SourceMapGenerator}\n           * @see Result#map\n           */\n\n        }, {\n          key: 'map',\n          get: function get() {\n            return this.stringify().map;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#root}.\n           *\n           * This property will only work with synchronous plugins. If the processor\n           * contains any asynchronous plugins it will throw an error.\n           *\n           * This is why this method is only for debug purpose,\n           * you should always use {@link LazyResult#then}.\n           *\n           * @type {Root}\n           * @see Result#root\n           */\n\n        }, {\n          key: 'root',\n          get: function get() {\n            return this.sync().root;\n          }\n          /**\n           * Processes input CSS through synchronous plugins\n           * and returns {@link Result#messages}.\n           *\n           * This property will only work with synchronous plugins. If the processor\n           * contains any asynchronous plugins it will throw an error.\n           *\n           * This is why this method is only for debug purpose,\n           * you should always use {@link LazyResult#then}.\n           *\n           * @type {Message[]}\n           * @see Result#messages\n           */\n\n        }, {\n          key: 'messages',\n          get: function get() {\n            return this.sync().messages;\n          }\n        }]);\n\n        return LazyResult;\n      }();\n\n      exports.default = LazyResult;\n      /**\n       * @callback onFulfilled\n       * @param {Result} result\n       */\n\n      /**\n       * @callback onRejected\n       * @param {Error} error\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 87 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      var createError = __webpack_require__(88);\n\n      var parseFrontMatter = __webpack_require__(28);\n\n      var lineColumnToIndex = __webpack_require__(89);\n\n      var _require = __webpack_require__(90),\n          hasPragma = _require.hasPragma; // utils\n\n\n      var utils = __webpack_require__(95);\n\n      var isSCSS = utils.isSCSS;\n      var isSCSSNestedPropertyNode = utils.isSCSSNestedPropertyNode;\n\n      function parseValueNodes(nodes) {\n        var parenGroup = {\n          open: null,\n          close: null,\n          groups: [],\n          type: \"paren_group\"\n        };\n        var parenGroupStack = [parenGroup];\n        var rootParenGroup = parenGroup;\n        var commaGroup = {\n          groups: [],\n          type: \"comma_group\"\n        };\n        var commaGroupStack = [commaGroup];\n\n        for (var i = 0; i < nodes.length; ++i) {\n          var node = nodes[i];\n          var isUnquotedDataURLCall = node.type === \"func\" && node.value === \"url\" && node.group && node.group.groups && node.group.groups[0] && node.group.groups[0].groups && node.group.groups[0].groups.length > 2 && node.group.groups[0].groups[0].type === \"word\" && node.group.groups[0].groups[0].value === \"data\" && node.group.groups[0].groups[1].type === \"colon\" && node.group.groups[0].groups[1].value === \":\";\n\n          if (isUnquotedDataURLCall) {\n            node.group.groups = [stringifyGroup(node)];\n          }\n\n          if (node.type === \"paren\" && node.value === \"(\") {\n            parenGroup = {\n              open: node,\n              close: null,\n              groups: [],\n              type: \"paren_group\"\n            };\n            parenGroupStack.push(parenGroup);\n            commaGroup = {\n              groups: [],\n              type: \"comma_group\"\n            };\n            commaGroupStack.push(commaGroup);\n          } else if (node.type === \"paren\" && node.value === \")\") {\n            if (commaGroup.groups.length) {\n              parenGroup.groups.push(commaGroup);\n            }\n\n            parenGroup.close = node;\n\n            if (commaGroupStack.length === 1) {\n              throw new Error(\"Unbalanced parenthesis\");\n            }\n\n            commaGroupStack.pop();\n            commaGroup = commaGroupStack[commaGroupStack.length - 1];\n            commaGroup.groups.push(parenGroup);\n            parenGroupStack.pop();\n            parenGroup = parenGroupStack[parenGroupStack.length - 1];\n          } else if (node.type === \"comma\") {\n            parenGroup.groups.push(commaGroup);\n            commaGroup = {\n              groups: [],\n              type: \"comma_group\"\n            };\n            commaGroupStack[commaGroupStack.length - 1] = commaGroup;\n          } else {\n            commaGroup.groups.push(node);\n          }\n        }\n\n        if (commaGroup.groups.length > 0) {\n          parenGroup.groups.push(commaGroup);\n        }\n\n        return rootParenGroup;\n      }\n\n      function stringifyGroup(node) {\n        if (node.group) {\n          return stringifyGroup(node.group);\n        }\n\n        if (node.groups) {\n          return node.groups.reduce(function (previousValue, currentValue, index) {\n            return previousValue + stringifyGroup(currentValue) + (currentValue.type === \"comma_group\" && index !== node.groups.length - 1 ? \",\" : \"\");\n          }, \"\");\n        }\n\n        var before = node.raws && node.raws.before ? node.raws.before : \"\";\n        var value = node.value ? node.value : \"\";\n        var unit = node.unit ? node.unit : \"\";\n        var after = node.raws && node.raws.after ? node.raws.after : \"\";\n        return before + value + unit + after;\n      }\n\n      function flattenGroups(node) {\n        if (node.type === \"paren_group\" && !node.open && !node.close && node.groups.length === 1) {\n          return flattenGroups(node.groups[0]);\n        }\n\n        if (node.type === \"comma_group\" && node.groups.length === 1) {\n          return flattenGroups(node.groups[0]);\n        }\n\n        if (node.type === \"paren_group\" || node.type === \"comma_group\") {\n          return Object.assign({}, node, {\n            groups: node.groups.map(flattenGroups)\n          });\n        }\n\n        return node;\n      }\n\n      function addTypePrefix(node, prefix) {\n        if (node && _typeof(node) === \"object\") {\n          delete node.parent;\n\n          for (var key in node) {\n            addTypePrefix(node[key], prefix);\n\n            if (key === \"type\" && typeof node[key] === \"string\") {\n              if (!node[key].startsWith(prefix)) {\n                node[key] = prefix + node[key];\n              }\n            }\n          }\n        }\n\n        return node;\n      }\n\n      function addMissingType(node) {\n        if (node && _typeof(node) === \"object\") {\n          delete node.parent;\n\n          for (var key in node) {\n            addMissingType(node[key]);\n          }\n\n          if (!Array.isArray(node) && node.value && !node.type) {\n            node.type = \"unknown\";\n          }\n        }\n\n        return node;\n      }\n\n      function parseNestedValue(node) {\n        if (node && _typeof(node) === \"object\") {\n          delete node.parent;\n\n          for (var key in node) {\n            parseNestedValue(node[key]);\n\n            if (key === \"nodes\") {\n              node.group = flattenGroups(parseValueNodes(node[key]));\n              delete node[key];\n            }\n          }\n        }\n\n        return node;\n      }\n\n      function parseValue(value) {\n        var valueParser = __webpack_require__(97);\n\n        var result = null;\n\n        try {\n          result = valueParser(value, {\n            loose: true\n          }).parse();\n        } catch (e) {\n          return {\n            type: \"value-unknown\",\n            value: value\n          };\n        }\n\n        var parsedResult = parseNestedValue(result);\n        return addTypePrefix(parsedResult, \"value-\");\n      }\n\n      function parseSelector(selector) {\n        // If there's a comment inside of a selector, the parser tries to parse\n        // the content of the comment as selectors which turns it into complete\n        // garbage. Better to print the whole selector as-is and not try to parse\n        // and reformat it.\n        if (selector.match(/\\/\\/|\\/\\*/)) {\n          return {\n            type: \"selector-unknown\",\n            value: selector.replace(/^ +/, \"\").replace(/ +$/, \"\")\n          };\n        }\n\n        var selectorParser = __webpack_require__(106);\n\n        var result = null;\n\n        try {\n          selectorParser(function (result_) {\n            result = result_;\n          }).process(selector);\n        } catch (e) {\n          // Fail silently. It's better to print it as is than to try and parse it\n          // Note: A common failure is for SCSS nested properties. `background:\n          // none { color: red; }` is parsed as a NestedDeclaration by\n          // postcss-scss, while `background: { color: red; }` is parsed as a Rule\n          // with a selector ending with a colon. See:\n          // https://github.com/postcss/postcss-scss/issues/39\n          return {\n            type: \"selector-unknown\",\n            value: selector\n          };\n        }\n\n        return addTypePrefix(result, \"selector-\");\n      }\n\n      function parseMediaQuery(params) {\n        var mediaParser = __webpack_require__(111).default;\n\n        var result = null;\n\n        try {\n          result = mediaParser(params);\n        } catch (e) {\n          // Ignore bad media queries\n          return {\n            type: \"selector-unknown\",\n            value: params\n          };\n        }\n\n        return addTypePrefix(addMissingType(result), \"media-\");\n      }\n\n      var DEFAULT_SCSS_DIRECTIVE = /(\\s*?)(!default).*$/;\n      var GLOBAL_SCSS_DIRECTIVE = /(\\s*?)(!global).*$/;\n\n      function parseNestedCSS(node) {\n        if (node && _typeof(node) === \"object\") {\n          delete node.parent;\n\n          for (var key in node) {\n            parseNestedCSS(node[key]);\n          }\n\n          if (!node.type) {\n            return node;\n          }\n\n          if (!node.raws) {\n            node.raws = {};\n          }\n\n          var selector = \"\";\n\n          if (typeof node.selector === \"string\") {\n            selector = node.raws.selector ? node.raws.selector.scss ? node.raws.selector.scss : node.raws.selector.raw : node.selector;\n\n            if (node.raws.between && node.raws.between.trim().length > 0) {\n              selector += node.raws.between;\n            }\n\n            node.raws.selector = selector;\n          }\n\n          var value = \"\";\n\n          if (typeof node.value === \"string\") {\n            value = node.raws.value ? node.raws.value.scss ? node.raws.value.scss : node.raws.value.raw : node.value;\n            value = value.trim();\n            node.raws.value = selector;\n          }\n\n          var params = \"\";\n\n          if (typeof node.params === \"string\") {\n            params = node.raws.params ? node.raws.params.scss ? node.raws.params.scss : node.raws.params.raw : node.params;\n\n            if (node.raws.afterName && node.raws.afterName.trim().length > 0) {\n              params = node.raws.afterName + params;\n            }\n\n            if (node.raws.between && node.raws.between.trim().length > 0) {\n              params = params + node.raws.between;\n            }\n\n            params = params.trim();\n            node.raws.params = params;\n          } // Ignore LESS mixin declaration\n\n\n          if (selector.trim().length > 0) {\n            if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {\n              return node;\n            } // Ignore LESS mixins\n\n\n            if (node.mixin) {\n              node.selector = parseValue(selector);\n              return node;\n            } // Check on SCSS nested property\n\n\n            if (isSCSSNestedPropertyNode(node)) {\n              node.isSCSSNesterProperty = true;\n            }\n\n            node.selector = parseSelector(selector);\n            return node;\n          }\n\n          if (value.length > 0) {\n            var defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);\n\n            if (defaultSCSSDirectiveIndex) {\n              value = value.substring(0, defaultSCSSDirectiveIndex.index);\n              node.scssDefault = true;\n\n              if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {\n                node.raws.scssDefault = defaultSCSSDirectiveIndex[0];\n              }\n            }\n\n            var globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);\n\n            if (globalSCSSDirectiveIndex) {\n              value = value.substring(0, globalSCSSDirectiveIndex.index);\n              node.scssGlobal = true;\n\n              if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {\n                node.raws.scssGlobal = globalSCSSDirectiveIndex[0];\n              }\n            }\n\n            if (value.startsWith(\"progid:\")) {\n              return {\n                type: \"value-unknown\",\n                value: value\n              };\n            }\n\n            node.value = parseValue(value);\n          }\n\n          if (node.type === \"css-atrule\" && params.length > 0) {\n            var name = node.name;\n            var lowercasedName = node.name.toLowerCase();\n\n            if (name === \"warn\" || name === \"error\") {\n              node.params = {\n                type: \"media-unknown\",\n                value: params\n              };\n              return node;\n            }\n\n            if (name === \"extend\" || name === \"nest\") {\n              node.selector = parseSelector(params);\n              delete node.params;\n              return node;\n            }\n\n            if (name === \"at-root\") {\n              if (/^\\(\\s*(without|with)\\s*:[\\s\\S]+\\)$/.test(params)) {\n                node.params = parseValue(params);\n              } else {\n                node.selector = parseSelector(params);\n                delete node.params;\n              }\n\n              return node;\n            }\n\n            if (lowercasedName === \"import\") {\n              node.params = parseValue(params);\n              return node;\n            }\n\n            if ([\"namespace\", \"supports\", \"if\", \"else\", \"for\", \"each\", \"while\", \"debug\", \"mixin\", \"include\", \"function\", \"return\", \"define-mixin\", \"add-mixin\"].indexOf(name) !== -1) {\n              // Remove unnecessary spaces in SCSS variable arguments\n              params = params.replace(/(\\$\\S+?)\\s+?\\.\\.\\./, \"$1...\"); // Remove unnecessary spaces before SCSS control, mixin and function directives\n\n              params = params.replace(/^(?!if)(\\S+)\\s+\\(/, \"$1(\");\n              node.value = parseValue(params);\n              delete node.params;\n              return node;\n            }\n\n            if (name === \"custom-selector\") {\n              var customSelector = params.match(/:--\\S+?\\s+/)[0].trim();\n              node.customSelector = customSelector;\n              node.selector = parseSelector(params.substring(customSelector.length));\n              delete node.params;\n              return node;\n            }\n\n            if ([\"media\", \"custom-media\"].indexOf(lowercasedName) !== -1) {\n              if (params.includes(\"#{\")) {\n                // Workaround for media at rule with scss interpolation\n                return {\n                  type: \"media-unknown\",\n                  value: params\n                };\n              }\n\n              node.params = parseMediaQuery(params);\n              return node;\n            }\n\n            node.params = params;\n            return node;\n          }\n        }\n\n        return node;\n      }\n\n      function parseWithParser(parser, text) {\n        var parsed = parseFrontMatter(text);\n        var frontMatter = parsed.frontMatter;\n        text = parsed.content;\n        var result;\n\n        try {\n          result = parser.parse(text);\n        } catch (e) {\n          if (typeof e.line !== \"number\") {\n            throw e;\n          }\n\n          throw createError(\"(postcss) \" + e.name + \" \" + e.reason, {\n            start: e\n          });\n        }\n\n        result = parseNestedCSS(addTypePrefix(result, \"css-\"));\n\n        if (frontMatter) {\n          result.nodes.unshift(frontMatter);\n        }\n\n        return result;\n      }\n\n      function requireParser(isSCSSParser) {\n        if (isSCSSParser) {\n          return __webpack_require__(113);\n        } // TODO: Remove this hack when this issue is fixed:\n        // https://github.com/shellscape/postcss-less/issues/88\n\n\n        var LessParser = __webpack_require__(72);\n\n        LessParser.prototype.atrule = function () {\n          return Object.getPrototypeOf(LessParser.prototype).atrule.apply(this, arguments);\n        };\n\n        return __webpack_require__(182);\n      }\n\n      function parse(text, parsers, opts) {\n        var hasExplicitParserChoice = opts.parser === \"less\" || opts.parser === \"scss\";\n        var isSCSSParser = isSCSS(opts.parser, text);\n\n        try {\n          return parseWithParser(requireParser(isSCSSParser), text);\n        } catch (originalError) {\n          if (hasExplicitParserChoice) {\n            throw originalError;\n          }\n\n          try {\n            return parseWithParser(requireParser(!isSCSSParser), text);\n          } catch (_secondError) {\n            throw originalError;\n          }\n        }\n      }\n\n      var parser = {\n        parse: parse,\n        astFormat: \"postcss\",\n        hasPragma: hasPragma,\n        locStart: function locStart(node) {\n          if (node.source) {\n            return lineColumnToIndex(node.source.start, node.source.input.css) - 1;\n          }\n\n          return null;\n        },\n        locEnd: function locEnd(node) {\n          var endNode = node.nodes && node.nodes[node.nodes.length - 1];\n\n          if (endNode && node.source && !node.source.end) {\n            node = endNode;\n          }\n\n          if (node.source && node.source.end) {\n            return lineColumnToIndex(node.source.end, node.source.input.css);\n          }\n\n          return null;\n        }\n      }; // Export as a plugin so we can reuse the same bundle for UMD loading\n\n      module.exports = {\n        parsers: {\n          css: parser,\n          less: parser,\n          scss: parser\n        }\n      };\n      /***/\n    },\n    /* 88 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function createError(message, loc) {\n        // Construct an error similar to the ones thrown by Babel.\n        var error = new SyntaxError(message + \" (\" + loc.start.line + \":\" + loc.start.column + \")\");\n        error.loc = loc;\n        return error;\n      }\n\n      module.exports = createError;\n      /***/\n    },\n    /* 89 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\"; // Super inefficient, needs to be cached.\n\n      module.exports = function (lineColumn, text) {\n        var index = 0;\n\n        for (var i = 0; i < lineColumn.line - 1; ++i) {\n          index = text.indexOf(\"\\n\", index) + 1;\n\n          if (index === -1) {\n            return -1;\n          }\n        }\n\n        return index + lineColumn.column;\n      };\n      /***/\n\n    },\n    /* 90 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var jsPragma = __webpack_require__(91);\n\n      var parseFrontMatter = __webpack_require__(28);\n\n      function hasPragma(text) {\n        return jsPragma.hasPragma(parseFrontMatter(text).content);\n      }\n\n      function insertPragma(text) {\n        var _parseFrontMatter = parseFrontMatter(text),\n            frontMatter = _parseFrontMatter.frontMatter,\n            content = _parseFrontMatter.content;\n\n        return (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") + jsPragma.insertPragma(content);\n      }\n\n      module.exports = {\n        hasPragma: hasPragma,\n        insertPragma: insertPragma\n      };\n      /***/\n    },\n    /* 91 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var docblock = __webpack_require__(92);\n\n      function hasPragma(text) {\n        var pragmas = Object.keys(docblock.parse(docblock.extract(text)));\n        return pragmas.indexOf(\"prettier\") !== -1 || pragmas.indexOf(\"format\") !== -1;\n      }\n\n      function insertPragma(text) {\n        var parsedDocblock = docblock.parseWithComments(docblock.extract(text));\n        var pragmas = Object.assign({\n          format: \"\"\n        }, parsedDocblock.pragmas);\n        var newDocblock = docblock.print({\n          pragmas: pragmas,\n          comments: parsedDocblock.comments.replace(/^(\\s+?\\r?\\n)+/, \"\") // remove leading newlines\n\n        }).replace(/(\\r\\n|\\r)/g, \"\\n\"); // normalise newlines (mitigate use of os.EOL by jest-docblock)\n\n        var strippedText = docblock.strip(text);\n        var separatingNewlines = strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\";\n        return newDocblock + separatingNewlines + strippedText;\n      }\n\n      module.exports = {\n        hasPragma: hasPragma,\n        insertPragma: insertPragma\n      };\n      /***/\n    },\n    /* 92 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      exports.extract = extract;\n      exports.strip = strip;\n      exports.parse = parse;\n      exports.parseWithComments = parseWithComments;\n      exports.print = print;\n\n      var _detectNewline;\n\n      function _load_detectNewline() {\n        return _detectNewline = _interopRequireDefault(__webpack_require__(93));\n      }\n\n      var _os;\n\n      function _load_os() {\n        return _os = __webpack_require__(94);\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      /**\n       * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n       *\n       * This source code is licensed under the MIT license found in the\n       * LICENSE file in the root directory of this source tree.\n       *\n       *\n       */\n\n\n      var commentEndRe = /\\*\\/$/;\n      var commentStartRe = /^\\/\\*\\*/;\n      var docblockRe = /^\\s*(\\/\\*\\*?(.|\\r?\\n)*?\\*\\/)/;\n      var lineCommentRe = /(^|\\s+)\\/\\/([^\\r\\n]*)/g;\n      var ltrimNewlineRe = /^(\\r?\\n)+/;\n      var multilineRe = /(?:^|\\r?\\n) *(@[^\\r\\n]*?) *\\r?\\n *(?![^@\\r\\n]*\\/\\/[^]*)([^@\\r\\n\\s][^@\\r\\n]+?) *\\r?\\n/g;\n      var propertyRe = /(?:^|\\r?\\n) *@(\\S+) *([^\\r\\n]*)/g;\n      var stringStartRe = /(\\r?\\n|^) *\\* ?/g;\n\n      function extract(contents) {\n        var match = contents.match(docblockRe);\n        return match ? match[0].trimLeft() : '';\n      }\n\n      function strip(contents) {\n        var match = contents.match(docblockRe);\n        return match && match[0] ? contents.substring(match[0].length) : contents;\n      }\n\n      function parse(docblock) {\n        return parseWithComments(docblock).pragmas;\n      }\n\n      function parseWithComments(docblock) {\n        var line = (0, (_detectNewline || _load_detectNewline()).default)(docblock) || (_os || _load_os()).EOL;\n\n        docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives\n\n        var prev = '';\n\n        while (prev !== docblock) {\n          prev = docblock;\n          docblock = docblock.replace(multilineRe, \"\".concat(line, \"$1 $2\").concat(line));\n        }\n\n        docblock = docblock.replace(ltrimNewlineRe, '').trimRight();\n        var result = Object.create(null);\n        var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();\n        var match;\n\n        while (match = propertyRe.exec(docblock)) {\n          // strip linecomments from pragmas\n          var nextPragma = match[2].replace(lineCommentRe, '');\n\n          if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {\n            result[match[1]] = [].concat(result[match[1]], nextPragma);\n          } else {\n            result[match[1]] = nextPragma;\n          }\n        }\n\n        return {\n          comments: comments,\n          pragmas: result\n        };\n      }\n\n      function print(_ref) {\n        var _ref$comments = _ref.comments;\n        var comments = _ref$comments === undefined ? '' : _ref$comments;\n        var _ref$pragmas = _ref.pragmas;\n        var pragmas = _ref$pragmas === undefined ? {} : _ref$pragmas;\n\n        var line = (0, (_detectNewline || _load_detectNewline()).default)(comments) || (_os || _load_os()).EOL;\n\n        var head = '/**';\n        var start = ' *';\n        var tail = ' */';\n        var keys = Object.keys(pragmas);\n        var printedObject = keys.map(function (key) {\n          return printKeyValues(key, pragmas[key]);\n        }).reduce(function (arr, next) {\n          return arr.concat(next);\n        }, []).map(function (keyValue) {\n          return start + ' ' + keyValue + line;\n        }).join('');\n\n        if (!comments) {\n          if (keys.length === 0) {\n            return '';\n          }\n\n          if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {\n            var value = pragmas[keys[0]];\n            return \"\".concat(head, \" \").concat(printKeyValues(keys[0], value)[0]).concat(tail);\n          }\n        }\n\n        var printedComments = comments.split(line).map(function (textLine) {\n          return \"\".concat(start, \" \").concat(textLine);\n        }).join(line) + line;\n        return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;\n      }\n\n      function printKeyValues(key, valueOrArray) {\n        return [].concat(valueOrArray).map(function (value) {\n          return \"@\".concat(key, \" \").concat(value).trim();\n        });\n      }\n      /***/\n\n    },\n    /* 93 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = function (str) {\n        if (typeof str !== 'string') {\n          throw new TypeError('Expected a string');\n        }\n\n        var newlines = str.match(/(?:\\r?\\n)/g) || [];\n\n        if (newlines.length === 0) {\n          return null;\n        }\n\n        var crlf = newlines.filter(function (el) {\n          return el === '\\r\\n';\n        }).length;\n        var lf = newlines.length - crlf;\n        return crlf > lf ? '\\r\\n' : '\\n';\n      };\n\n      module.exports.graceful = function (str) {\n        return module.exports(str) || '\\n';\n      };\n      /***/\n\n    },\n    /* 94 */\n\n    /***/\n    function (module, exports) {\n      exports.endianness = function () {\n        return 'LE';\n      };\n\n      exports.hostname = function () {\n        if (typeof location !== 'undefined') {\n          return location.hostname;\n        } else return '';\n      };\n\n      exports.loadavg = function () {\n        return [];\n      };\n\n      exports.uptime = function () {\n        return 0;\n      };\n\n      exports.freemem = function () {\n        return Number.MAX_VALUE;\n      };\n\n      exports.totalmem = function () {\n        return Number.MAX_VALUE;\n      };\n\n      exports.cpus = function () {\n        return [];\n      };\n\n      exports.type = function () {\n        return 'Browser';\n      };\n\n      exports.release = function () {\n        if (typeof navigator !== 'undefined') {\n          return navigator.appVersion;\n        }\n\n        return '';\n      };\n\n      exports.networkInterfaces = exports.getNetworkInterfaces = function () {\n        return {};\n      };\n\n      exports.arch = function () {\n        return 'javascript';\n      };\n\n      exports.platform = function () {\n        return 'browser';\n      };\n\n      exports.tmpdir = exports.tmpDir = function () {\n        return '/tmp';\n      };\n\n      exports.EOL = '\\n';\n      /***/\n    },\n    /* 95 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var htmlTagNames = __webpack_require__(96);\n\n      var colorAdjusterFunctions = [\"red\", \"green\", \"blue\", \"alpha\", \"a\", \"rgb\", \"hue\", \"h\", \"saturation\", \"s\", \"lightness\", \"l\", \"whiteness\", \"w\", \"blackness\", \"b\", \"tint\", \"shade\", \"blend\", \"blenda\", \"contrast\", \"hsl\", \"hsla\", \"hwb\", \"hwba\"];\n\n      function getAncestorCounter(path, typeOrTypes) {\n        var types = [].concat(typeOrTypes);\n        var counter = -1;\n        var ancestorNode;\n\n        while (ancestorNode = path.getParentNode(++counter)) {\n          if (types.indexOf(ancestorNode.type) !== -1) {\n            return counter;\n          }\n        }\n\n        return -1;\n      }\n\n      function getAncestorNode(path, typeOrTypes) {\n        var counter = getAncestorCounter(path, typeOrTypes);\n        return counter === -1 ? null : path.getParentNode(counter);\n      }\n\n      function getPropOfDeclNode(path) {\n        var declAncestorNode = getAncestorNode(path, \"css-decl\");\n        return declAncestorNode && declAncestorNode.prop && declAncestorNode.prop.toLowerCase();\n      }\n\n      function isSCSS(parser, text) {\n        var hasExplicitParserChoice = parser === \"less\" || parser === \"scss\";\n        var IS_POSSIBLY_SCSS = /(\\w\\s*: [^}:]+|#){|@import[^\\n]+(url|,)/;\n        return hasExplicitParserChoice ? parser === \"scss\" : IS_POSSIBLY_SCSS.test(text);\n      }\n\n      function isWideKeywords(value) {\n        return [\"initial\", \"inherit\", \"unset\", \"revert\"].indexOf(value.toLowerCase()) !== -1;\n      }\n\n      function isKeyframeAtRuleKeywords(path, value) {\n        var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n        return atRuleAncestorNode && atRuleAncestorNode.name && atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") && [\"from\", \"to\"].indexOf(value.toLowerCase()) !== -1;\n      }\n\n      function maybeToLowerCase(value) {\n        return value.includes(\"$\") || value.includes(\"@\") || value.includes(\"#\") || value.startsWith(\"%\") || value.startsWith(\"--\") || value.startsWith(\":--\") || value.includes(\"(\") && value.includes(\")\") ? value : value.toLowerCase();\n      }\n\n      function insideValueFunctionNode(path, functionName) {\n        var funcAncestorNode = getAncestorNode(path, \"value-func\");\n        return funcAncestorNode && funcAncestorNode.value && funcAncestorNode.value.toLowerCase() === functionName;\n      }\n\n      function insideICSSRuleNode(path) {\n        var ruleAncestorNode = getAncestorNode(path, \"css-rule\");\n        return ruleAncestorNode && ruleAncestorNode.raws && ruleAncestorNode.raws.selector && (ruleAncestorNode.raws.selector.startsWith(\":import\") || ruleAncestorNode.raws.selector.startsWith(\":export\"));\n      }\n\n      function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {\n        var atRuleNames = [].concat(atRuleNameOrAtRuleNames);\n        var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n        return atRuleAncestorNode && atRuleNames.indexOf(atRuleAncestorNode.name.toLowerCase()) !== -1;\n      }\n\n      function insideURLFunctionInImportAtRuleNode(path) {\n        var node = path.getValue();\n        var atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");\n        return atRuleAncestorNode && atRuleAncestorNode.name === \"import\" && node.groups[0].value === \"url\" && node.groups.length === 2;\n      }\n\n      function isURLFunctionNode(node) {\n        return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";\n      }\n\n      function isLastNode(path, node) {\n        var parentNode = path.getParentNode();\n\n        if (!parentNode) {\n          return false;\n        }\n\n        var nodes = parentNode.nodes;\n        return nodes && nodes.indexOf(node) === nodes.length - 1;\n      }\n\n      function isHTMLTag(value) {\n        return htmlTagNames.indexOf(value.toLowerCase()) !== -1;\n      }\n\n      function isDetachedRulesetDeclarationNode(node) {\n        // If a Less file ends up being parsed with the SCSS parser, Less\n        // variable declarations will be parsed as atrules with names ending\n        // with a colon, so keep the original case then.\n        if (!node.selector) {\n          return false;\n        }\n\n        return typeof node.selector === \"string\" && /^@.+:.*$/.test(node.selector) || node.selector.value && /^@.+:.*$/.test(node.selector.value);\n      }\n\n      function isForKeywordNode(node) {\n        return node.type === \"value-word\" && [\"from\", \"through\", \"end\"].indexOf(node.value) !== -1;\n      }\n\n      function isIfElseKeywordNode(node) {\n        return node.type === \"value-word\" && [\"and\", \"or\", \"not\"].indexOf(node.value) !== -1;\n      }\n\n      function isEachKeywordNode(node) {\n        return node.type === \"value-word\" && node.value === \"in\";\n      }\n\n      function isMultiplicationNode(node) {\n        return node.type === \"value-operator\" && node.value === \"*\";\n      }\n\n      function isDivisionNode(node) {\n        return node.type === \"value-operator\" && node.value === \"/\";\n      }\n\n      function isAdditionNode(node) {\n        return node.type === \"value-operator\" && node.value === \"+\";\n      }\n\n      function isSubtractionNode(node) {\n        return node.type === \"value-operator\" && node.value === \"-\";\n      }\n\n      function isModuloNode(node) {\n        return node.type === \"value-operator\" && node.value === \"%\";\n      }\n\n      function isMathOperatorNode(node) {\n        return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);\n      }\n\n      function isEqualityOperatorNode(node) {\n        return node.type === \"value-word\" && [\"==\", \"!=\"].indexOf(node.value) !== -1;\n      }\n\n      function isRelationalOperatorNode(node) {\n        return node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].indexOf(node.value) !== -1;\n      }\n\n      function isSCSSControlDirectiveNode(node) {\n        return node.type === \"css-atrule\" && [\"if\", \"else\", \"for\", \"each\", \"while\"].indexOf(node.name) !== -1;\n      }\n\n      function isSCSSNestedPropertyNode(node) {\n        if (!node.selector) {\n          return false;\n        }\n\n        return node.selector.replace(/\\/\\*.*?\\*\\//, \"\").replace(/\\/\\/.*?\\n/, \"\").trim().endsWith(\":\");\n      }\n\n      function isDetachedRulesetCallNode(node) {\n        return node.raws && node.raws.params && /^\\(\\s*\\)$/.test(node.raws.params);\n      }\n\n      function isTemplatePlaceholderNode(node) {\n        return node.name.startsWith(\"prettier-placeholder\");\n      }\n\n      function isTemplatePropNode(node) {\n        return node.prop.startsWith(\"@prettier-placeholder\");\n      }\n\n      function isPostcssSimpleVarNode(currentNode, nextNode) {\n        return currentNode.value === \"$$\" && currentNode.type === \"value-func\" && nextNode && nextNode.type === \"value-word\" && !nextNode.raws.before;\n      }\n\n      function hasComposesNode(node) {\n        return node.value && node.value.type === \"value-root\" && node.value.group && node.value.group.type === \"value-value\" && node.prop.toLowerCase() === \"composes\";\n      }\n\n      function hasParensAroundNode(node) {\n        return node.value && node.value.group && node.value.group.group && node.value.group.group.type === \"value-paren_group\" && node.value.group.group.open !== null && node.value.group.group.close !== null;\n      }\n\n      function hasEmptyRawBefore(node) {\n        return node.raws && node.raws.before === \"\";\n      }\n\n      function isKeyValuePairNode(node) {\n        return node.type === \"value-comma_group\" && node.groups && node.groups[1] && node.groups[1].type === \"value-colon\";\n      }\n\n      function isKeyValuePairInParenGroupNode(node) {\n        return node.type === \"value-paren_group\" && node.groups && node.groups[0] && isKeyValuePairNode(node.groups[0]);\n      }\n\n      function isSCSSMapItemNode(path) {\n        var node = path.getValue(); // Ignore empty item (i.e. `$key: ()`)\n\n        if (node.groups.length === 0) {\n          return false;\n        }\n\n        var parentParentNode = path.getParentNode(1); // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)\n\n        if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {\n          return false;\n        }\n\n        var declNode = getAncestorNode(path, \"css-decl\"); // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)\n\n        if (declNode && declNode.prop && declNode.prop.startsWith(\"$\")) {\n          return true;\n        } // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)\n\n\n        if (isKeyValuePairInParenGroupNode(parentParentNode)) {\n          return true;\n        } // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)\n\n\n        if (parentParentNode.type === \"value-func\") {\n          return true;\n        }\n\n        return false;\n      }\n\n      function isInlineValueCommentNode(node) {\n        return node.type === \"value-comment\" && node.inline;\n      }\n\n      function isHashNode(node) {\n        return node.type === \"value-word\" && node.value === \"#\";\n      }\n\n      function isLeftCurlyBraceNode(node) {\n        return node.type === \"value-word\" && node.value === \"{\";\n      }\n\n      function isRightCurlyBraceNode(node) {\n        return node.type === \"value-word\" && node.value === \"}\";\n      }\n\n      function isWordNode(node) {\n        return [\"value-word\", \"value-atword\"].indexOf(node.type) !== -1;\n      }\n\n      function isColonNode(node) {\n        return node.type === \"value-colon\";\n      }\n\n      function isMediaAndSupportsKeywords(node) {\n        return node.value && [\"not\", \"and\", \"or\"].indexOf(node.value.toLowerCase()) !== -1;\n      }\n\n      function isColorAdjusterFuncNode(node) {\n        if (node.type !== \"value-func\") {\n          return false;\n        }\n\n        return colorAdjusterFunctions.indexOf(node.value.toLowerCase()) !== -1;\n      }\n\n      module.exports = {\n        getAncestorCounter: getAncestorCounter,\n        getAncestorNode: getAncestorNode,\n        getPropOfDeclNode: getPropOfDeclNode,\n        maybeToLowerCase: maybeToLowerCase,\n        insideValueFunctionNode: insideValueFunctionNode,\n        insideICSSRuleNode: insideICSSRuleNode,\n        insideAtRuleNode: insideAtRuleNode,\n        insideURLFunctionInImportAtRuleNode: insideURLFunctionInImportAtRuleNode,\n        isKeyframeAtRuleKeywords: isKeyframeAtRuleKeywords,\n        isHTMLTag: isHTMLTag,\n        isWideKeywords: isWideKeywords,\n        isSCSS: isSCSS,\n        isLastNode: isLastNode,\n        isSCSSControlDirectiveNode: isSCSSControlDirectiveNode,\n        isDetachedRulesetDeclarationNode: isDetachedRulesetDeclarationNode,\n        isRelationalOperatorNode: isRelationalOperatorNode,\n        isEqualityOperatorNode: isEqualityOperatorNode,\n        isMultiplicationNode: isMultiplicationNode,\n        isDivisionNode: isDivisionNode,\n        isAdditionNode: isAdditionNode,\n        isSubtractionNode: isSubtractionNode,\n        isModuloNode: isModuloNode,\n        isMathOperatorNode: isMathOperatorNode,\n        isEachKeywordNode: isEachKeywordNode,\n        isForKeywordNode: isForKeywordNode,\n        isURLFunctionNode: isURLFunctionNode,\n        isIfElseKeywordNode: isIfElseKeywordNode,\n        hasComposesNode: hasComposesNode,\n        hasParensAroundNode: hasParensAroundNode,\n        hasEmptyRawBefore: hasEmptyRawBefore,\n        isSCSSNestedPropertyNode: isSCSSNestedPropertyNode,\n        isDetachedRulesetCallNode: isDetachedRulesetCallNode,\n        isTemplatePlaceholderNode: isTemplatePlaceholderNode,\n        isTemplatePropNode: isTemplatePropNode,\n        isPostcssSimpleVarNode: isPostcssSimpleVarNode,\n        isKeyValuePairNode: isKeyValuePairNode,\n        isKeyValuePairInParenGroupNode: isKeyValuePairInParenGroupNode,\n        isSCSSMapItemNode: isSCSSMapItemNode,\n        isInlineValueCommentNode: isInlineValueCommentNode,\n        isHashNode: isHashNode,\n        isLeftCurlyBraceNode: isLeftCurlyBraceNode,\n        isRightCurlyBraceNode: isRightCurlyBraceNode,\n        isWordNode: isWordNode,\n        isColonNode: isColonNode,\n        isMediaAndSupportsKeywords: isMediaAndSupportsKeywords,\n        isColorAdjusterFuncNode: isColorAdjusterFuncNode\n      };\n      /***/\n    },\n    /* 96 */\n\n    /***/\n    function (module, exports) {\n      module.exports = [\"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"body\", \"br\", \"button\", \"canvas\", \"caption\", \"center\", \"cite\", \"code\", \"col\", \"colgroup\", \"command\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"i\", \"iframe\", \"image\", \"img\", \"input\", \"ins\", \"isindex\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"listing\", \"main\", \"map\", \"mark\", \"marquee\", \"math\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"multicol\", \"nav\", \"nextid\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"pre\", \"progress\", \"q\", \"rb\", \"rbc\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\", \"section\", \"select\", \"shadow\", \"slot\", \"small\", \"source\", \"spacer\", \"span\", \"strike\", \"strong\", \"style\", \"sub\", \"summary\", \"sup\", \"svg\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"time\", \"title\", \"tr\", \"track\", \"tt\", \"u\", \"ul\", \"var\", \"video\", \"wbr\", \"xmp\"];\n      /***/\n    },\n    /* 97 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var Parser = __webpack_require__(98);\n\n      var AtWord = __webpack_require__(31);\n\n      var Colon = __webpack_require__(32);\n\n      var Comma = __webpack_require__(33);\n\n      var Comment = __webpack_require__(34);\n\n      var Func = __webpack_require__(35);\n\n      var Num = __webpack_require__(36);\n\n      var Operator = __webpack_require__(37);\n\n      var Paren = __webpack_require__(38);\n\n      var Str = __webpack_require__(39);\n\n      var UnicodeRange = __webpack_require__(41);\n\n      var Value = __webpack_require__(30);\n\n      var Word = __webpack_require__(40);\n\n      var parser = function parser(source, options) {\n        return new Parser(source, options);\n      };\n\n      parser.atword = function (opts) {\n        return new AtWord(opts);\n      };\n\n      parser.colon = function (opts) {\n        opts.value = opts.value || ':';\n        return new Colon(opts);\n      };\n\n      parser.comma = function (opts) {\n        opts.value = opts.value || ',';\n        return new Comma(opts);\n      };\n\n      parser.comment = function (opts) {\n        return new Comment(opts);\n      };\n\n      parser.func = function (opts) {\n        return new Func(opts);\n      };\n\n      parser.number = function (opts) {\n        return new Num(opts);\n      };\n\n      parser.operator = function (opts) {\n        return new Operator(opts);\n      };\n\n      parser.paren = function (opts) {\n        opts.value = opts.value || '(';\n        return new Paren(opts);\n      };\n\n      parser.string = function (opts) {\n        opts.quote = opts.quote || '\\'';\n        return new Str(opts);\n      };\n\n      parser.value = function (opts) {\n        return new Value(opts);\n      };\n\n      parser.word = function (opts) {\n        return new Word(opts);\n      };\n\n      parser.unicodeRange = function (opts) {\n        return new UnicodeRange(opts);\n      };\n\n      module.exports = parser;\n      /***/\n    },\n    /* 98 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n\n      var Root = __webpack_require__(99);\n\n      var Value = __webpack_require__(30);\n\n      var AtWord = __webpack_require__(31);\n\n      var Colon = __webpack_require__(32);\n\n      var Comma = __webpack_require__(33);\n\n      var Comment = __webpack_require__(34);\n\n      var Func = __webpack_require__(35);\n\n      var Numbr = __webpack_require__(36);\n\n      var Operator = __webpack_require__(37);\n\n      var Paren = __webpack_require__(38);\n\n      var Str = __webpack_require__(39);\n\n      var Word = __webpack_require__(40);\n\n      var UnicodeRange = __webpack_require__(41);\n\n      var tokenize = __webpack_require__(100);\n\n      var flatten = __webpack_require__(42);\n\n      var indexesOf = __webpack_require__(43);\n\n      var uniq = __webpack_require__(44);\n\n      var ParserError = __webpack_require__(105);\n\n      function sortAscending(list) {\n        return list.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      module.exports =\n      /*#__PURE__*/\n      function () {\n        function Parser(input, options) {\n          _classCallCheck(this, Parser);\n\n          var defaults = {\n            loose: false\n          }; // cache needs to be an array for values with more than 1 level of function nesting\n\n          this.cache = [];\n          this.input = input;\n          this.options = Object.assign({}, defaults, options);\n          this.position = 0; // we'll use this to keep track of the paren balance\n\n          this.unbalanced = 0;\n          this.root = new Root();\n          var value = new Value();\n          this.root.append(value);\n          this.current = value;\n          this.tokens = tokenize(input, this.options);\n        }\n\n        _createClass(Parser, [{\n          key: \"parse\",\n          value: function parse() {\n            return this.loop();\n          }\n        }, {\n          key: \"colon\",\n          value: function colon() {\n            var token = this.currToken;\n            this.newNode(new Colon({\n              value: token[1],\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6]\n            }));\n            this.position++;\n          }\n        }, {\n          key: \"comma\",\n          value: function comma() {\n            var token = this.currToken;\n            this.newNode(new Comma({\n              value: token[1],\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6]\n            }));\n            this.position++;\n          }\n        }, {\n          key: \"comment\",\n          value: function comment() {\n            var inline = false,\n                value = this.currToken[1].replace(/\\/\\*|\\*\\//g, ''),\n                node;\n\n            if (this.options.loose && value.startsWith(\"//\")) {\n              value = value.substring(2);\n              inline = true;\n            }\n\n            node = new Comment({\n              value: value,\n              inline: inline,\n              source: {\n                start: {\n                  line: this.currToken[2],\n                  column: this.currToken[3]\n                },\n                end: {\n                  line: this.currToken[4],\n                  column: this.currToken[5]\n                }\n              },\n              sourceIndex: this.currToken[6]\n            });\n            this.newNode(node);\n            this.position++;\n          }\n        }, {\n          key: \"error\",\n          value: function error(message, token) {\n            throw new ParserError(message + \" at line: \".concat(token[2], \", column \").concat(token[3]));\n          }\n        }, {\n          key: \"loop\",\n          value: function loop() {\n            while (this.position < this.tokens.length) {\n              this.parseTokens();\n            }\n\n            if (!this.current.last && this.spaces) {\n              this.current.raws.before += this.spaces;\n            } else if (this.spaces) {\n              this.current.last.raws.after += this.spaces;\n            }\n\n            this.spaces = '';\n            return this.root;\n          }\n        }, {\n          key: \"operator\",\n          value: function operator() {\n            // if a +|- operator is followed by a non-word character (. is allowed) and\n            // is preceded by a non-word character. (5+5)\n            var char = this.currToken[1],\n                node;\n\n            if (char === '+' || char === '-') {\n              // only inspect if the operator is not the first token, and we're only\n              // within a calc() function: the only spec-valid place for math expressions\n              if (!this.options.loose) {\n                if (this.position > 0) {\n                  if (this.current.type === 'func' && this.current.value === 'calc') {\n                    // allow operators to be proceeded by spaces and opening parens\n                    if (this.prevToken[0] !== 'space' && this.prevToken[0] !== '(') {\n                      this.error('Syntax Error', this.currToken);\n                    } // valid: calc(1 - +2)\n                    // invalid: calc(1 -+2)\n                    else if (this.nextToken[0] !== 'space' && this.nextToken[0] !== 'word') {\n                        this.error('Syntax Error', this.currToken);\n                      } // valid: calc(1 - +2)\n                      // valid: calc(-0.5 + 2)\n                      // invalid: calc(1 -2)\n                      else if (this.nextToken[0] === 'word' && this.current.last.type !== 'operator' && this.current.last.value !== '(') {\n                          this.error('Syntax Error', this.currToken);\n                        }\n                  } // if we're not in a function and someone has doubled up on operators,\n                  // or they're trying to perform a calc outside of a calc\n                  // eg. +-4px or 5+ 5, throw an error\n                  else if (this.nextToken[0] === 'space' || this.nextToken[0] === 'operator' || this.prevToken[0] === 'operator') {\n                      this.error('Syntax Error', this.currToken);\n                    }\n                }\n              }\n\n              if (!this.options.loose) {\n                if (this.nextToken[0] === 'word') {\n                  return this.word();\n                }\n              } else {\n                if ((!this.current.nodes.length || this.current.last && this.current.last.type === 'operator') && this.nextToken[0] === 'word') {\n                  return this.word();\n                }\n              }\n            }\n\n            node = new Operator({\n              value: this.currToken[1],\n              source: {\n                start: {\n                  line: this.currToken[2],\n                  column: this.currToken[3]\n                },\n                end: {\n                  line: this.currToken[2],\n                  column: this.currToken[3]\n                }\n              },\n              sourceIndex: this.currToken[4]\n            });\n            this.position++;\n            return this.newNode(node);\n          }\n        }, {\n          key: \"parseTokens\",\n          value: function parseTokens() {\n            switch (this.currToken[0]) {\n              case 'space':\n                this.space();\n                break;\n\n              case 'colon':\n                this.colon();\n                break;\n\n              case 'comma':\n                this.comma();\n                break;\n\n              case 'comment':\n                this.comment();\n                break;\n\n              case '(':\n                this.parenOpen();\n                break;\n\n              case ')':\n                this.parenClose();\n                break;\n\n              case 'atword':\n              case 'word':\n                this.word();\n                break;\n\n              case 'operator':\n                this.operator();\n                break;\n\n              case 'string':\n                this.string();\n                break;\n\n              case 'unicoderange':\n                this.unicodeRange();\n                break;\n\n              default:\n                this.word();\n                break;\n            }\n          }\n        }, {\n          key: \"parenOpen\",\n          value: function parenOpen() {\n            var unbalanced = 1,\n                pos = this.position + 1,\n                token = this.currToken,\n                last; // check for balanced parens\n\n            while (pos < this.tokens.length && unbalanced) {\n              var tkn = this.tokens[pos];\n\n              if (tkn[0] === '(') {\n                unbalanced++;\n              }\n\n              if (tkn[0] === ')') {\n                unbalanced--;\n              }\n\n              pos++;\n            }\n\n            if (unbalanced) {\n              this.error('Expected closing parenthesis', token);\n            } // ok, all parens are balanced. continue on\n\n\n            last = this.current.last;\n\n            if (last && last.type === 'func' && last.unbalanced < 0) {\n              last.unbalanced = 0; // ok we're ready to add parens now\n\n              this.current = last;\n            }\n\n            this.current.unbalanced++;\n            this.newNode(new Paren({\n              value: token[1],\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6]\n            }));\n            this.position++; // url functions get special treatment, and anything between the function\n            // parens get treated as one word, if the contents aren't not a string.\n\n            if (this.current.type === 'func' && this.current.unbalanced && this.current.value === 'url' && this.currToken[0] !== 'string' && this.currToken[0] !== ')' && !this.options.loose) {\n              var nextToken = this.nextToken,\n                  value = this.currToken[1],\n                  start = {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              };\n\n              while (nextToken && nextToken[0] !== ')' && this.current.unbalanced) {\n                this.position++;\n                value += this.currToken[1];\n                nextToken = this.nextToken;\n              }\n\n              if (this.position !== this.tokens.length - 1) {\n                // skip the following word definition, or it'll be a duplicate\n                this.position++;\n                this.newNode(new Word({\n                  value: value,\n                  source: {\n                    start: start,\n                    end: {\n                      line: this.currToken[4],\n                      column: this.currToken[5]\n                    }\n                  },\n                  sourceIndex: this.currToken[6]\n                }));\n              }\n            }\n          }\n        }, {\n          key: \"parenClose\",\n          value: function parenClose() {\n            var token = this.currToken;\n            this.newNode(new Paren({\n              value: token[1],\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6]\n            }));\n            this.position++;\n\n            if (this.position >= this.tokens.length - 1 && !this.current.unbalanced) {\n              return;\n            }\n\n            this.current.unbalanced--;\n\n            if (this.current.unbalanced < 0) {\n              this.error('Expected opening parenthesis', token);\n            }\n\n            if (!this.current.unbalanced && this.cache.length) {\n              this.current = this.cache.pop();\n            }\n          }\n        }, {\n          key: \"space\",\n          value: function space() {\n            var token = this.currToken; // Handle space before and after the selector\n\n            if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {\n              this.current.last.raws.after += token[1];\n              this.position++;\n            } else {\n              this.spaces = token[1];\n              this.position++;\n            }\n          }\n        }, {\n          key: \"unicodeRange\",\n          value: function unicodeRange() {\n            var token = this.currToken;\n            this.newNode(new UnicodeRange({\n              value: token[1],\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6]\n            }));\n            this.position++;\n          }\n        }, {\n          key: \"splitWord\",\n          value: function splitWord() {\n            var _this = this;\n\n            var nextToken = this.nextToken,\n                word = this.currToken[1],\n                rNumber = /^[\\+\\-]?((\\d+(\\.\\d*)?)|(\\.\\d+))([eE][\\+\\-]?\\d+)?/,\n                // treat css-like groupings differently so they can be inspected,\n            // but don't address them as anything but a word, but allow hex values\n            // to pass through.\n            rNoFollow = /^(?!\\#([a-z0-9]+))[\\#\\{\\}]/gi,\n                hasAt,\n                indices;\n\n            if (!rNoFollow.test(word)) {\n              while (nextToken && nextToken[0] === 'word') {\n                this.position++;\n                var current = this.currToken[1];\n                word += current;\n                nextToken = this.nextToken;\n              }\n            }\n\n            hasAt = indexesOf(word, '@');\n            indices = sortAscending(uniq(flatten([[0], hasAt])));\n            indices.forEach(function (ind, i) {\n              var index = indices[i + 1] || word.length,\n                  value = word.slice(ind, index),\n                  node;\n\n              if (~hasAt.indexOf(ind)) {\n                node = new AtWord({\n                  value: value.slice(1),\n                  source: {\n                    start: {\n                      line: _this.currToken[2],\n                      column: _this.currToken[3] + ind\n                    },\n                    end: {\n                      line: _this.currToken[4],\n                      column: _this.currToken[3] + (index - 1)\n                    }\n                  },\n                  sourceIndex: _this.currToken[6] + indices[i]\n                });\n              } else if (rNumber.test(_this.currToken[1])) {\n                var unit = value.replace(rNumber, '');\n                node = new Numbr({\n                  value: value.replace(unit, ''),\n                  source: {\n                    start: {\n                      line: _this.currToken[2],\n                      column: _this.currToken[3] + ind\n                    },\n                    end: {\n                      line: _this.currToken[4],\n                      column: _this.currToken[3] + (index - 1)\n                    }\n                  },\n                  sourceIndex: _this.currToken[6] + indices[i],\n                  unit: unit\n                });\n              } else {\n                node = new (nextToken && nextToken[0] === '(' ? Func : Word)({\n                  value: value,\n                  source: {\n                    start: {\n                      line: _this.currToken[2],\n                      column: _this.currToken[3] + ind\n                    },\n                    end: {\n                      line: _this.currToken[4],\n                      column: _this.currToken[3] + (index - 1)\n                    }\n                  },\n                  sourceIndex: _this.currToken[6] + indices[i]\n                });\n\n                if (node.constructor.name === 'Word') {\n                  node.isHex = /^#(.+)/.test(value);\n                  node.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(value);\n                } else {\n                  _this.cache.push(_this.current);\n                }\n              }\n\n              _this.newNode(node);\n            });\n            this.position++;\n          }\n        }, {\n          key: \"string\",\n          value: function string() {\n            var token = this.currToken,\n                value = this.currToken[1],\n                rQuote = /^(\\\"|\\')/,\n                quoted = rQuote.test(value),\n                quote = '',\n                node;\n\n            if (quoted) {\n              quote = value.match(rQuote)[0]; // set value to the string within the quotes\n              // quotes are stored in raws\n\n              value = value.slice(1, value.length - 1);\n            }\n\n            node = new Str({\n              value: value,\n              source: {\n                start: {\n                  line: token[2],\n                  column: token[3]\n                },\n                end: {\n                  line: token[4],\n                  column: token[5]\n                }\n              },\n              sourceIndex: token[6],\n              quoted: quoted\n            });\n            node.raws.quote = quote;\n            this.newNode(node);\n            this.position++;\n          }\n        }, {\n          key: \"word\",\n          value: function word() {\n            return this.splitWord();\n          }\n        }, {\n          key: \"newNode\",\n          value: function newNode(node) {\n            if (this.spaces) {\n              node.raws.before += this.spaces;\n              this.spaces = '';\n            }\n\n            return this.current.append(node);\n          }\n        }, {\n          key: \"currToken\",\n          get: function get() {\n            return this.tokens[this.position];\n          }\n        }, {\n          key: \"nextToken\",\n          get: function get() {\n            return this.tokens[this.position + 1];\n          }\n        }, {\n          key: \"prevToken\",\n          get: function get() {\n            return this.tokens[this.position - 1];\n          }\n        }]);\n\n        return Parser;\n      }();\n      /***/\n\n    },\n    /* 99 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      var Container = __webpack_require__(1);\n\n      module.exports =\n      /*#__PURE__*/\n      function (_Container) {\n        _inherits(Root, _Container);\n\n        function Root(opts) {\n          var _this;\n\n          _classCallCheck(this, Root);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(Root).call(this, opts));\n          _this.type = 'root';\n          return _this;\n        }\n\n        return Root;\n      }(Container);\n      /***/\n\n    },\n    /* 100 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var openBracket = '{'.charCodeAt(0);\n      var closeBracket = '}'.charCodeAt(0);\n      var openParen = '('.charCodeAt(0);\n      var closeParen = ')'.charCodeAt(0);\n      var singleQuote = '\\''.charCodeAt(0);\n      var doubleQuote = '\"'.charCodeAt(0);\n      var backslash = '\\\\'.charCodeAt(0);\n      var slash = '/'.charCodeAt(0);\n      var period = '.'.charCodeAt(0);\n      var comma = ','.charCodeAt(0);\n      var colon = ':'.charCodeAt(0);\n      var asterisk = '*'.charCodeAt(0);\n      var minus = '-'.charCodeAt(0);\n      var plus = '+'.charCodeAt(0);\n      var pound = '#'.charCodeAt(0);\n      var newline = '\\n'.charCodeAt(0);\n      var space = ' '.charCodeAt(0);\n      var feed = '\\f'.charCodeAt(0);\n      var tab = '\\t'.charCodeAt(0);\n      var cr = '\\r'.charCodeAt(0);\n      var at = '@'.charCodeAt(0);\n      var lowerE = 'e'.charCodeAt(0);\n      var upperE = 'E'.charCodeAt(0);\n      var digit0 = '0'.charCodeAt(0);\n      var digit9 = '9'.charCodeAt(0);\n      var lowerU = 'u'.charCodeAt(0);\n      var upperU = 'U'.charCodeAt(0);\n      var atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;,/]/g;\n      var wordEnd = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\n      var wordEndNum = /[ \\n\\t\\r\\(\\)\\{\\}\\*:;@!&'\"\\-\\+\\|~>,\\[\\]\\\\]|\\//g;\n      var alphaNum = /^[a-z0-9]/i;\n      var unicodeRange = /^[a-f0-9?\\-]/i;\n\n      var util = __webpack_require__(101);\n\n      var TokenizeError = __webpack_require__(104);\n\n      module.exports = function tokenize(input, options) {\n        options = options || {};\n        var tokens = [],\n            css = input.valueOf(),\n            length = css.length,\n            offset = -1,\n            line = 1,\n            pos = 0,\n            parentCount = 0,\n            isURLArg = null,\n            code,\n            next,\n            quote,\n            lines,\n            last,\n            content,\n            escape,\n            nextLine,\n            nextOffset,\n            escaped,\n            escapePos,\n            nextChar;\n\n        function unclosed(what) {\n          var message = util.format('Unclosed %s at line: %d, column: %d, token: %d', what, line, pos - offset, pos);\n          throw new TokenizeError(message);\n        }\n\n        function tokenizeError() {\n          var message = util.format('Syntax error at line: %d, column: %d, token: %d', line, pos - offset, pos);\n          throw new TokenizeError(message);\n        }\n\n        while (pos < length) {\n          code = css.charCodeAt(pos);\n\n          if (code === newline) {\n            offset = pos;\n            line += 1;\n          }\n\n          switch (code) {\n            case newline:\n            case space:\n            case tab:\n            case cr:\n            case feed:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n\n                if (code === newline) {\n                  offset = next;\n                  line += 1;\n                }\n              } while (code === space || code === newline || code === tab || code === cr || code === feed);\n\n              tokens.push(['space', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n              pos = next - 1;\n              break;\n\n            case colon:\n              next = pos + 1;\n              tokens.push(['colon', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n              pos = next - 1;\n              break;\n\n            case comma:\n              next = pos + 1;\n              tokens.push(['comma', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n              pos = next - 1;\n              break;\n\n            case openBracket:\n              tokens.push(['{', '{', line, pos - offset, line, next - offset, pos]);\n              break;\n\n            case closeBracket:\n              tokens.push(['}', '}', line, pos - offset, line, next - offset, pos]);\n              break;\n\n            case openParen:\n              parentCount++;\n              isURLArg = !isURLArg && parentCount === 1 && tokens.length > 0 && tokens[tokens.length - 1][0] === \"word\" && tokens[tokens.length - 1][1] === \"url\";\n              tokens.push(['(', '(', line, pos - offset, line, next - offset, pos]);\n              break;\n\n            case closeParen:\n              parentCount--;\n              isURLArg = !isURLArg && parentCount === 1;\n              tokens.push([')', ')', line, pos - offset, line, next - offset, pos]);\n              break;\n\n            case singleQuote:\n            case doubleQuote:\n              quote = code === singleQuote ? '\\'' : '\"';\n              next = pos;\n\n              do {\n                escaped = false;\n                next = css.indexOf(quote, next + 1);\n\n                if (next === -1) {\n                  unclosed('quote', quote);\n                }\n\n                escapePos = next;\n\n                while (css.charCodeAt(escapePos - 1) === backslash) {\n                  escapePos -= 1;\n                  escaped = !escaped;\n                }\n              } while (escaped);\n\n              tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            case at:\n              atEnd.lastIndex = pos + 1;\n              atEnd.test(css);\n\n              if (atEnd.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = atEnd.lastIndex - 2;\n              }\n\n              tokens.push(['atword', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            case backslash:\n              next = pos;\n              code = css.charCodeAt(next + 1);\n\n              if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                next += 1;\n              }\n\n              tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            case plus:\n            case minus:\n            case asterisk:\n              next = pos + 1;\n              nextChar = css.slice(pos + 1, next + 1);\n              var prevChar = css.slice(pos - 1, pos); // if the operator is immediately followed by a word character, then we\n              // have a prefix of some kind, and should fall-through. eg. -webkit\n              // look for --* for custom variables\n\n              if (code === minus && nextChar.charCodeAt(0) === minus) {\n                next++;\n                tokens.push(['word', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n                pos = next - 1;\n                break;\n              }\n\n              tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n              pos = next - 1;\n              break;\n\n            default:\n              if (code === slash && (css.charCodeAt(pos + 1) === asterisk || options.loose && !isURLArg && css.charCodeAt(pos + 1) === slash)) {\n                var isStandardComment = css.charCodeAt(pos + 1) === asterisk;\n\n                if (isStandardComment) {\n                  next = css.indexOf('*/', pos + 2) + 1;\n\n                  if (next === 0) {\n                    unclosed('comment', '*/');\n                  }\n                } else {\n                  var newlinePos = css.indexOf('\\n', pos + 2);\n                  next = newlinePos !== -1 ? newlinePos - 1 : length;\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n                offset = nextOffset;\n                line = nextLine;\n                pos = next;\n              } else if (code === pound && !alphaNum.test(css.slice(pos + 1, pos + 2))) {\n                next = pos + 1;\n                tokens.push(['#', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n                pos = next - 1;\n              } else if ((code === lowerU || code === upperU) && css.charCodeAt(pos + 1) === plus) {\n                next = pos + 2;\n\n                do {\n                  next += 1;\n                  code = css.charCodeAt(next);\n                } while (next < length && unicodeRange.test(css.slice(next, next + 1)));\n\n                tokens.push(['unicoderange', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n                pos = next - 1;\n              } // catch a regular slash, that isn't a comment\n              else if (code === slash) {\n                  next = pos + 1;\n                  tokens.push(['operator', css.slice(pos, next), line, pos - offset, line, next - offset, pos]);\n                  pos = next - 1;\n                } else {\n                  var regex = wordEnd; // we're dealing with a word that starts with a number\n                  // those get treated differently\n\n                  if (code >= digit0 && code <= digit9) {\n                    regex = wordEndNum;\n                  }\n\n                  regex.lastIndex = pos + 1;\n                  regex.test(css);\n\n                  if (regex.lastIndex === 0) {\n                    next = css.length - 1;\n                  } else {\n                    next = regex.lastIndex - 2;\n                  } // Exponential number notation with minus or plus: 1e-10, 1e+10\n\n\n                  if (regex === wordEndNum || code === period) {\n                    var ncode = css.charCodeAt(next),\n                        ncode1 = css.charCodeAt(next + 1),\n                        ncode2 = css.charCodeAt(next + 2);\n\n                    if ((ncode === lowerE || ncode === upperE) && (ncode1 === minus || ncode1 === plus) && ncode2 >= digit0 && ncode2 <= digit9) {\n                      wordEndNum.lastIndex = next + 2;\n                      wordEndNum.test(css);\n\n                      if (wordEndNum.lastIndex === 0) {\n                        next = css.length - 1;\n                      } else {\n                        next = wordEndNum.lastIndex - 2;\n                      }\n                    }\n                  }\n\n                  tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n                  pos = next;\n                }\n\n              break;\n          }\n\n          pos++;\n        }\n\n        return tokens;\n      };\n      /***/\n\n    },\n    /* 101 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (global, process) {\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        } // Copyright Joyent, Inc. and other Node contributors.\n        //\n        // Permission is hereby granted, free of charge, to any person obtaining a\n        // copy of this software and associated documentation files (the\n        // \"Software\"), to deal in the Software without restriction, including\n        // without limitation the rights to use, copy, modify, merge, publish,\n        // distribute, sublicense, and/or sell copies of the Software, and to permit\n        // persons to whom the Software is furnished to do so, subject to the\n        // following conditions:\n        //\n        // The above copyright notice and this permission notice shall be included\n        // in all copies or substantial portions of the Software.\n        //\n        // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n        // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n        var formatRegExp = /%[sdj%]/g;\n\n        exports.format = function (f) {\n          if (!isString(f)) {\n            var objects = [];\n\n            for (var i = 0; i < arguments.length; i++) {\n              objects.push(inspect(arguments[i]));\n            }\n\n            return objects.join(' ');\n          }\n\n          var i = 1;\n          var args = arguments;\n          var len = args.length;\n          var str = String(f).replace(formatRegExp, function (x) {\n            if (x === '%%') return '%';\n            if (i >= len) return x;\n\n            switch (x) {\n              case '%s':\n                return String(args[i++]);\n\n              case '%d':\n                return Number(args[i++]);\n\n              case '%j':\n                try {\n                  return JSON.stringify(args[i++]);\n                } catch (_) {\n                  return '[Circular]';\n                }\n\n              default:\n                return x;\n            }\n          });\n\n          for (var x = args[i]; i < len; x = args[++i]) {\n            if (isNull(x) || !isObject(x)) {\n              str += ' ' + x;\n            } else {\n              str += ' ' + inspect(x);\n            }\n          }\n\n          return str;\n        }; // Mark that a method should not be used.\n        // Returns a modified function which warns once by default.\n        // If --no-deprecation is set, then it is a no-op.\n\n\n        exports.deprecate = function (fn, msg) {\n          // Allow for deprecating things in the process of starting up.\n          if (isUndefined(global.process)) {\n            return function () {\n              return exports.deprecate(fn, msg).apply(this, arguments);\n            };\n          }\n\n          if (process.noDeprecation === true) {\n            return fn;\n          }\n\n          var warned = false;\n\n          function deprecated() {\n            if (!warned) {\n              if (process.throwDeprecation) {\n                throw new Error(msg);\n              } else if (process.traceDeprecation) {\n                console.trace(msg);\n              } else {\n                console.error(msg);\n              }\n\n              warned = true;\n            }\n\n            return fn.apply(this, arguments);\n          }\n\n          return deprecated;\n        };\n\n        var debugs = {};\n        var debugEnviron;\n\n        exports.debuglog = function (set) {\n          if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';\n          set = set.toUpperCase();\n\n          if (!debugs[set]) {\n            if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n              var pid = process.pid;\n\n              debugs[set] = function () {\n                var msg = exports.format.apply(exports, arguments);\n                console.error('%s %d: %s', set, pid, msg);\n              };\n            } else {\n              debugs[set] = function () {};\n            }\n          }\n\n          return debugs[set];\n        };\n        /**\n         * Echos the value of a value. Trys to print the value out\n         * in the best way possible given the different types.\n         *\n         * @param {Object} obj The object to print out.\n         * @param {Object} opts Optional options object that alters the output.\n         */\n\n        /* legacy: obj, showHidden, depth, colors*/\n\n\n        function inspect(obj, opts) {\n          // default options\n          var ctx = {\n            seen: [],\n            stylize: stylizeNoColor\n          }; // legacy...\n\n          if (arguments.length >= 3) ctx.depth = arguments[2];\n          if (arguments.length >= 4) ctx.colors = arguments[3];\n\n          if (isBoolean(opts)) {\n            // legacy...\n            ctx.showHidden = opts;\n          } else if (opts) {\n            // got an \"options\" object\n            exports._extend(ctx, opts);\n          } // set default options\n\n\n          if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n          if (isUndefined(ctx.depth)) ctx.depth = 2;\n          if (isUndefined(ctx.colors)) ctx.colors = false;\n          if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n          if (ctx.colors) ctx.stylize = stylizeWithColor;\n          return formatValue(ctx, obj, ctx.depth);\n        }\n\n        exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n\n        inspect.colors = {\n          'bold': [1, 22],\n          'italic': [3, 23],\n          'underline': [4, 24],\n          'inverse': [7, 27],\n          'white': [37, 39],\n          'grey': [90, 39],\n          'black': [30, 39],\n          'blue': [34, 39],\n          'cyan': [36, 39],\n          'green': [32, 39],\n          'magenta': [35, 39],\n          'red': [31, 39],\n          'yellow': [33, 39]\n        }; // Don't use 'blue' not visible on cmd.exe\n\n        inspect.styles = {\n          'special': 'cyan',\n          'number': 'yellow',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red'\n        };\n\n        function stylizeWithColor(str, styleType) {\n          var style = inspect.styles[styleType];\n\n          if (style) {\n            return \"\\x1B[\" + inspect.colors[style][0] + 'm' + str + \"\\x1B[\" + inspect.colors[style][1] + 'm';\n          } else {\n            return str;\n          }\n        }\n\n        function stylizeNoColor(str, styleType) {\n          return str;\n        }\n\n        function arrayToHash(array) {\n          var hash = {};\n          array.forEach(function (val, idx) {\n            hash[val] = true;\n          });\n          return hash;\n        }\n\n        function formatValue(ctx, value, recurseTimes) {\n          // Provide a hook for user-specified inspect functions.\n          // Check that value is an object with an inspect function on it\n          if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special\n          value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n          !(value.constructor && value.constructor.prototype === value)) {\n            var ret = value.inspect(recurseTimes, ctx);\n\n            if (!isString(ret)) {\n              ret = formatValue(ctx, ret, recurseTimes);\n            }\n\n            return ret;\n          } // Primitive types cannot have properties\n\n\n          var primitive = formatPrimitive(ctx, value);\n\n          if (primitive) {\n            return primitive;\n          } // Look up the keys of the object.\n\n\n          var keys = Object.keys(value);\n          var visibleKeys = arrayToHash(keys);\n\n          if (ctx.showHidden) {\n            keys = Object.getOwnPropertyNames(value);\n          } // IE doesn't make error fields non-enumerable\n          // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n\n\n          if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n            return formatError(value);\n          } // Some type of object without properties can be shortcutted.\n\n\n          if (keys.length === 0) {\n            if (isFunction(value)) {\n              var name = value.name ? ': ' + value.name : '';\n              return ctx.stylize('[Function' + name + ']', 'special');\n            }\n\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            }\n\n            if (isDate(value)) {\n              return ctx.stylize(Date.prototype.toString.call(value), 'date');\n            }\n\n            if (isError(value)) {\n              return formatError(value);\n            }\n          }\n\n          var base = '',\n              array = false,\n              braces = ['{', '}']; // Make Array say that they are Array\n\n          if (isArray(value)) {\n            array = true;\n            braces = ['[', ']'];\n          } // Make functions say that they are functions\n\n\n          if (isFunction(value)) {\n            var n = value.name ? ': ' + value.name : '';\n            base = ' [Function' + n + ']';\n          } // Make RegExps say that they are RegExps\n\n\n          if (isRegExp(value)) {\n            base = ' ' + RegExp.prototype.toString.call(value);\n          } // Make dates with properties first say the date\n\n\n          if (isDate(value)) {\n            base = ' ' + Date.prototype.toUTCString.call(value);\n          } // Make error with message first say the error\n\n\n          if (isError(value)) {\n            base = ' ' + formatError(value);\n          }\n\n          if (keys.length === 0 && (!array || value.length == 0)) {\n            return braces[0] + base + braces[1];\n          }\n\n          if (recurseTimes < 0) {\n            if (isRegExp(value)) {\n              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n            } else {\n              return ctx.stylize('[Object]', 'special');\n            }\n          }\n\n          ctx.seen.push(value);\n          var output;\n\n          if (array) {\n            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n          } else {\n            output = keys.map(function (key) {\n              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n            });\n          }\n\n          ctx.seen.pop();\n          return reduceToSingleString(output, base, braces);\n        }\n\n        function formatPrimitive(ctx, value) {\n          if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');\n\n          if (isString(value)) {\n            var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n            return ctx.stylize(simple, 'string');\n          }\n\n          if (isNumber(value)) return ctx.stylize('' + value, 'number');\n          if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is \"object\", so special case here.\n\n          if (isNull(value)) return ctx.stylize('null', 'null');\n        }\n\n        function formatError(value) {\n          return '[' + Error.prototype.toString.call(value) + ']';\n        }\n\n        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n          var output = [];\n\n          for (var i = 0, l = value.length; i < l; ++i) {\n            if (hasOwnProperty(value, String(i))) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n            } else {\n              output.push('');\n            }\n          }\n\n          keys.forEach(function (key) {\n            if (!key.match(/^\\d+$/)) {\n              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n            }\n          });\n          return output;\n        }\n\n        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n          var name, str, desc;\n          desc = Object.getOwnPropertyDescriptor(value, key) || {\n            value: value[key]\n          };\n\n          if (desc.get) {\n            if (desc.set) {\n              str = ctx.stylize('[Getter/Setter]', 'special');\n            } else {\n              str = ctx.stylize('[Getter]', 'special');\n            }\n          } else {\n            if (desc.set) {\n              str = ctx.stylize('[Setter]', 'special');\n            }\n          }\n\n          if (!hasOwnProperty(visibleKeys, key)) {\n            name = '[' + key + ']';\n          }\n\n          if (!str) {\n            if (ctx.seen.indexOf(desc.value) < 0) {\n              if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n              } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n              }\n\n              if (str.indexOf('\\n') > -1) {\n                if (array) {\n                  str = str.split('\\n').map(function (line) {\n                    return '  ' + line;\n                  }).join('\\n').substr(2);\n                } else {\n                  str = '\\n' + str.split('\\n').map(function (line) {\n                    return '   ' + line;\n                  }).join('\\n');\n                }\n              }\n            } else {\n              str = ctx.stylize('[Circular]', 'special');\n            }\n          }\n\n          if (isUndefined(name)) {\n            if (array && key.match(/^\\d+$/)) {\n              return str;\n            }\n\n            name = JSON.stringify('' + key);\n\n            if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n              name = name.substr(1, name.length - 2);\n              name = ctx.stylize(name, 'name');\n            } else {\n              name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n              name = ctx.stylize(name, 'string');\n            }\n          }\n\n          return name + ': ' + str;\n        }\n\n        function reduceToSingleString(output, base, braces) {\n          var numLinesEst = 0;\n          var length = output.reduce(function (prev, cur) {\n            numLinesEst++;\n            if (cur.indexOf('\\n') >= 0) numLinesEst++;\n            return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n          }, 0);\n\n          if (length > 60) {\n            return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n          }\n\n          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n        } // NOTE: These type checking functions intentionally don't use `instanceof`\n        // because it is fragile and can be easily faked with `Object.create()`.\n\n\n        function isArray(ar) {\n          return Array.isArray(ar);\n        }\n\n        exports.isArray = isArray;\n\n        function isBoolean(arg) {\n          return typeof arg === 'boolean';\n        }\n\n        exports.isBoolean = isBoolean;\n\n        function isNull(arg) {\n          return arg === null;\n        }\n\n        exports.isNull = isNull;\n\n        function isNullOrUndefined(arg) {\n          return arg == null;\n        }\n\n        exports.isNullOrUndefined = isNullOrUndefined;\n\n        function isNumber(arg) {\n          return typeof arg === 'number';\n        }\n\n        exports.isNumber = isNumber;\n\n        function isString(arg) {\n          return typeof arg === 'string';\n        }\n\n        exports.isString = isString;\n\n        function isSymbol(arg) {\n          return _typeof(arg) === 'symbol';\n        }\n\n        exports.isSymbol = isSymbol;\n\n        function isUndefined(arg) {\n          return arg === void 0;\n        }\n\n        exports.isUndefined = isUndefined;\n\n        function isRegExp(re) {\n          return isObject(re) && objectToString(re) === '[object RegExp]';\n        }\n\n        exports.isRegExp = isRegExp;\n\n        function isObject(arg) {\n          return _typeof(arg) === 'object' && arg !== null;\n        }\n\n        exports.isObject = isObject;\n\n        function isDate(d) {\n          return isObject(d) && objectToString(d) === '[object Date]';\n        }\n\n        exports.isDate = isDate;\n\n        function isError(e) {\n          return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);\n        }\n\n        exports.isError = isError;\n\n        function isFunction(arg) {\n          return typeof arg === 'function';\n        }\n\n        exports.isFunction = isFunction;\n\n        function isPrimitive(arg) {\n          return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' || // ES6 symbol\n          typeof arg === 'undefined';\n        }\n\n        exports.isPrimitive = isPrimitive;\n        exports.isBuffer = __webpack_require__(102);\n\n        function objectToString(o) {\n          return Object.prototype.toString.call(o);\n        }\n\n        function pad(n) {\n          return n < 10 ? '0' + n.toString(10) : n.toString(10);\n        }\n\n        var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34\n\n        function timestamp() {\n          var d = new Date();\n          var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');\n          return [d.getDate(), months[d.getMonth()], time].join(' ');\n        } // log is just a thin wrapper to console.log that prepends a timestamp\n\n\n        exports.log = function () {\n          console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n        };\n        /**\n         * Inherit the prototype methods from one constructor into another.\n         *\n         * The Function.prototype.inherits from lang.js rewritten as a standalone\n         * function (not on Function.prototype). NOTE: If this file is to be loaded\n         * during bootstrapping this function needs to be rewritten using some native\n         * functions as prototype setup using normal JavaScript does not work as\n         * expected during bootstrapping (see mirror.js in r114903).\n         *\n         * @param {function} ctor Constructor function which needs to inherit the\n         *     prototype.\n         * @param {function} superCtor Constructor function to inherit prototype from.\n         */\n\n\n        exports.inherits = __webpack_require__(103);\n\n        exports._extend = function (origin, add) {\n          // Don't do anything if add isn't an object\n          if (!add || !isObject(add)) return origin;\n          var keys = Object.keys(add);\n          var i = keys.length;\n\n          while (i--) {\n            origin[keys[i]] = add[keys[i]];\n          }\n\n          return origin;\n        };\n\n        function hasOwnProperty(obj, prop) {\n          return Object.prototype.hasOwnProperty.call(obj, prop);\n        }\n        /* WEBPACK VAR INJECTION */\n\n      }).call(exports, __webpack_require__(15), __webpack_require__(12));\n      /***/\n    },\n    /* 102 */\n\n    /***/\n    function (module, exports) {\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      module.exports = function isBuffer(arg) {\n        return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';\n      };\n      /***/\n\n    },\n    /* 103 */\n\n    /***/\n    function (module, exports) {\n      if (typeof Object.create === 'function') {\n        // implementation from standard node.js 'util' module\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          ctor.prototype = Object.create(superCtor.prototype, {\n            constructor: {\n              value: ctor,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n        };\n      } else {\n        // old school shim for old browsers\n        module.exports = function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n\n          var TempCtor = function TempCtor() {};\n\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        };\n      }\n      /***/\n\n    },\n    /* 104 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n          if (Class === null || !_isNativeFunction(Class)) return Class;\n\n          if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n\n            _cache.set(Class, Wrapper);\n          }\n\n          function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n          }\n\n          Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n              value: Wrapper,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n          return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n      }\n\n      function isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n\n        try {\n          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n          _construct = Reflect.construct;\n        } else {\n          _construct = function _construct(Parent, args, Class) {\n            var a = [null];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n          };\n        }\n\n        return _construct.apply(null, arguments);\n      }\n\n      function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      var TokenizeError =\n      /*#__PURE__*/\n      function (_Error) {\n        _inherits(TokenizeError, _Error);\n\n        function TokenizeError(message) {\n          var _this;\n\n          _classCallCheck(this, TokenizeError);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(TokenizeError).call(this, message));\n          _this.name = _this.constructor.name;\n          _this.message = message || 'An error ocurred while tokzenizing.';\n\n          if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n          } else {\n            _this.stack = new Error(message).stack;\n          }\n\n          return _this;\n        }\n\n        return TokenizeError;\n      }(_wrapNativeSuper(Error));\n\n      module.exports = TokenizeError;\n      /***/\n    },\n    /* 105 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n          return call;\n        }\n\n        return _assertThisInitialized(self);\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function\");\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n      }\n\n      function _assertThisInitialized(self) {\n        if (self === void 0) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return self;\n      }\n\n      function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n          if (Class === null || !_isNativeFunction(Class)) return Class;\n\n          if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n          }\n\n          if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n\n            _cache.set(Class, Wrapper);\n          }\n\n          function Wrapper() {\n            return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n          }\n\n          Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n              value: Wrapper,\n              enumerable: false,\n              writable: true,\n              configurable: true\n            }\n          });\n          return _setPrototypeOf(Wrapper, Class);\n        };\n\n        return _wrapNativeSuper(Class);\n      }\n\n      function isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n\n        try {\n          Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      function _construct(Parent, args, Class) {\n        if (isNativeReflectConstruct()) {\n          _construct = Reflect.construct;\n        } else {\n          _construct = function _construct(Parent, args, Class) {\n            var a = [null];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n          };\n        }\n\n        return _construct.apply(null, arguments);\n      }\n\n      function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n      }\n\n      function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n          o.__proto__ = p;\n          return o;\n        };\n\n        return _setPrototypeOf(o, p);\n      }\n\n      function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n      }\n\n      var ParserError =\n      /*#__PURE__*/\n      function (_Error) {\n        _inherits(ParserError, _Error);\n\n        function ParserError(message) {\n          var _this;\n\n          _classCallCheck(this, ParserError);\n\n          _this = _possibleConstructorReturn(this, _getPrototypeOf(ParserError).call(this, message));\n          _this.name = _this.constructor.name;\n          _this.message = message || 'An error ocurred while parsing.';\n\n          if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n          } else {\n            _this.stack = new Error(message).stack;\n          }\n\n          return _this;\n        }\n\n        return ParserError;\n      }(_wrapNativeSuper(Error));\n\n      module.exports = ParserError;\n      /***/\n    },\n    /* 106 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _processor = __webpack_require__(107);\n\n      var _processor2 = _interopRequireDefault(_processor);\n\n      var _attribute = __webpack_require__(53);\n\n      var _attribute2 = _interopRequireDefault(_attribute);\n\n      var _className = __webpack_require__(47);\n\n      var _className2 = _interopRequireDefault(_className);\n\n      var _combinator = __webpack_require__(55);\n\n      var _combinator2 = _interopRequireDefault(_combinator);\n\n      var _comment = __webpack_require__(48);\n\n      var _comment2 = _interopRequireDefault(_comment);\n\n      var _id = __webpack_require__(49);\n\n      var _id2 = _interopRequireDefault(_id);\n\n      var _nesting = __webpack_require__(56);\n\n      var _nesting2 = _interopRequireDefault(_nesting);\n\n      var _pseudo = __webpack_require__(52);\n\n      var _pseudo2 = _interopRequireDefault(_pseudo);\n\n      var _root = __webpack_require__(45);\n\n      var _root2 = _interopRequireDefault(_root);\n\n      var _selector = __webpack_require__(46);\n\n      var _selector2 = _interopRequireDefault(_selector);\n\n      var _string = __webpack_require__(51);\n\n      var _string2 = _interopRequireDefault(_string);\n\n      var _tag = __webpack_require__(50);\n\n      var _tag2 = _interopRequireDefault(_tag);\n\n      var _universal = __webpack_require__(54);\n\n      var _universal2 = _interopRequireDefault(_universal);\n\n      var _types = __webpack_require__(0);\n\n      var types = _interopRequireWildcard(_types);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj.default = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var parser = function parser(processor) {\n        return new _processor2.default(processor);\n      };\n\n      parser.attribute = function (opts) {\n        return new _attribute2.default(opts);\n      };\n\n      parser.className = function (opts) {\n        return new _className2.default(opts);\n      };\n\n      parser.combinator = function (opts) {\n        return new _combinator2.default(opts);\n      };\n\n      parser.comment = function (opts) {\n        return new _comment2.default(opts);\n      };\n\n      parser.id = function (opts) {\n        return new _id2.default(opts);\n      };\n\n      parser.nesting = function (opts) {\n        return new _nesting2.default(opts);\n      };\n\n      parser.pseudo = function (opts) {\n        return new _pseudo2.default(opts);\n      };\n\n      parser.root = function (opts) {\n        return new _root2.default(opts);\n      };\n\n      parser.selector = function (opts) {\n        return new _selector2.default(opts);\n      };\n\n      parser.string = function (opts) {\n        return new _string2.default(opts);\n      };\n\n      parser.tag = function (opts) {\n        return new _tag2.default(opts);\n      };\n\n      parser.universal = function (opts) {\n        return new _universal2.default(opts);\n      };\n\n      Object.keys(types).forEach(function (type) {\n        if (type === '__esModule') {\n          return;\n        }\n\n        parser[type] = types[type]; // eslint-disable-line\n      });\n      exports.default = parser;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 107 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _parser = __webpack_require__(108);\n\n      var _parser2 = _interopRequireDefault(_parser);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Processor = function () {\n        function Processor(func) {\n          _classCallCheck(this, Processor);\n\n          this.func = func || function noop() {};\n\n          return this;\n        }\n\n        Processor.prototype.process = function process(selectors) {\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          var input = new _parser2.default({\n            css: selectors,\n            error: function error(e) {\n              throw new Error(e);\n            },\n            options: options\n          });\n          this.res = input;\n          this.func(input);\n          return this;\n        };\n\n        _createClass(Processor, [{\n          key: 'result',\n          get: function get() {\n            return String(this.res);\n          }\n        }]);\n\n        return Processor;\n      }();\n\n      exports.default = Processor;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 108 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _flatten = __webpack_require__(42);\n\n      var _flatten2 = _interopRequireDefault(_flatten);\n\n      var _indexesOf = __webpack_require__(43);\n\n      var _indexesOf2 = _interopRequireDefault(_indexesOf);\n\n      var _uniq = __webpack_require__(44);\n\n      var _uniq2 = _interopRequireDefault(_uniq);\n\n      var _root = __webpack_require__(45);\n\n      var _root2 = _interopRequireDefault(_root);\n\n      var _selector = __webpack_require__(46);\n\n      var _selector2 = _interopRequireDefault(_selector);\n\n      var _className = __webpack_require__(47);\n\n      var _className2 = _interopRequireDefault(_className);\n\n      var _comment = __webpack_require__(48);\n\n      var _comment2 = _interopRequireDefault(_comment);\n\n      var _id = __webpack_require__(49);\n\n      var _id2 = _interopRequireDefault(_id);\n\n      var _tag = __webpack_require__(50);\n\n      var _tag2 = _interopRequireDefault(_tag);\n\n      var _string = __webpack_require__(51);\n\n      var _string2 = _interopRequireDefault(_string);\n\n      var _pseudo = __webpack_require__(52);\n\n      var _pseudo2 = _interopRequireDefault(_pseudo);\n\n      var _attribute = __webpack_require__(53);\n\n      var _attribute2 = _interopRequireDefault(_attribute);\n\n      var _universal = __webpack_require__(54);\n\n      var _universal2 = _interopRequireDefault(_universal);\n\n      var _combinator = __webpack_require__(55);\n\n      var _combinator2 = _interopRequireDefault(_combinator);\n\n      var _nesting = __webpack_require__(56);\n\n      var _nesting2 = _interopRequireDefault(_nesting);\n\n      var _sortAscending = __webpack_require__(109);\n\n      var _sortAscending2 = _interopRequireDefault(_sortAscending);\n\n      var _tokenize = __webpack_require__(110);\n\n      var _tokenize2 = _interopRequireDefault(_tokenize);\n\n      var _types = __webpack_require__(0);\n\n      var types = _interopRequireWildcard(_types);\n\n      function _interopRequireWildcard(obj) {\n        if (obj && obj.__esModule) {\n          return obj;\n        } else {\n          var newObj = {};\n\n          if (obj != null) {\n            for (var key in obj) {\n              if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n            }\n          }\n\n          newObj.default = obj;\n          return newObj;\n        }\n      }\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var Parser = function () {\n        function Parser(input) {\n          _classCallCheck(this, Parser);\n\n          this.input = input;\n          this.lossy = input.options.lossless === false;\n          this.position = 0;\n          this.root = new _root2.default();\n          var selectors = new _selector2.default();\n          this.root.append(selectors);\n          this.current = selectors;\n\n          if (this.lossy) {\n            this.tokens = (0, _tokenize2.default)({\n              safe: input.safe,\n              css: input.css.trim()\n            });\n          } else {\n            this.tokens = (0, _tokenize2.default)(input);\n          }\n\n          return this.loop();\n        }\n\n        Parser.prototype.attribute = function attribute() {\n          var str = '';\n          var attr = void 0;\n          var startingToken = this.currToken;\n          this.position++;\n\n          while (this.position < this.tokens.length && this.currToken[0] !== ']') {\n            str += this.tokens[this.position][1];\n            this.position++;\n          }\n\n          if (this.position === this.tokens.length && !~str.indexOf(']')) {\n            this.error('Expected a closing square bracket.');\n          }\n\n          var parts = str.split(/((?:[*~^$|]?=))([^]*)/);\n          var namespace = parts[0].split(/(\\|)/g);\n          var attributeProps = {\n            operator: parts[1],\n            value: parts[2],\n            source: {\n              start: {\n                line: startingToken[2],\n                column: startingToken[3]\n              },\n              end: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              }\n            },\n            sourceIndex: startingToken[4]\n          };\n\n          if (namespace.length > 1) {\n            if (namespace[0] === '') {\n              namespace[0] = true;\n            }\n\n            attributeProps.attribute = this.parseValue(namespace[2]);\n            attributeProps.namespace = this.parseNamespace(namespace[0]);\n          } else {\n            attributeProps.attribute = this.parseValue(parts[0]);\n          }\n\n          attr = new _attribute2.default(attributeProps);\n\n          if (parts[2]) {\n            var insensitive = parts[2].split(/(\\s+i\\s*?)$/);\n            var trimmedValue = insensitive[0].trim();\n            attr.value = this.lossy ? trimmedValue : insensitive[0];\n\n            if (insensitive[1]) {\n              attr.insensitive = true;\n\n              if (!this.lossy) {\n                attr.raws.insensitive = insensitive[1];\n              }\n            }\n\n            attr.quoted = trimmedValue[0] === '\\'' || trimmedValue[0] === '\"';\n            attr.raws.unquoted = attr.quoted ? trimmedValue.slice(1, -1) : trimmedValue;\n          }\n\n          this.newNode(attr);\n          this.position++;\n        };\n\n        Parser.prototype.combinator = function combinator() {\n          if (this.currToken[1] === '|') {\n            return this.namespace();\n          }\n\n          var node = new _combinator2.default({\n            value: '',\n            source: {\n              start: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              },\n              end: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              }\n            },\n            sourceIndex: this.currToken[4]\n          });\n\n          while (this.position < this.tokens.length && this.currToken && (this.currToken[0] === 'space' || this.currToken[0] === 'combinator')) {\n            if (this.nextToken && this.nextToken[0] === 'combinator') {\n              node.spaces.before = this.parseSpace(this.currToken[1]);\n              node.source.start.line = this.nextToken[2];\n              node.source.start.column = this.nextToken[3];\n              node.source.end.column = this.nextToken[3];\n              node.source.end.line = this.nextToken[2];\n              node.sourceIndex = this.nextToken[4];\n            } else if (this.prevToken && this.prevToken[0] === 'combinator') {\n              node.spaces.after = this.parseSpace(this.currToken[1]);\n            } else if (this.currToken[0] === 'combinator') {\n              node.value = this.currToken[1];\n            } else if (this.currToken[0] === 'space') {\n              node.value = this.parseSpace(this.currToken[1], ' ');\n            }\n\n            this.position++;\n          }\n\n          return this.newNode(node);\n        };\n\n        Parser.prototype.comma = function comma() {\n          if (this.position === this.tokens.length - 1) {\n            this.root.trailingComma = true;\n            this.position++;\n            return;\n          }\n\n          var selectors = new _selector2.default();\n          this.current.parent.append(selectors);\n          this.current = selectors;\n          this.position++;\n        };\n\n        Parser.prototype.comment = function comment() {\n          var node = new _comment2.default({\n            value: this.currToken[1],\n            source: {\n              start: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              },\n              end: {\n                line: this.currToken[4],\n                column: this.currToken[5]\n              }\n            },\n            sourceIndex: this.currToken[6]\n          });\n          this.newNode(node);\n          this.position++;\n        };\n\n        Parser.prototype.error = function error(message) {\n          throw new this.input.error(message); // eslint-disable-line new-cap\n        };\n\n        Parser.prototype.missingBackslash = function missingBackslash() {\n          return this.error('Expected a backslash preceding the semicolon.');\n        };\n\n        Parser.prototype.missingParenthesis = function missingParenthesis() {\n          return this.error('Expected opening parenthesis.');\n        };\n\n        Parser.prototype.missingSquareBracket = function missingSquareBracket() {\n          return this.error('Expected opening square bracket.');\n        };\n\n        Parser.prototype.namespace = function namespace() {\n          var before = this.prevToken && this.prevToken[1] || true;\n\n          if (this.nextToken[0] === 'word') {\n            this.position++;\n            return this.word(before);\n          } else if (this.nextToken[0] === '*') {\n            this.position++;\n            return this.universal(before);\n          }\n        };\n\n        Parser.prototype.nesting = function nesting() {\n          this.newNode(new _nesting2.default({\n            value: this.currToken[1],\n            source: {\n              start: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              },\n              end: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              }\n            },\n            sourceIndex: this.currToken[4]\n          }));\n          this.position++;\n        };\n\n        Parser.prototype.parentheses = function parentheses() {\n          var last = this.current.last;\n\n          if (last && last.type === types.PSEUDO) {\n            var selector = new _selector2.default();\n            var cache = this.current;\n            last.append(selector);\n            this.current = selector;\n            var balanced = 1;\n            this.position++;\n\n            while (this.position < this.tokens.length && balanced) {\n              if (this.currToken[0] === '(') {\n                balanced++;\n              }\n\n              if (this.currToken[0] === ')') {\n                balanced--;\n              }\n\n              if (balanced) {\n                this.parse();\n              } else {\n                selector.parent.source.end.line = this.currToken[2];\n                selector.parent.source.end.column = this.currToken[3];\n                this.position++;\n              }\n            }\n\n            if (balanced) {\n              this.error('Expected closing parenthesis.');\n            }\n\n            this.current = cache;\n          } else {\n            var _balanced = 1;\n            this.position++;\n            last.value += '(';\n\n            while (this.position < this.tokens.length && _balanced) {\n              if (this.currToken[0] === '(') {\n                _balanced++;\n              }\n\n              if (this.currToken[0] === ')') {\n                _balanced--;\n              }\n\n              last.value += this.parseParenthesisToken(this.currToken);\n              this.position++;\n            }\n\n            if (_balanced) {\n              this.error('Expected closing parenthesis.');\n            }\n          }\n        };\n\n        Parser.prototype.pseudo = function pseudo() {\n          var _this = this;\n\n          var pseudoStr = '';\n          var startingToken = this.currToken;\n\n          while (this.currToken && this.currToken[0] === ':') {\n            pseudoStr += this.currToken[1];\n            this.position++;\n          }\n\n          if (!this.currToken) {\n            return this.error('Expected pseudo-class or pseudo-element');\n          }\n\n          if (this.currToken[0] === 'word') {\n            var pseudo = void 0;\n            this.splitWord(false, function (first, length) {\n              pseudoStr += first;\n              pseudo = new _pseudo2.default({\n                value: pseudoStr,\n                source: {\n                  start: {\n                    line: startingToken[2],\n                    column: startingToken[3]\n                  },\n                  end: {\n                    line: _this.currToken[4],\n                    column: _this.currToken[5]\n                  }\n                },\n                sourceIndex: startingToken[4]\n              });\n\n              _this.newNode(pseudo);\n\n              if (length > 1 && _this.nextToken && _this.nextToken[0] === '(') {\n                _this.error('Misplaced parenthesis.');\n              }\n            });\n          } else {\n            this.error('Unexpected \"' + this.currToken[0] + '\" found.');\n          }\n        };\n\n        Parser.prototype.space = function space() {\n          var token = this.currToken; // Handle space before and after the selector\n\n          if (this.position === 0 || this.prevToken[0] === ',' || this.prevToken[0] === '(') {\n            this.spaces = this.parseSpace(token[1]);\n            this.position++;\n          } else if (this.position === this.tokens.length - 1 || this.nextToken[0] === ',' || this.nextToken[0] === ')') {\n            this.current.last.spaces.after = this.parseSpace(token[1]);\n            this.position++;\n          } else {\n            this.combinator();\n          }\n        };\n\n        Parser.prototype.string = function string() {\n          var token = this.currToken;\n          this.newNode(new _string2.default({\n            value: this.currToken[1],\n            source: {\n              start: {\n                line: token[2],\n                column: token[3]\n              },\n              end: {\n                line: token[4],\n                column: token[5]\n              }\n            },\n            sourceIndex: token[6]\n          }));\n          this.position++;\n        };\n\n        Parser.prototype.universal = function universal(namespace) {\n          var nextToken = this.nextToken;\n\n          if (nextToken && nextToken[1] === '|') {\n            this.position++;\n            return this.namespace();\n          }\n\n          this.newNode(new _universal2.default({\n            value: this.currToken[1],\n            source: {\n              start: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              },\n              end: {\n                line: this.currToken[2],\n                column: this.currToken[3]\n              }\n            },\n            sourceIndex: this.currToken[4]\n          }), namespace);\n          this.position++;\n        };\n\n        Parser.prototype.splitWord = function splitWord(namespace, firstCallback) {\n          var _this2 = this;\n\n          var nextToken = this.nextToken;\n          var word = this.currToken[1];\n\n          while (nextToken && nextToken[0] === 'word') {\n            this.position++;\n            var current = this.currToken[1];\n            word += current;\n\n            if (current.lastIndexOf('\\\\') === current.length - 1) {\n              var next = this.nextToken;\n\n              if (next && next[0] === 'space') {\n                word += this.parseSpace(next[1], ' ');\n                this.position++;\n              }\n            }\n\n            nextToken = this.nextToken;\n          }\n\n          var hasClass = (0, _indexesOf2.default)(word, '.');\n          var hasId = (0, _indexesOf2.default)(word, '#'); // Eliminate Sass interpolations from the list of id indexes\n\n          var interpolations = (0, _indexesOf2.default)(word, '#{');\n\n          if (interpolations.length) {\n            hasId = hasId.filter(function (hashIndex) {\n              return !~interpolations.indexOf(hashIndex);\n            });\n          }\n\n          var indices = (0, _sortAscending2.default)((0, _uniq2.default)((0, _flatten2.default)([[0], hasClass, hasId])));\n          indices.forEach(function (ind, i) {\n            var index = indices[i + 1] || word.length;\n            var value = word.slice(ind, index);\n\n            if (i === 0 && firstCallback) {\n              return firstCallback.call(_this2, value, indices.length);\n            }\n\n            var node = void 0;\n\n            if (~hasClass.indexOf(ind)) {\n              node = new _className2.default({\n                value: value.slice(1),\n                source: {\n                  start: {\n                    line: _this2.currToken[2],\n                    column: _this2.currToken[3] + ind\n                  },\n                  end: {\n                    line: _this2.currToken[4],\n                    column: _this2.currToken[3] + (index - 1)\n                  }\n                },\n                sourceIndex: _this2.currToken[6] + indices[i]\n              });\n            } else if (~hasId.indexOf(ind)) {\n              node = new _id2.default({\n                value: value.slice(1),\n                source: {\n                  start: {\n                    line: _this2.currToken[2],\n                    column: _this2.currToken[3] + ind\n                  },\n                  end: {\n                    line: _this2.currToken[4],\n                    column: _this2.currToken[3] + (index - 1)\n                  }\n                },\n                sourceIndex: _this2.currToken[6] + indices[i]\n              });\n            } else {\n              node = new _tag2.default({\n                value: value,\n                source: {\n                  start: {\n                    line: _this2.currToken[2],\n                    column: _this2.currToken[3] + ind\n                  },\n                  end: {\n                    line: _this2.currToken[4],\n                    column: _this2.currToken[3] + (index - 1)\n                  }\n                },\n                sourceIndex: _this2.currToken[6] + indices[i]\n              });\n            }\n\n            _this2.newNode(node, namespace);\n          });\n          this.position++;\n        };\n\n        Parser.prototype.word = function word(namespace) {\n          var nextToken = this.nextToken;\n\n          if (nextToken && nextToken[1] === '|') {\n            this.position++;\n            return this.namespace();\n          }\n\n          return this.splitWord(namespace);\n        };\n\n        Parser.prototype.loop = function loop() {\n          while (this.position < this.tokens.length) {\n            this.parse(true);\n          }\n\n          return this.root;\n        };\n\n        Parser.prototype.parse = function parse(throwOnParenthesis) {\n          switch (this.currToken[0]) {\n            case 'space':\n              this.space();\n              break;\n\n            case 'comment':\n              this.comment();\n              break;\n\n            case '(':\n              this.parentheses();\n              break;\n\n            case ')':\n              if (throwOnParenthesis) {\n                this.missingParenthesis();\n              }\n\n              break;\n\n            case '[':\n              this.attribute();\n              break;\n\n            case ']':\n              this.missingSquareBracket();\n              break;\n\n            case 'at-word':\n            case 'word':\n              this.word();\n              break;\n\n            case ':':\n              this.pseudo();\n              break;\n\n            case ';':\n              this.missingBackslash();\n              break;\n\n            case ',':\n              this.comma();\n              break;\n\n            case '*':\n              this.universal();\n              break;\n\n            case '&':\n              this.nesting();\n              break;\n\n            case 'combinator':\n              this.combinator();\n              break;\n\n            case 'string':\n              this.string();\n              break;\n          }\n        };\n        /**\n         * Helpers\n         */\n\n\n        Parser.prototype.parseNamespace = function parseNamespace(namespace) {\n          if (this.lossy && typeof namespace === 'string') {\n            var trimmed = namespace.trim();\n\n            if (!trimmed.length) {\n              return true;\n            }\n\n            return trimmed;\n          }\n\n          return namespace;\n        };\n\n        Parser.prototype.parseSpace = function parseSpace(space, replacement) {\n          return this.lossy ? replacement || '' : space;\n        };\n\n        Parser.prototype.parseValue = function parseValue(value) {\n          return this.lossy && value && typeof value === 'string' ? value.trim() : value;\n        };\n\n        Parser.prototype.parseParenthesisToken = function parseParenthesisToken(token) {\n          if (!this.lossy) {\n            return token[1];\n          }\n\n          if (token[0] === 'space') {\n            return this.parseSpace(token[1], ' ');\n          }\n\n          return this.parseValue(token[1]);\n        };\n\n        Parser.prototype.newNode = function newNode(node, namespace) {\n          if (namespace) {\n            node.namespace = this.parseNamespace(namespace);\n          }\n\n          if (this.spaces) {\n            node.spaces.before = this.spaces;\n            this.spaces = '';\n          }\n\n          return this.current.append(node);\n        };\n\n        _createClass(Parser, [{\n          key: 'currToken',\n          get: function get() {\n            return this.tokens[this.position];\n          }\n        }, {\n          key: 'nextToken',\n          get: function get() {\n            return this.tokens[this.position + 1];\n          }\n        }, {\n          key: 'prevToken',\n          get: function get() {\n            return this.tokens[this.position - 1];\n          }\n        }]);\n\n        return Parser;\n      }();\n\n      exports.default = Parser;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 109 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = sortAscending;\n\n      function sortAscending(list) {\n        return list.sort(function (a, b) {\n          return a - b;\n        });\n      }\n\n      ;\n      module.exports = exports[\"default\"];\n      /***/\n    },\n    /* 110 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = tokenize;\n      var singleQuote = 39,\n          doubleQuote = 34,\n          backslash = 92,\n          slash = 47,\n          newline = 10,\n          space = 32,\n          feed = 12,\n          tab = 9,\n          cr = 13,\n          plus = 43,\n          gt = 62,\n          tilde = 126,\n          pipe = 124,\n          comma = 44,\n          openBracket = 40,\n          closeBracket = 41,\n          openSq = 91,\n          closeSq = 93,\n          semicolon = 59,\n          asterisk = 42,\n          colon = 58,\n          ampersand = 38,\n          at = 64,\n          atEnd = /[ \\n\\t\\r\\{\\(\\)'\"\\\\;/]/g,\n          wordEnd = /[ \\n\\t\\r\\(\\)\\*:;@!&'\"\\+\\|~>,\\[\\]\\\\]|\\/(?=\\*)/g;\n\n      function tokenize(input) {\n        var tokens = [];\n        var css = input.css.valueOf();\n        var code = void 0,\n            next = void 0,\n            quote = void 0,\n            lines = void 0,\n            last = void 0,\n            content = void 0,\n            escape = void 0,\n            nextLine = void 0,\n            nextOffset = void 0,\n            escaped = void 0,\n            escapePos = void 0;\n        var length = css.length;\n        var offset = -1;\n        var line = 1;\n        var pos = 0;\n\n        var unclosed = function unclosed(what, end) {\n          if (input.safe) {\n            css += end;\n            next = css.length - 1;\n          } else {\n            throw input.error('Unclosed ' + what, line, pos - offset, pos);\n          }\n        };\n\n        while (pos < length) {\n          code = css.charCodeAt(pos);\n\n          if (code === newline) {\n            offset = pos;\n            line += 1;\n          }\n\n          switch (code) {\n            case newline:\n            case space:\n            case tab:\n            case cr:\n            case feed:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n\n                if (code === newline) {\n                  offset = next;\n                  line += 1;\n                }\n              } while (code === space || code === newline || code === tab || code === cr || code === feed);\n\n              tokens.push(['space', css.slice(pos, next), line, pos - offset, pos]);\n              pos = next - 1;\n              break;\n\n            case plus:\n            case gt:\n            case tilde:\n            case pipe:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n              } while (code === plus || code === gt || code === tilde || code === pipe);\n\n              tokens.push(['combinator', css.slice(pos, next), line, pos - offset, pos]);\n              pos = next - 1;\n              break;\n\n            case asterisk:\n              tokens.push(['*', '*', line, pos - offset, pos]);\n              break;\n\n            case ampersand:\n              tokens.push(['&', '&', line, pos - offset, pos]);\n              break;\n\n            case comma:\n              tokens.push([',', ',', line, pos - offset, pos]);\n              break;\n\n            case openSq:\n              tokens.push(['[', '[', line, pos - offset, pos]);\n              break;\n\n            case closeSq:\n              tokens.push([']', ']', line, pos - offset, pos]);\n              break;\n\n            case colon:\n              tokens.push([':', ':', line, pos - offset, pos]);\n              break;\n\n            case semicolon:\n              tokens.push([';', ';', line, pos - offset, pos]);\n              break;\n\n            case openBracket:\n              tokens.push(['(', '(', line, pos - offset, pos]);\n              break;\n\n            case closeBracket:\n              tokens.push([')', ')', line, pos - offset, pos]);\n              break;\n\n            case singleQuote:\n            case doubleQuote:\n              quote = code === singleQuote ? \"'\" : '\"';\n              next = pos;\n\n              do {\n                escaped = false;\n                next = css.indexOf(quote, next + 1);\n\n                if (next === -1) {\n                  unclosed('quote', quote);\n                }\n\n                escapePos = next;\n\n                while (css.charCodeAt(escapePos - 1) === backslash) {\n                  escapePos -= 1;\n                  escaped = !escaped;\n                }\n              } while (escaped);\n\n              tokens.push(['string', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            case at:\n              atEnd.lastIndex = pos + 1;\n              atEnd.test(css);\n\n              if (atEnd.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = atEnd.lastIndex - 2;\n              }\n\n              tokens.push(['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            case backslash:\n              next = pos;\n              escape = true;\n\n              while (css.charCodeAt(next + 1) === backslash) {\n                next += 1;\n                escape = !escape;\n              }\n\n              code = css.charCodeAt(next + 1);\n\n              if (escape && code !== slash && code !== space && code !== newline && code !== tab && code !== cr && code !== feed) {\n                next += 1;\n              }\n\n              tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n              pos = next;\n              break;\n\n            default:\n              if (code === slash && css.charCodeAt(pos + 1) === asterisk) {\n                next = css.indexOf('*/', pos + 2) + 1;\n\n                if (next === 0) {\n                  unclosed('comment', '*/');\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                tokens.push(['comment', content, line, pos - offset, nextLine, next - nextOffset, pos]);\n                offset = nextOffset;\n                line = nextLine;\n                pos = next;\n              } else {\n                wordEnd.lastIndex = pos + 1;\n                wordEnd.test(css);\n\n                if (wordEnd.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = wordEnd.lastIndex - 2;\n                }\n\n                tokens.push(['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset, pos]);\n                pos = next;\n              }\n\n              break;\n          }\n\n          pos++;\n        }\n\n        return tokens;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 111 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = parseMedia;\n\n      var _Container = __webpack_require__(57);\n\n      var _Container2 = _interopRequireDefault(_Container);\n\n      var _parsers = __webpack_require__(112);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      /**\r\n       * Parses a media query list into an array of nodes. A typical node signature:\r\n       *  {string} node.type -- one of: 'media-query', 'media-type', 'keyword',\r\n       *    'media-feature-expression', 'media-feature', 'colon', 'value'\r\n       *  {string} node.value -- the contents of a particular element, trimmed\r\n       *    e.g.: `screen`, `max-width`, `1024px`\r\n       *  {string} node.after -- whitespaces that follow the element\r\n       *  {string} node.before -- whitespaces that precede the element\r\n       *  {string} node.sourceIndex -- the index of the element in a source media\r\n       *    query list, 0-based\r\n       *  {object} node.parent -- a link to the parent node (a container)\r\n       *\r\n       * Some nodes (media queries, media feature expressions) contain other nodes.\r\n       * They additionally have:\r\n       *  {array} node.nodes -- an array of nodes of the type described here\r\n       *  {funciton} node.each -- traverses direct children of the node, calling\r\n       *    a callback for each one\r\n       *  {funciton} node.walk -- traverses ALL descendants of the node, calling\r\n       *    a callback for each one\r\n       */\n\n\n      function parseMedia(value) {\n        return new _Container2.default({\n          nodes: (0, _parsers.parseMediaList)(value),\n          type: 'media-query-list',\n          value: value.trim()\n        });\n      }\n      /***/\n\n    },\n    /* 112 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.parseMediaFeature = parseMediaFeature;\n      exports.parseMediaQuery = parseMediaQuery;\n      exports.parseMediaList = parseMediaList;\n\n      var _Node = __webpack_require__(58);\n\n      var _Node2 = _interopRequireDefault(_Node);\n\n      var _Container = __webpack_require__(57);\n\n      var _Container2 = _interopRequireDefault(_Container);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      /**\r\n       * Parses a media feature expression, e.g. `max-width: 10px`, `(color)`\r\n       *\r\n       * @param {string} string - the source expression string, can be inside parens\r\n       * @param {Number} index - the index of `string` in the overall input\r\n       *\r\n       * @return {Array} an array of Nodes, the first element being a media feature,\r\n       *    the secont - its value (may be missing)\r\n       */\n\n\n      function parseMediaFeature(string) {\n        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var modesEntered = [{\n          mode: 'normal',\n          character: null\n        }];\n        var result = [];\n        var lastModeIndex = 0;\n        var mediaFeature = '';\n        var colon = null;\n        var mediaFeatureValue = null;\n        var indexLocal = index;\n        var stringNormalized = string; // Strip trailing parens (if any), and correct the starting index\n\n        if (string[0] === '(' && string[string.length - 1] === ')') {\n          stringNormalized = string.substring(1, string.length - 1);\n          indexLocal++;\n        }\n\n        for (var i = 0; i < stringNormalized.length; i++) {\n          var character = stringNormalized[i]; // If entering/exiting a string\n\n          if (character === '\\'' || character === '\"') {\n            if (modesEntered[lastModeIndex].isCalculationEnabled === true) {\n              modesEntered.push({\n                mode: 'string',\n                isCalculationEnabled: false,\n                character: character\n              });\n              lastModeIndex++;\n            } else if (modesEntered[lastModeIndex].mode === 'string' && modesEntered[lastModeIndex].character === character && stringNormalized[i - 1] !== '\\\\') {\n              modesEntered.pop();\n              lastModeIndex--;\n            }\n          } // If entering/exiting interpolation\n\n\n          if (character === '{') {\n            modesEntered.push({\n              mode: 'interpolation',\n              isCalculationEnabled: true\n            });\n            lastModeIndex++;\n          } else if (character === '}') {\n            modesEntered.pop();\n            lastModeIndex--;\n          } // If a : is met outside of a string, function call or interpolation, than\n          // this : separates a media feature and a value\n\n\n          if (modesEntered[lastModeIndex].mode === 'normal' && character === ':') {\n            var mediaFeatureValueStr = stringNormalized.substring(i + 1);\n            mediaFeatureValue = {\n              type: 'value',\n              before: /^(\\s*)/.exec(mediaFeatureValueStr)[1],\n              after: /(\\s*)$/.exec(mediaFeatureValueStr)[1],\n              value: mediaFeatureValueStr.trim()\n            }; // +1 for the colon\n\n            mediaFeatureValue.sourceIndex = mediaFeatureValue.before.length + i + 1 + indexLocal;\n            colon = {\n              type: 'colon',\n              sourceIndex: i + indexLocal,\n              after: mediaFeatureValue.before,\n              value: ':'\n            };\n            break;\n          }\n\n          mediaFeature += character;\n        } // Forming a media feature node\n\n\n        mediaFeature = {\n          type: 'media-feature',\n          before: /^(\\s*)/.exec(mediaFeature)[1],\n          after: /(\\s*)$/.exec(mediaFeature)[1],\n          value: mediaFeature.trim()\n        };\n        mediaFeature.sourceIndex = mediaFeature.before.length + indexLocal;\n        result.push(mediaFeature);\n\n        if (colon !== null) {\n          colon.before = mediaFeature.after;\n          result.push(colon);\n        }\n\n        if (mediaFeatureValue !== null) {\n          result.push(mediaFeatureValue);\n        }\n\n        return result;\n      }\n      /**\r\n       * Parses a media query, e.g. `screen and (color)`, `only tv`\r\n       *\r\n       * @param {string} string - the source media query string\r\n       * @param {Number} index - the index of `string` in the overall input\r\n       *\r\n       * @return {Array} an array of Nodes and Containers\r\n       */\n\n\n      function parseMediaQuery(string) {\n        var index = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n        var result = []; // How many timies the parser entered parens/curly braces\n\n        var localLevel = 0; // Has any keyword, media type, media feature expression or interpolation\n        // ('element' hereafter) started\n\n        var insideSomeValue = false;\n        var node = void 0;\n\n        function resetNode() {\n          return {\n            before: '',\n            after: '',\n            value: ''\n          };\n        }\n\n        node = resetNode();\n\n        for (var i = 0; i < string.length; i++) {\n          var character = string[i]; // If not yet entered any element\n\n          if (!insideSomeValue) {\n            if (character.search(/\\s/) !== -1) {\n              // A whitespace\n              // Don't form 'after' yet; will do it later\n              node.before += character;\n            } else {\n              // Not a whitespace - entering an element\n              // Expression start\n              if (character === '(') {\n                node.type = 'media-feature-expression';\n                localLevel++;\n              }\n\n              node.value = character;\n              node.sourceIndex = index + i;\n              insideSomeValue = true;\n            }\n          } else {\n            // Already in the middle of some alement\n            node.value += character; // Here parens just increase localLevel and don't trigger a start of\n            // a media feature expression (since they can't be nested)\n            // Interpolation start\n\n            if (character === '{' || character === '(') {\n              localLevel++;\n            } // Interpolation/function call/media feature expression end\n\n\n            if (character === ')' || character === '}') {\n              localLevel--;\n            }\n          } // If exited all parens/curlies and the next symbol\n\n\n          if (insideSomeValue && localLevel === 0 && (character === ')' || i === string.length - 1 || string[i + 1].search(/\\s/) !== -1)) {\n            if (['not', 'only', 'and'].indexOf(node.value) !== -1) {\n              node.type = 'keyword';\n            } // if it's an expression, parse its contents\n\n\n            if (node.type === 'media-feature-expression') {\n              node.nodes = parseMediaFeature(node.value, node.sourceIndex);\n            }\n\n            result.push(Array.isArray(node.nodes) ? new _Container2.default(node) : new _Node2.default(node));\n            node = resetNode();\n            insideSomeValue = false;\n          }\n        } // Now process the result array - to specify undefined types of the nodes\n        // and specify the `after` prop\n\n\n        for (var _i = 0; _i < result.length; _i++) {\n          node = result[_i];\n\n          if (_i > 0) {\n            result[_i - 1].after = node.before;\n          } // Node types. Might not be set because contains interpolation/function\n          // calls or fully consists of them\n\n\n          if (node.type === undefined) {\n            if (_i > 0) {\n              // only `and` can follow an expression\n              if (result[_i - 1].type === 'media-feature-expression') {\n                node.type = 'keyword';\n                continue;\n              } // Anything after 'only|not' is a media type\n\n\n              if (result[_i - 1].value === 'not' || result[_i - 1].value === 'only') {\n                node.type = 'media-type';\n                continue;\n              } // Anything after 'and' is an expression\n\n\n              if (result[_i - 1].value === 'and') {\n                node.type = 'media-feature-expression';\n                continue;\n              }\n\n              if (result[_i - 1].type === 'media-type') {\n                // if it is the last element - it might be an expression\n                // or 'and' depending on what is after it\n                if (!result[_i + 1]) {\n                  node.type = 'media-feature-expression';\n                } else {\n                  node.type = result[_i + 1].type === 'media-feature-expression' ? 'keyword' : 'media-feature-expression';\n                }\n              }\n            }\n\n            if (_i === 0) {\n              // `screen`, `fn( ... )`, `#{ ... }`. Not an expression, since then\n              // its type would have been set by now\n              if (!result[_i + 1]) {\n                node.type = 'media-type';\n                continue;\n              } // `screen and` or `#{...} (max-width: 10px)`\n\n\n              if (result[_i + 1] && (result[_i + 1].type === 'media-feature-expression' || result[_i + 1].type === 'keyword')) {\n                node.type = 'media-type';\n                continue;\n              }\n\n              if (result[_i + 2]) {\n                // `screen and (color) ...`\n                if (result[_i + 2].type === 'media-feature-expression') {\n                  node.type = 'media-type';\n                  result[_i + 1].type = 'keyword';\n                  continue;\n                } // `only screen and ...`\n\n\n                if (result[_i + 2].type === 'keyword') {\n                  node.type = 'keyword';\n                  result[_i + 1].type = 'media-type';\n                  continue;\n                }\n              }\n\n              if (result[_i + 3]) {\n                // `screen and (color) ...`\n                if (result[_i + 3].type === 'media-feature-expression') {\n                  node.type = 'keyword';\n                  result[_i + 1].type = 'media-type';\n                  result[_i + 2].type = 'keyword';\n                  continue;\n                }\n              }\n            }\n          }\n        }\n\n        return result;\n      }\n      /**\r\n       * Parses a media query list. Takes a possible `url()` at the start into\r\n       * account, and divides the list into media queries that are parsed separately\r\n       *\r\n       * @param {string} string - the source media query list string\r\n       *\r\n       * @return {Array} an array of Nodes/Containers\r\n       */\n\n\n      function parseMediaList(string) {\n        var result = [];\n        var interimIndex = 0;\n        var levelLocal = 0; // Check for a `url(...)` part (if it is contents of an @import rule)\n\n        var doesHaveUrl = /^(\\s*)url\\s*\\(/.exec(string);\n\n        if (doesHaveUrl !== null) {\n          var i = doesHaveUrl[0].length;\n          var parenthesesLv = 1;\n\n          while (parenthesesLv > 0) {\n            var character = string[i];\n\n            if (character === '(') {\n              parenthesesLv++;\n            }\n\n            if (character === ')') {\n              parenthesesLv--;\n            }\n\n            i++;\n          }\n\n          result.unshift(new _Node2.default({\n            type: 'url',\n            value: string.substring(0, i).trim(),\n            sourceIndex: doesHaveUrl[1].length,\n            before: doesHaveUrl[1],\n            after: /^(\\s*)/.exec(string.substring(i))[1]\n          }));\n          interimIndex = i;\n        } // Start processing the media query list\n\n\n        for (var _i2 = interimIndex; _i2 < string.length; _i2++) {\n          var _character = string[_i2]; // Dividing the media query list into comma-separated media queries\n          // Only count commas that are outside of any parens\n          // (i.e., not part of function call params list, etc.)\n\n          if (_character === '(') {\n            levelLocal++;\n          }\n\n          if (_character === ')') {\n            levelLocal--;\n          }\n\n          if (levelLocal === 0 && _character === ',') {\n            var _mediaQueryString = string.substring(interimIndex, _i2);\n\n            var _spaceBefore = /^(\\s*)/.exec(_mediaQueryString)[1];\n            result.push(new _Container2.default({\n              type: 'media-query',\n              value: _mediaQueryString.trim(),\n              sourceIndex: interimIndex + _spaceBefore.length,\n              nodes: parseMediaQuery(_mediaQueryString, interimIndex),\n              before: _spaceBefore,\n              after: /(\\s*)$/.exec(_mediaQueryString)[1]\n            }));\n            interimIndex = _i2 + 1;\n          }\n        }\n\n        var mediaQueryString = string.substring(interimIndex);\n        var spaceBefore = /^(\\s*)/.exec(mediaQueryString)[1];\n        result.push(new _Container2.default({\n          type: 'media-query',\n          value: mediaQueryString.trim(),\n          sourceIndex: interimIndex + spaceBefore.length,\n          nodes: parseMediaQuery(mediaQueryString, interimIndex),\n          before: spaceBefore,\n          after: /(\\s*)$/.exec(mediaQueryString)[1]\n        }));\n        return result;\n      }\n      /***/\n\n    },\n    /* 113 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var stringify = __webpack_require__(114);\n\n      var parse = __webpack_require__(116);\n\n      module.exports = {\n        parse: parse,\n        stringify: stringify\n      };\n      /***/\n    },\n    /* 114 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var ScssStringifier = __webpack_require__(115);\n\n      module.exports = function scssStringify(node, builder) {\n        var str = new ScssStringifier(builder);\n        str.stringify(node);\n      };\n      /***/\n\n    },\n    /* 115 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Stringifier = __webpack_require__(17);\n\n      var ScssStringifier = function (_Stringifier) {\n        _inherits(ScssStringifier, _Stringifier);\n\n        function ScssStringifier() {\n          _classCallCheck(this, ScssStringifier);\n\n          return _possibleConstructorReturn(this, _Stringifier.apply(this, arguments));\n        }\n\n        ScssStringifier.prototype.comment = function comment(node) {\n          var left = this.raw(node, 'left', 'commentLeft');\n          var right = this.raw(node, 'right', 'commentRight');\n\n          if (node.raws.inline) {\n            var text = node.raws.text || node.text;\n            this.builder('//' + left + text + right, node);\n          } else {\n            this.builder('/*' + left + node.text + right + '*/', node);\n          }\n        };\n\n        ScssStringifier.prototype.decl = function decl(node, semicolon) {\n          if (!node.isNested) {\n            _Stringifier.prototype.decl.call(this, node, semicolon);\n          } else {\n            var between = this.raw(node, 'between', 'colon');\n            var string = node.prop + between + this.rawValue(node, 'value');\n\n            if (node.important) {\n              string += node.raws.important || ' !important';\n            }\n\n            this.builder(string + '{', node, 'start');\n            var after = void 0;\n\n            if (node.nodes && node.nodes.length) {\n              this.body(node);\n              after = this.raw(node, 'after');\n            } else {\n              after = this.raw(node, 'after', 'emptyBody');\n            }\n\n            if (after) this.builder(after);\n            this.builder('}', node, 'end');\n          }\n        };\n\n        ScssStringifier.prototype.rawValue = function rawValue(node, prop) {\n          var value = node[prop];\n          var raw = node.raws[prop];\n\n          if (raw && raw.value === value) {\n            return raw.scss ? raw.scss : raw.raw;\n          } else {\n            return value;\n          }\n        };\n\n        return ScssStringifier;\n      }(Stringifier);\n\n      module.exports = ScssStringifier;\n      /***/\n    },\n    /* 116 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var Input = __webpack_require__(59);\n\n      var ScssParser = __webpack_require__(131);\n\n      module.exports = function scssParse(scss, opts) {\n        var input = new Input(scss, opts);\n        var parser = new ScssParser(input);\n        parser.parse();\n        return parser.root;\n      };\n      /***/\n\n    },\n    /* 117 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 118 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 119 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 120 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (Buffer) {\n        function _typeof(obj) {\n          if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n              return typeof obj;\n            };\n          } else {\n            _typeof = function _typeof(obj) {\n              return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n          }\n\n          return _typeof(obj);\n        }\n\n        exports.__esModule = true;\n        exports.default = void 0;\n\n        var _sourceMap = _interopRequireDefault(__webpack_require__(61));\n\n        var _path = _interopRequireDefault(__webpack_require__(6));\n\n        var _fs = _interopRequireDefault(__webpack_require__(130));\n\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : {\n            default: obj\n          };\n        }\n\n        function fromBase64(str) {\n          if (Buffer) {\n            return Buffer.from(str, 'base64').toString();\n          } else {\n            return window.atob(str);\n          }\n        }\n        /**\n         * Source map information from input CSS.\n         * For example, source map after Sass compiler.\n         *\n         * This class will automatically find source map in input CSS or in file system\n         * near input file (according `from` option).\n         *\n         * @example\n         * const root = postcss.parse(css, { from: 'a.sass.css' })\n         * root.input.map //=> PreviousMap\n         */\n\n\n        var PreviousMap =\n        /*#__PURE__*/\n        function () {\n          /**\n           * @param {string}         css    Input CSS source.\n           * @param {processOptions} [opts] {@link Processor#process} options.\n           */\n          function PreviousMap(css, opts) {\n            this.loadAnnotation(css);\n            /**\n             * Was source map inlined by data-uri to input CSS.\n             *\n             * @type {boolean}\n             */\n\n            this.inline = this.startWith(this.annotation, 'data:');\n            var prev = opts.map ? opts.map.prev : undefined;\n            var text = this.loadMap(opts.from, prev);\n            if (text) this.text = text;\n          }\n          /**\n           * Create a instance of `SourceMapGenerator` class\n           * from the `source-map` library to work with source map information.\n           *\n           * It is lazy method, so it will create object only on first call\n           * and then it will use cache.\n           *\n           * @return {SourceMapGenerator} Object with source map information.\n           */\n\n\n          var _proto = PreviousMap.prototype;\n\n          _proto.consumer = function consumer() {\n            if (!this.consumerCache) {\n              this.consumerCache = new _sourceMap.default.SourceMapConsumer(this.text);\n            }\n\n            return this.consumerCache;\n          };\n          /**\n           * Does source map contains `sourcesContent` with input source text.\n           *\n           * @return {boolean} Is `sourcesContent` present.\n           */\n\n\n          _proto.withContent = function withContent() {\n            return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n          };\n\n          _proto.startWith = function startWith(string, start) {\n            if (!string) return false;\n            return string.substr(0, start.length) === start;\n          };\n\n          _proto.loadAnnotation = function loadAnnotation(css) {\n            var match = css.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//);\n            if (match) this.annotation = match[1].trim();\n          };\n\n          _proto.decodeInline = function decodeInline(text) {\n            var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n            var baseUri = /^data:application\\/json;base64,/;\n            var uri = 'data:application/json,';\n\n            if (this.startWith(text, uri)) {\n              return decodeURIComponent(text.substr(uri.length));\n            }\n\n            if (baseCharsetUri.test(text) || baseUri.test(text)) {\n              return fromBase64(text.substr(RegExp.lastMatch.length));\n            }\n\n            var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n            throw new Error('Unsupported source map encoding ' + encoding);\n          };\n\n          _proto.loadMap = function loadMap(file, prev) {\n            if (prev === false) return false;\n\n            if (prev) {\n              if (typeof prev === 'string') {\n                return prev;\n              } else if (typeof prev === 'function') {\n                var prevPath = prev(file);\n\n                if (prevPath && _fs.default.existsSync && _fs.default.existsSync(prevPath)) {\n                  return _fs.default.readFileSync(prevPath, 'utf-8').toString().trim();\n                } else {\n                  throw new Error('Unable to load previous source map: ' + prevPath.toString());\n                }\n              } else if (prev instanceof _sourceMap.default.SourceMapConsumer) {\n                return _sourceMap.default.SourceMapGenerator.fromSourceMap(prev).toString();\n              } else if (prev instanceof _sourceMap.default.SourceMapGenerator) {\n                return prev.toString();\n              } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n              } else {\n                throw new Error('Unsupported previous source map format: ' + prev.toString());\n              }\n            } else if (this.inline) {\n              return this.decodeInline(this.annotation);\n            } else if (this.annotation) {\n              var map = this.annotation;\n              if (file) map = _path.default.join(_path.default.dirname(file), map);\n              this.root = _path.default.dirname(map);\n\n              if (_fs.default.existsSync && _fs.default.existsSync(map)) {\n                return _fs.default.readFileSync(map, 'utf-8').toString().trim();\n              } else {\n                return false;\n              }\n            }\n          };\n\n          _proto.isMap = function isMap(map) {\n            if (_typeof(map) !== 'object') return false;\n            return typeof map.mappings === 'string' || typeof map._mappings === 'string';\n          };\n\n          return PreviousMap;\n        }();\n\n        var _default = PreviousMap;\n        exports.default = _default;\n        module.exports = exports.default;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(18).Buffer);\n      /***/\n    },\n    /* 121 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.byteLength = byteLength;\n      exports.toByteArray = toByteArray;\n      exports.fromByteArray = fromByteArray;\n      var lookup = [];\n      var revLookup = [];\n      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n      for (var i = 0, len = code.length; i < len; ++i) {\n        lookup[i] = code[i];\n        revLookup[code.charCodeAt(i)] = i;\n      }\n\n      revLookup['-'.charCodeAt(0)] = 62;\n      revLookup['_'.charCodeAt(0)] = 63;\n\n      function placeHoldersCount(b64) {\n        var len = b64.length;\n\n        if (len % 4 > 0) {\n          throw new Error('Invalid string. Length must be a multiple of 4');\n        } // the number of equal signs (place holders)\n        // if there are two placeholders, than the two characters before it\n        // represent one byte\n        // if there is only one, then the three characters before it represent 2 bytes\n        // this is just a cheap hack to not do indexOf twice\n\n\n        return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n      }\n\n      function byteLength(b64) {\n        // base64 is 4/3 + up to two characters of the original data\n        return b64.length * 3 / 4 - placeHoldersCount(b64);\n      }\n\n      function toByteArray(b64) {\n        var i, j, l, tmp, placeHolders, arr;\n        var len = b64.length;\n        placeHolders = placeHoldersCount(b64);\n        arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars\n\n        l = placeHolders > 0 ? len - 4 : len;\n        var L = 0;\n\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n          arr[L++] = tmp >> 16 & 0xFF;\n          arr[L++] = tmp >> 8 & 0xFF;\n          arr[L++] = tmp & 0xFF;\n        }\n\n        if (placeHolders === 2) {\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n          arr[L++] = tmp & 0xFF;\n        } else if (placeHolders === 1) {\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n          arr[L++] = tmp >> 8 & 0xFF;\n          arr[L++] = tmp & 0xFF;\n        }\n\n        return arr;\n      }\n\n      function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n      }\n\n      function encodeChunk(uint8, start, end) {\n        var tmp;\n        var output = [];\n\n        for (var i = start; i < end; i += 3) {\n          tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n          output.push(tripletToBase64(tmp));\n        }\n\n        return output.join('');\n      }\n\n      function fromByteArray(uint8) {\n        var tmp;\n        var len = uint8.length;\n        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n        var output = '';\n        var parts = [];\n        var maxChunkLength = 16383; // must be multiple of 3\n        // go through the array every three bytes, we'll deal with trailing stuff later\n\n        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n        } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n        if (extraBytes === 1) {\n          tmp = uint8[len - 1];\n          output += lookup[tmp >> 2];\n          output += lookup[tmp << 4 & 0x3F];\n          output += '==';\n        } else if (extraBytes === 2) {\n          tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n          output += lookup[tmp >> 10];\n          output += lookup[tmp >> 4 & 0x3F];\n          output += lookup[tmp << 2 & 0x3F];\n          output += '=';\n        }\n\n        parts.push(output);\n        return parts.join('');\n      }\n      /***/\n\n    },\n    /* 122 */\n\n    /***/\n    function (module, exports) {\n      exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n        var e, m;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var nBits = -7;\n        var i = isLE ? nBytes - 1 : 0;\n        var d = isLE ? -1 : 1;\n        var s = buffer[offset + i];\n        i += d;\n        e = s & (1 << -nBits) - 1;\n        s >>= -nBits;\n        nBits += eLen;\n\n        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        m = e & (1 << -nBits) - 1;\n        e >>= -nBits;\n        nBits += mLen;\n\n        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n        if (e === 0) {\n          e = 1 - eBias;\n        } else if (e === eMax) {\n          return m ? NaN : (s ? -1 : 1) * Infinity;\n        } else {\n          m = m + Math.pow(2, mLen);\n          e = e - eBias;\n        }\n\n        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n      };\n\n      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n        var e, m, c;\n        var eLen = nBytes * 8 - mLen - 1;\n        var eMax = (1 << eLen) - 1;\n        var eBias = eMax >> 1;\n        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n        var i = isLE ? 0 : nBytes - 1;\n        var d = isLE ? 1 : -1;\n        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n        value = Math.abs(value);\n\n        if (isNaN(value) || value === Infinity) {\n          m = isNaN(value) ? 1 : 0;\n          e = eMax;\n        } else {\n          e = Math.floor(Math.log(value) / Math.LN2);\n\n          if (value * (c = Math.pow(2, -e)) < 1) {\n            e--;\n            c *= 2;\n          }\n\n          if (e + eBias >= 1) {\n            value += rt / c;\n          } else {\n            value += rt * Math.pow(2, 1 - eBias);\n          }\n\n          if (value * c >= 2) {\n            e++;\n            c /= 2;\n          }\n\n          if (e + eBias >= eMax) {\n            m = 0;\n            e = eMax;\n          } else if (e + eBias >= 1) {\n            m = (value * c - 1) * Math.pow(2, mLen);\n            e = e + eBias;\n          } else {\n            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n            e = 0;\n          }\n        }\n\n        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n        e = e << mLen | m;\n        eLen += mLen;\n\n        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n        buffer[offset + i - d] |= s * 128;\n      };\n      /***/\n\n    },\n    /* 123 */\n\n    /***/\n    function (module, exports) {\n      var toString = {}.toString;\n\n      module.exports = Array.isArray || function (arr) {\n        return toString.call(arr) == '[object Array]';\n      };\n      /***/\n\n    },\n    /* 124 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n      /**\n       * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n       */\n\n      exports.encode = function (number) {\n        if (0 <= number && number < intToCharMap.length) {\n          return intToCharMap[number];\n        }\n\n        throw new TypeError(\"Must be between 0 and 63: \" + number);\n      };\n      /**\n       * Decode a single base 64 character code digit to an integer. Returns -1 on\n       * failure.\n       */\n\n\n      exports.decode = function (charCode) {\n        var bigA = 65; // 'A'\n\n        var bigZ = 90; // 'Z'\n\n        var littleA = 97; // 'a'\n\n        var littleZ = 122; // 'z'\n\n        var zero = 48; // '0'\n\n        var nine = 57; // '9'\n\n        var plus = 43; // '+'\n\n        var slash = 47; // '/'\n\n        var littleOffset = 26;\n        var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n        if (bigA <= charCode && charCode <= bigZ) {\n          return charCode - bigA;\n        } // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\n\n        if (littleA <= charCode && charCode <= littleZ) {\n          return charCode - littleA + littleOffset;\n        } // 52 - 61: 0123456789\n\n\n        if (zero <= charCode && charCode <= nine) {\n          return charCode - zero + numberOffset;\n        } // 62: +\n\n\n        if (charCode == plus) {\n          return 62;\n        } // 63: /\n\n\n        if (charCode == slash) {\n          return 63;\n        } // Invalid base64 digit.\n\n\n        return -1;\n      };\n      /***/\n\n    },\n    /* 125 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2014 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(8);\n      /**\n       * Determine whether mappingB is after mappingA with respect to generated\n       * position.\n       */\n\n\n      function generatedPositionAfter(mappingA, mappingB) {\n        // Optimized for most common case\n        var lineA = mappingA.generatedLine;\n        var lineB = mappingB.generatedLine;\n        var columnA = mappingA.generatedColumn;\n        var columnB = mappingB.generatedColumn;\n        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n      }\n      /**\n       * A data structure to provide a sorted view of accumulated mappings in a\n       * performance conscious manner. It trades a neglibable overhead in general\n       * case for a large speedup in case of mappings being added in order.\n       */\n\n\n      function MappingList() {\n        this._array = [];\n        this._sorted = true; // Serves as infimum\n\n        this._last = {\n          generatedLine: -1,\n          generatedColumn: 0\n        };\n      }\n      /**\n       * Iterate through internal items. This method takes the same arguments that\n       * `Array.prototype.forEach` takes.\n       *\n       * NOTE: The order of the mappings is NOT guaranteed.\n       */\n\n\n      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n      };\n      /**\n       * Add the given source mapping.\n       *\n       * @param Object aMapping\n       */\n\n\n      MappingList.prototype.add = function MappingList_add(aMapping) {\n        if (generatedPositionAfter(this._last, aMapping)) {\n          this._last = aMapping;\n\n          this._array.push(aMapping);\n        } else {\n          this._sorted = false;\n\n          this._array.push(aMapping);\n        }\n      };\n      /**\n       * Returns the flat, sorted array of mappings. The mappings are sorted by\n       * generated position.\n       *\n       * WARNING: This method returns internal data without copying, for\n       * performance. The return value must NOT be mutated, and should be treated as\n       * an immutable borrow. If you want to take ownership, you must make your own\n       * copy.\n       */\n\n\n      MappingList.prototype.toArray = function MappingList_toArray() {\n        if (!this._sorted) {\n          this._array.sort(util.compareByGeneratedPositionsInflated);\n\n          this._sorted = true;\n        }\n\n        return this._array;\n      };\n\n      exports.MappingList = MappingList;\n      /***/\n    },\n    /* 126 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(8);\n\n      var binarySearch = __webpack_require__(127);\n\n      var ArraySet = __webpack_require__(64).ArraySet;\n\n      var base64VLQ = __webpack_require__(63);\n\n      var quickSort = __webpack_require__(128).quickSort;\n\n      function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n      }\n\n      SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {\n        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the\n      // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n      // are lazily instantiated, accessed via the `_generatedMappings` and\n      // `_originalMappings` getters respectively, and we only parse the mappings\n      // and create these arrays once queried for a source location. We jump through\n      // these hoops because there can be many thousands of mappings, and parsing\n      // them is expensive, so we only want to do it if we must.\n      //\n      // Each object in the arrays is of the form:\n      //\n      //     {\n      //       generatedLine: The line number in the generated code,\n      //       generatedColumn: The column number in the generated code,\n      //       source: The path to the original source file that generated this\n      //               chunk of code,\n      //       originalLine: The line number in the original source that\n      //                     corresponds to this chunk of generated code,\n      //       originalColumn: The column number in the original source that\n      //                       corresponds to this chunk of generated code,\n      //       name: The name of the original symbol which generated this chunk of\n      //             code.\n      //     }\n      //\n      // All properties except for `generatedLine` and `generatedColumn` can be\n      // `null`.\n      //\n      // `_generatedMappings` is ordered by the generated positions.\n      //\n      // `_originalMappings` is ordered by the original positions.\n\n      SourceMapConsumer.prototype.__generatedMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__generatedMappings;\n        }\n      });\n      SourceMapConsumer.prototype.__originalMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__originalMappings;\n        }\n      });\n\n      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n        var c = aStr.charAt(index);\n        return c === \";\" || c === \",\";\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        throw new Error(\"Subclasses must implement _parseMappings\");\n      };\n\n      SourceMapConsumer.GENERATED_ORDER = 1;\n      SourceMapConsumer.ORIGINAL_ORDER = 2;\n      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n      SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n      /**\n       * Iterate over each mapping between an original source/line/column and a\n       * generated line/column in this source map.\n       *\n       * @param Function aCallback\n       *        The function that is called with each mapping.\n       * @param Object aContext\n       *        Optional. If specified, this object will be the value of `this` every\n       *        time that `aCallback` is called.\n       * @param aOrder\n       *        Either `SourceMapConsumer.GENERATED_ORDER` or\n       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n       *        iterate over the mappings sorted by the generated file's line/column\n       *        order or the original's source/line/column order, respectively. Defaults to\n       *        `SourceMapConsumer.GENERATED_ORDER`.\n       */\n\n      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n          var source = mapping.source === null ? null : this._sources.at(mapping.source);\n          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n          return {\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : this._names.at(mapping.name)\n          };\n        }, this).forEach(aCallback, context);\n      };\n      /**\n       * Returns all generated line and column information for the original source,\n       * line, and column provided. If no column is provided, returns all mappings\n       * corresponding to a either the line we are searching for or the next\n       * closest line that has any mappings. Otherwise, returns all mappings\n       * corresponding to the given line and either the column we are searching for\n       * or the next closest column that has any offsets.\n       *\n       * The only argument is an object with the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number is 1-based.\n       *   - column: Optional. the column number in the original source.\n       *    The column number is 0-based.\n       *\n       * and an array of objects is returned, each with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *    line number is 1-based.\n       *   - column: The column number in the generated source, or null.\n       *    The column number is 0-based.\n       */\n\n\n      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n        // returns the index of the closest mapping less than the needle. By\n        // setting needle.originalColumn to 0, we thus find the last mapping for\n        // the given line, provided such a mapping exists.\n\n        var needle = {\n          source: util.getArg(aArgs, 'source'),\n          originalLine: line,\n          originalColumn: util.getArg(aArgs, 'column', 0)\n        };\n        needle.source = this._findSourceIndex(needle.source);\n\n        if (needle.source < 0) {\n          return [];\n        }\n\n        var mappings = [];\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n\n            while (mapping && mapping.originalLine === originalLine) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          } else {\n            var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n\n            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          }\n        }\n\n        return mappings;\n      };\n\n      exports.SourceMapConsumer = SourceMapConsumer;\n      /**\n       * A BasicSourceMapConsumer instance represents a parsed source map which we can\n       * query for information about the original file positions by giving it a file\n       * position in the generated source.\n       *\n       * The first parameter is the raw source map (either as a JSON string, or\n       * already parsed to an object). According to the spec, source maps have the\n       * following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - sources: An array of URLs to the original source files.\n       *   - names: An array of identifiers which can be referrenced by individual mappings.\n       *   - sourceRoot: Optional. The URL root from which all sources are relative.\n       *   - sourcesContent: Optional. An array of contents of the original source files.\n       *   - mappings: A string of base64 VLQs which contain the actual mappings.\n       *   - file: Optional. The generated file this source map is associated with.\n       *\n       * Here is an example source map, taken from the source map spec[0]:\n       *\n       *     {\n       *       version : 3,\n       *       file: \"out.js\",\n       *       sourceRoot : \"\",\n       *       sources: [\"foo.js\", \"bar.js\"],\n       *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *       mappings: \"AA,AB;;ABCDE;\"\n       *     }\n       *\n       * The second parameter, if given, is a string whose value is the URL\n       * at which the source map was found.  This URL is used to compute the\n       * sources array.\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n       */\n\n      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n        // requires the array) to play nice here.\n\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a\n        // string rather than a number, so we use loose equality checking here.\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        if (sourceRoot) {\n          sourceRoot = util.normalize(sourceRoot);\n        }\n\n        sources = sources.map(String) // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize) // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function (source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n        }); // Pass `true` below to allow duplicate names and sources. While source maps\n        // are intended to be compressed and deduplicated, the TypeScript compiler\n        // sometimes generates source maps with duplicates in them. See Github issue\n        // #72 and bugzil.la/889492.\n\n        this._names = ArraySet.fromArray(names.map(String), true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this._absoluteSources = this._sources.toArray().map(function (s) {\n          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n        });\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this._sourceMapURL = aSourceMapURL;\n        this.file = file;\n      }\n\n      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n      /**\n       * Utility function to find the index of a source.  Returns -1 if not\n       * found.\n       */\n\n      BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {\n        var relativeSource = aSource;\n\n        if (this.sourceRoot != null) {\n          relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n\n        if (this._sources.has(relativeSource)) {\n          return this._sources.indexOf(relativeSource);\n        } // Maybe aSource is an absolute URL as returned by |sources|.  In\n        // this case we can't simply undo the transform.\n\n\n        var i;\n\n        for (i = 0; i < this._absoluteSources.length; ++i) {\n          if (this._absoluteSources[i] == aSource) {\n            return i;\n          }\n        }\n\n        return -1;\n      };\n      /**\n       * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n       *\n       * @param SourceMapGenerator aSourceMap\n       *        The source map that will be consumed.\n       * @param String aSourceMapURL\n       *        The URL at which the source map can be found (optional)\n       * @returns BasicSourceMapConsumer\n       */\n\n\n      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n        var smc = Object.create(BasicSourceMapConsumer.prototype);\n        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file;\n        smc._sourceMapURL = aSourceMapURL;\n        smc._absoluteSources = smc._sources.toArray().map(function (s) {\n          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n        }); // Because we are modifying the entries (by converting string sources and\n        // names to indices into the sources and names ArraySets), we have to make\n        // a copy of the entry or else bad things happen. Shared mutable state\n        // strikes again! See github issue #191.\n\n        var generatedMappings = aSourceMap._mappings.toArray().slice();\n\n        var destGeneratedMappings = smc.__generatedMappings = [];\n        var destOriginalMappings = smc.__originalMappings = [];\n\n        for (var i = 0, length = generatedMappings.length; i < length; i++) {\n          var srcMapping = generatedMappings[i];\n          var destMapping = new Mapping();\n          destMapping.generatedLine = srcMapping.generatedLine;\n          destMapping.generatedColumn = srcMapping.generatedColumn;\n\n          if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n\n            if (srcMapping.name) {\n              destMapping.name = names.indexOf(srcMapping.name);\n            }\n\n            destOriginalMappings.push(destMapping);\n          }\n\n          destGeneratedMappings.push(destMapping);\n        }\n\n        quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n        return smc;\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      BasicSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          return this._absoluteSources.slice();\n        }\n      });\n      /**\n       * Provide the JIT with a nice shape / hidden class.\n       */\n\n      function Mapping() {\n        this.generatedLine = 0;\n        this.generatedColumn = 0;\n        this.source = null;\n        this.originalLine = null;\n        this.originalColumn = null;\n        this.name = null;\n      }\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var length = aStr.length;\n        var index = 0;\n        var cachedSegments = {};\n        var temp = {};\n        var originalMappings = [];\n        var generatedMappings = [];\n        var mapping, str, segment, end, value;\n\n        while (index < length) {\n          if (aStr.charAt(index) === ';') {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n          } else if (aStr.charAt(index) === ',') {\n            index++;\n          } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,\n            // many segments often have the same encoding. We can exploit this\n            // fact by caching the parsed variable length fields of each segment,\n            // allowing us to avoid a second parse if we encounter the same\n            // segment again.\n\n            for (end = index; end < length; end++) {\n              if (this._charIsMappingSeparator(aStr, end)) {\n                break;\n              }\n            }\n\n            str = aStr.slice(index, end);\n            segment = cachedSegments[str];\n\n            if (segment) {\n              index += str.length;\n            } else {\n              segment = [];\n\n              while (index < end) {\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n              }\n\n              if (segment.length === 2) {\n                throw new Error('Found a source, but no line and column');\n              }\n\n              if (segment.length === 3) {\n                throw new Error('Found a source and line, but no column');\n              }\n\n              cachedSegments[str] = segment;\n            } // Generated column.\n\n\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n\n            if (segment.length > 1) {\n              // Original source.\n              mapping.source = previousSource + segment[1];\n              previousSource += segment[1]; // Original line.\n\n              mapping.originalLine = previousOriginalLine + segment[2];\n              previousOriginalLine = mapping.originalLine; // Lines are stored 0-based\n\n              mapping.originalLine += 1; // Original column.\n\n              mapping.originalColumn = previousOriginalColumn + segment[3];\n              previousOriginalColumn = mapping.originalColumn;\n\n              if (segment.length > 4) {\n                // Original name.\n                mapping.name = previousName + segment[4];\n                previousName += segment[4];\n              }\n            }\n\n            generatedMappings.push(mapping);\n\n            if (typeof mapping.originalLine === 'number') {\n              originalMappings.push(mapping);\n            }\n          }\n        }\n\n        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = generatedMappings;\n        quickSort(originalMappings, util.compareByOriginalPositions);\n        this.__originalMappings = originalMappings;\n      };\n      /**\n       * Find the mapping that best matches the hypothetical \"needle\" mapping that\n       * we are searching for in the given \"haystack\" of mappings.\n       */\n\n\n      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        // To return the position we are searching for, we must first find the\n        // mapping for the given position and then return the opposite position it\n        // points to. Because the mappings are sorted, we can use binary search to\n        // find the best mapping.\n        if (aNeedle[aLineName] <= 0) {\n          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n\n        if (aNeedle[aColumnName] < 0) {\n          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n      };\n      /**\n       * Compute the last column for each generated mapping. The last column is\n       * inclusive.\n       */\n\n\n      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n        for (var index = 0; index < this._generatedMappings.length; ++index) {\n          var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We\n          // can come up with an optimistic estimate, however, by assuming that\n          // mappings are contiguous (i.e. given two consecutive mappings, the\n          // first mapping ends where the second one starts).\n\n          if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n              continue;\n            }\n          } // The last mapping for each line spans the entire line.\n\n\n          mapping.lastGeneratedColumn = Infinity;\n        }\n      };\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the generated source.  The column\n       *     number is 0-based.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the original source, or null.  The\n       *     column number is 0-based.\n       *   - name: The original identifier, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._generatedMappings[index];\n\n          if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, 'source', null);\n\n            if (source !== null) {\n              source = this._sources.at(source);\n              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n            }\n\n            var name = util.getArg(mapping, 'name', null);\n\n            if (name !== null) {\n              name = this._names.at(name);\n            }\n\n            return {\n              source: source,\n              line: util.getArg(mapping, 'originalLine', null),\n              column: util.getArg(mapping, 'originalColumn', null),\n              name: name\n            };\n          }\n        }\n\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n          return false;\n        }\n\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n          return sc == null;\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n          return null;\n        }\n\n        var index = this._findSourceIndex(aSource);\n\n        if (index >= 0) {\n          return this.sourcesContent[index];\n        }\n\n        var relativeSource = aSource;\n\n        if (this.sourceRoot != null) {\n          relativeSource = util.relative(this.sourceRoot, relativeSource);\n        }\n\n        var url;\n\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n          // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n          // many users. We can help them out when they expect file:// URIs to\n          // behave like it would if they were running a local HTTP server. See\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n          var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n\n          if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n          }\n\n          if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n          }\n        } // This function is used recursively from\n        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n        // don't want to throw if we can't find the source - we just want to\n        // return null, so we provide a flag to exit gracefully.\n\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the original source.  The column\n       *     number is 0-based.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the generated source, or null.\n       *     The column number is 0-based.\n       */\n\n\n      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var source = util.getArg(aArgs, 'source');\n        source = this._findSourceIndex(source);\n\n        if (source < 0) {\n          return {\n            line: null,\n            column: null,\n            lastColumn: null\n          };\n        }\n\n        var needle = {\n          source: source,\n          originalLine: util.getArg(aArgs, 'line'),\n          originalColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (mapping.source === needle.source) {\n            return {\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            };\n          }\n        }\n\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      };\n\n      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n      /**\n       * An IndexedSourceMapConsumer instance represents a parsed source map which\n       * we can query for information. It differs from BasicSourceMapConsumer in\n       * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n       * input.\n       *\n       * The first parameter is a raw source map (either as a JSON string, or already\n       * parsed to an object). According to the spec for indexed source maps, they\n       * have the following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - file: Optional. The generated file this source map is associated with.\n       *   - sections: A list of section definitions.\n       *\n       * Each value under the \"sections\" field has two fields:\n       *   - offset: The offset into the original specified at which this section\n       *       begins to apply, defined as an object with a \"line\" and \"column\"\n       *       field.\n       *   - map: A source map definition. This source map could also be indexed,\n       *       but doesn't have to be.\n       *\n       * Instead of the \"map\" field, it's also possible to have a \"url\" field\n       * specifying a URL to retrieve a source map from, but that's currently\n       * unsupported.\n       *\n       * Here's an example source map, taken from the source map spec[0], but\n       * modified to omit a section which uses the \"url\" field.\n       *\n       *  {\n       *    version : 3,\n       *    file: \"app.js\",\n       *    sections: [{\n       *      offset: {line:100, column:10},\n       *      map: {\n       *        version : 3,\n       *        file: \"section.js\",\n       *        sources: [\"foo.js\", \"bar.js\"],\n       *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *        mappings: \"AAAA,E;;ABCDE;\"\n       *      }\n       *    }],\n       *  }\n       *\n       * The second parameter, if given, is a string whose value is the URL\n       * at which the source map was found.  This URL is used to compute the\n       * sources array.\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n       */\n\n      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = util.parseSourceMapInput(aSourceMap);\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sections = util.getArg(sourceMap, 'sections');\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        var lastOffset = {\n          line: -1,\n          column: 0\n        };\n        this._sections = sections.map(function (s) {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error('Support for url field in sections not implemented.');\n          }\n\n          var offset = util.getArg(s, 'offset');\n          var offsetLine = util.getArg(offset, 'line');\n          var offsetColumn = util.getArg(offset, 'column');\n\n          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error('Section offsets must be ordered and non-overlapping.');\n          }\n\n          lastOffset = offset;\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n          };\n        });\n      }\n\n      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n      IndexedSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          var sources = [];\n\n          for (var i = 0; i < this._sections.length; i++) {\n            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n              sources.push(this._sections[i].consumer.sources[j]);\n            }\n          }\n\n          return sources;\n        }\n      });\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the generated source.  The column\n       *     number is 0-based.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.  The\n       *     line number is 1-based.\n       *   - column: The column number in the original source, or null.  The\n       *     column number is 0-based.\n       *   - name: The original identifier, or null.\n       */\n\n      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        }; // Find the section containing the generated position we're trying to map\n        // to an original position.\n\n        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\n          if (cmp) {\n            return cmp;\n          }\n\n          return needle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n\n        if (!section) {\n          return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n          };\n        }\n\n        return section.consumer.originalPositionFor({\n          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n          bias: aArgs.bias\n        });\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n        return this._sections.every(function (s) {\n          return s.consumer.hasContentsOfAllSources();\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var content = section.consumer.sourceContentFor(aSource, true);\n\n          if (content) {\n            return content;\n          }\n        }\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.  The line number\n       *     is 1-based.\n       *   - column: The column number in the original source.  The column\n       *     number is 0-based.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.  The\n       *     line number is 1-based. \n       *   - column: The column number in the generated source, or null.\n       *     The column number is 0-based.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i]; // Only consider this section if the requested source is in the list of\n          // sources of the consumer.\n\n          if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n            continue;\n          }\n\n          var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\n          if (generatedPosition) {\n            var ret = {\n              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n          }\n        }\n\n        return {\n          line: null,\n          column: null\n        };\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var sectionMappings = section.consumer._generatedMappings;\n\n          for (var j = 0; j < sectionMappings.length; j++) {\n            var mapping = sectionMappings[j];\n\n            var source = section.consumer._sources.at(mapping.source);\n\n            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n\n            this._sources.add(source);\n\n            source = this._sources.indexOf(source);\n            var name = null;\n\n            if (mapping.name) {\n              name = section.consumer._names.at(mapping.name);\n\n              this._names.add(name);\n\n              name = this._names.indexOf(name);\n            } // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n\n\n            var adjustedMapping = {\n              source: source,\n              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n              originalLine: mapping.originalLine,\n              originalColumn: mapping.originalColumn,\n              name: name\n            };\n\n            this.__generatedMappings.push(adjustedMapping);\n\n            if (typeof adjustedMapping.originalLine === 'number') {\n              this.__originalMappings.push(adjustedMapping);\n            }\n          }\n        }\n\n        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n        quickSort(this.__originalMappings, util.compareByOriginalPositions);\n      };\n\n      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n      /***/\n    },\n    /* 127 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.GREATEST_LOWER_BOUND = 1;\n      exports.LEAST_UPPER_BOUND = 2;\n      /**\n       * Recursive implementation of binary search.\n       *\n       * @param aLow Indices here and lower do not contain the needle.\n       * @param aHigh Indices here and higher do not contain the needle.\n       * @param aNeedle The element being searched for.\n       * @param aHaystack The non-empty array being searched.\n       * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       */\n\n      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        // This function terminates when one of the following is true:\n        //\n        //   1. We find the exact element we are looking for.\n        //\n        //   2. We did not find the exact element, but we can return the index of\n        //      the next-closest element.\n        //\n        //   3. We did not find the exact element, and there is no next-closest\n        //      element than the one we are searching for, so we return -1.\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\n        if (cmp === 0) {\n          // Found the element we are looking for.\n          return mid;\n        } else if (cmp > 0) {\n          // Our needle is greater than aHaystack[mid].\n          if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n          } // The exact needle element was not found in this haystack. Determine if\n          // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n          } else {\n            return mid;\n          }\n        } else {\n          // Our needle is less than aHaystack[mid].\n          if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n          } // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n          } else {\n            return aLow < 0 ? -1 : aLow;\n          }\n        }\n      }\n      /**\n       * This is an implementation of binary search which will always try and return\n       * the index of the closest element if there is no exact hit. This is because\n       * mappings between original and generated line/col pairs are single points,\n       * and there is an implicit region between each of them, so a miss just means\n       * that you aren't on the very start of a region.\n       *\n       * @param aNeedle The element you are looking for.\n       * @param aHaystack The array that is being searched.\n       * @param aCompare A function which takes the needle and an element in the\n       *     array and returns -1, 0, or 1 depending on whether the needle is less\n       *     than, equal to, or greater than the element, respectively.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n       */\n\n\n      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n          return -1;\n        }\n\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\n        if (index < 0) {\n          return -1;\n        } // We have found either the exact element, or the next-closest element than\n        // the one we are searching for. However, there may be more than one such\n        // element. Make sure we always return the smallest of these.\n\n\n        while (index - 1 >= 0) {\n          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n          }\n\n          --index;\n        }\n\n        return index;\n      };\n      /***/\n\n    },\n    /* 128 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      // It turns out that some (most?) JavaScript engines don't self-host\n      // `Array.prototype.sort`. This makes sense because C++ will likely remain\n      // faster than JS when doing raw CPU-intensive sorting. However, when using a\n      // custom comparator function, calling back and forth between the VM's C++ and\n      // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n      // worse generated code for the comparator function than would be optimal. In\n      // fact, when sorting with a comparator, these costs outweigh the benefits of\n      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n      // a ~3500ms mean speed-up in `bench/bench.html`.\n\n      /**\n       * Swap the elements indexed by `x` and `y` in the array `ary`.\n       *\n       * @param {Array} ary\n       *        The array.\n       * @param {Number} x\n       *        The index of the first item.\n       * @param {Number} y\n       *        The index of the second item.\n       */\n      function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n      }\n      /**\n       * Returns a random integer within the range `low .. high` inclusive.\n       *\n       * @param {Number} low\n       *        The lower bound on the range.\n       * @param {Number} high\n       *        The upper bound on the range.\n       */\n\n\n      function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n      }\n      /**\n       * The Quick Sort algorithm.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       * @param {Number} p\n       *        Start index of the array\n       * @param {Number} r\n       *        End index of the array\n       */\n\n\n      function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n          // (1) Partitioning.\n          //\n          // The partitioning chooses a pivot between `p` and `r` and moves all\n          // elements that are less than or equal to the pivot to the before it, and\n          // all the elements that are greater than it after it. The effect is that\n          // once partition is done, the pivot is in the exact place it will be when\n          // the array is put in sorted order, and it will not need to be moved\n          // again. This runs in O(n) time.\n          // Always choose a random pivot so that an input array which is reverse\n          // sorted does not cause O(n^2) running time.\n          var pivotIndex = randomIntInRange(p, r);\n          var i = p - 1;\n          swap(ary, pivotIndex, r);\n          var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold\n          // true:\n          //\n          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n          //\n          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\n          for (var j = p; j < r; j++) {\n            if (comparator(ary[j], pivot) <= 0) {\n              i += 1;\n              swap(ary, i, j);\n            }\n          }\n\n          swap(ary, i + 1, j);\n          var q = i + 1; // (2) Recurse on each half.\n\n          doQuickSort(ary, comparator, p, q - 1);\n          doQuickSort(ary, comparator, q + 1, r);\n        }\n      }\n      /**\n       * Sort the given array in-place with the given comparator function.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       */\n\n\n      exports.quickSort = function (ary, comparator) {\n        doQuickSort(ary, comparator, 0, ary.length - 1);\n      };\n      /***/\n\n    },\n    /* 129 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var SourceMapGenerator = __webpack_require__(62).SourceMapGenerator;\n\n      var util = __webpack_require__(8); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n      // operating systems these days (capturing the result).\n\n\n      var REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\n      var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n      // the source-map library are loaded. This MUST NOT CHANGE across\n      // versions!\n\n      var isSourceNode = \"$$$isSourceNode$$$\";\n      /**\n       * SourceNodes provide a way to abstract over interpolating/concatenating\n       * snippets of generated JavaScript source code while maintaining the line and\n       * column information associated with the original source code.\n       *\n       * @param aLine The original line number.\n       * @param aColumn The original column number.\n       * @param aSource The original source's filename.\n       * @param aChunks Optional. An array of strings which are snippets of\n       *        generated JS, or other SourceNodes.\n       * @param aName The original identifier.\n       */\n\n      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        this[isSourceNode] = true;\n        if (aChunks != null) this.add(aChunks);\n      }\n      /**\n       * Creates a SourceNode from generated code and a SourceMapConsumer.\n       *\n       * @param aGeneratedCode The generated code\n       * @param aSourceMapConsumer The SourceMap for the generated code\n       * @param aRelativePath Optional. The path that relative sources in the\n       *        SourceMapConsumer should be relative to.\n       */\n\n\n      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        // The SourceNode we want to fill with the generated code\n        // and the SourceMap\n        var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n        // while all odd indices are the newlines between two adjacent lines\n        // (since `REGEX_NEWLINE` captures its match).\n        // Processed fragments are accessed by calling `shiftNextLine`.\n\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n        var remainingLinesIndex = 0;\n\n        var shiftNextLine = function shiftNextLine() {\n          var lineContents = getNextLine(); // The last line of a file might not have a newline.\n\n          var newLine = getNextLine() || \"\";\n          return lineContents + newLine;\n\n          function getNextLine() {\n            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n          }\n        }; // We need to remember the position of \"remainingLines\"\n\n\n        var lastGeneratedLine = 1,\n            lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n        // To extract it current and last mapping is used.\n        // Here we store the last mapping.\n\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n              // Associate first line with \"lastMapping\"\n              addMappingWithCode(lastMapping, shiftNextLine());\n              lastGeneratedLine++;\n              lastGeneratedColumn = 0; // The remaining code is added without mapping\n            } else {\n              // There is no new line in between.\n              // Associate the code between \"lastGeneratedColumn\" and\n              // \"mapping.generatedColumn\" with \"lastMapping\"\n              var nextLine = remainingLines[remainingLinesIndex] || '';\n              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n              addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n              lastMapping = mapping;\n              return;\n            }\n          } // We add the generated code until the first mapping\n          // to the SourceNode without any mapping.\n          // Each line is added as separate string.\n\n\n          while (lastGeneratedLine < mapping.generatedLine) {\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n          }\n\n          if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[remainingLinesIndex] || '';\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n          }\n\n          lastMapping = mapping;\n        }, this); // We have processed all mappings.\n\n        if (remainingLinesIndex < remainingLines.length) {\n          if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n          } // and add the remaining lines without any mapping\n\n\n          node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n        } // Copy sourcesContent into SourceNode\n\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aRelativePath != null) {\n              sourceFile = util.join(aRelativePath, sourceFile);\n            }\n\n            node.setSourceContent(sourceFile, content);\n          }\n        });\n        return node;\n\n        function addMappingWithCode(mapping, code) {\n          if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n          } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n          }\n        }\n      };\n      /**\n       * Add a chunk of generated JS to this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n          aChunk.forEach(function (chunk) {\n            this.add(chunk);\n          }, this);\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          if (aChunk) {\n            this.children.push(aChunk);\n          }\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Add a chunk of generated JS to the beginning of this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n          for (var i = aChunk.length - 1; i >= 0; i--) {\n            this.prepend(aChunk[i]);\n          }\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          this.children.unshift(aChunk);\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Walk over the tree of JS snippets in this node and its children. The\n       * walking function is called once for each snippet of JS and is passed that\n       * snippet and the its original associated source's line/column location.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          chunk = this.children[i];\n\n          if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n          } else {\n            if (chunk !== '') {\n              aFn(chunk, {\n                source: this.source,\n                line: this.line,\n                column: this.column,\n                name: this.name\n              });\n            }\n          }\n        }\n      };\n      /**\n       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n       * each of `this.children`.\n       *\n       * @param aSep The separator.\n       */\n\n\n      SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n\n        if (len > 0) {\n          newChildren = [];\n\n          for (i = 0; i < len - 1; i++) {\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n          }\n\n          newChildren.push(this.children[i]);\n          this.children = newChildren;\n        }\n\n        return this;\n      };\n      /**\n       * Call String.prototype.replace on the very right-most source snippet. Useful\n       * for trimming whitespace from the end of a source node, etc.\n       *\n       * @param aPattern The pattern to replace.\n       * @param aReplacement The thing to replace the pattern with.\n       */\n\n\n      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n\n        if (lastChild[isSourceNode]) {\n          lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n          this.children.push(''.replace(aPattern, aReplacement));\n        }\n\n        return this;\n      };\n      /**\n       * Set the source content for a source file. This will be added to the SourceMapGenerator\n       * in the sourcesContent field.\n       *\n       * @param aSourceFile The filename of the source file\n       * @param aSourceContent The content of the source file\n       */\n\n\n      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n      };\n      /**\n       * Walk over the tree of SourceNodes. The walking function is called for each\n       * source file content and is passed the filename and source content.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n          }\n        }\n\n        var sources = Object.keys(this.sourceContents);\n\n        for (var i = 0, len = sources.length; i < len; i++) {\n          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n      };\n      /**\n       * Return the string representation of this source node. Walks over the tree\n       * and concatenates all the various snippets together to one string.\n       */\n\n\n      SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = \"\";\n        this.walk(function (chunk) {\n          str += chunk;\n        });\n        return str;\n      };\n      /**\n       * Returns the string representation of this source node along with a source\n       * map.\n       */\n\n\n      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n          code: \"\",\n          line: 1,\n          column: 0\n        };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n          generated.code += chunk;\n\n          if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              generated: {\n                line: generated.line,\n                column: generated.column\n              }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          }\n\n          for (var idx = 0, length = chunk.length; idx < length; idx++) {\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n              generated.line++;\n              generated.column = 0; // Mappings end at eol\n\n              if (idx + 1 === length) {\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n              } else if (sourceMappingActive) {\n                map.addMapping({\n                  source: original.source,\n                  original: {\n                    line: original.line,\n                    column: original.column\n                  },\n                  generated: {\n                    line: generated.line,\n                    column: generated.column\n                  },\n                  name: original.name\n                });\n              }\n            } else {\n              generated.column++;\n            }\n          }\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n          map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n          code: generated.code,\n          map: map\n        };\n      };\n\n      exports.SourceNode = SourceNode;\n      /***/\n    },\n    /* 130 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 131 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Comment = __webpack_require__(19);\n\n      var Parser = __webpack_require__(66);\n\n      var NestedDeclaration = __webpack_require__(140);\n\n      var scssTokenizer = __webpack_require__(141);\n\n      var ScssParser = function (_Parser) {\n        _inherits(ScssParser, _Parser);\n\n        function ScssParser() {\n          _classCallCheck(this, ScssParser);\n\n          return _possibleConstructorReturn(this, _Parser.apply(this, arguments));\n        }\n\n        ScssParser.prototype.createTokenizer = function createTokenizer() {\n          this.tokenizer = scssTokenizer(this.input);\n        };\n\n        ScssParser.prototype.rule = function rule(tokens) {\n          var withColon = false;\n          var brackets = 0;\n          var value = '';\n\n          for (var _iterator = tokens, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var i = _ref;\n\n            if (withColon) {\n              if (i[0] !== 'comment' && i[0] !== '{') {\n                value += i[1];\n              }\n            } else if (i[0] === 'space' && i[1].indexOf('\\n') !== -1) {\n              break;\n            } else if (i[0] === '(') {\n              brackets += 1;\n            } else if (i[0] === ')') {\n              brackets -= 1;\n            } else if (brackets === 0 && i[0] === ':') {\n              withColon = true;\n            }\n          }\n\n          if (!withColon || value.trim() === '' || /^[a-zA-Z-:#]/.test(value)) {\n            _Parser.prototype.rule.call(this, tokens);\n          } else {\n            tokens.pop();\n            var node = new NestedDeclaration();\n            this.init(node);\n            var last = tokens[tokens.length - 1];\n\n            if (last[4]) {\n              node.source.end = {\n                line: last[4],\n                column: last[5]\n              };\n            } else {\n              node.source.end = {\n                line: last[2],\n                column: last[3]\n              };\n            }\n\n            while (tokens[0][0] !== 'word') {\n              node.raws.before += tokens.shift()[1];\n            }\n\n            node.source.start = {\n              line: tokens[0][2],\n              column: tokens[0][3]\n            };\n            node.prop = '';\n\n            while (tokens.length) {\n              var type = tokens[0][0];\n\n              if (type === ':' || type === 'space' || type === 'comment') {\n                break;\n              }\n\n              node.prop += tokens.shift()[1];\n            }\n\n            node.raws.between = '';\n            var token = void 0;\n\n            while (tokens.length) {\n              token = tokens.shift();\n\n              if (token[0] === ':') {\n                node.raws.between += token[1];\n                break;\n              } else {\n                node.raws.between += token[1];\n              }\n            }\n\n            if (node.prop[0] === '_' || node.prop[0] === '*') {\n              node.raws.before += node.prop[0];\n              node.prop = node.prop.slice(1);\n            }\n\n            node.raws.between += this.spacesAndCommentsFromStart(tokens);\n            this.precheckMissedSemicolon(tokens);\n\n            for (var _i2 = tokens.length - 1; _i2 > 0; _i2--) {\n              token = tokens[_i2];\n\n              if (token[1] === '!important') {\n                node.important = true;\n                var string = this.stringFrom(tokens, _i2);\n                string = this.spacesFromEnd(tokens) + string;\n\n                if (string !== ' !important') {\n                  node.raws.important = string;\n                }\n\n                break;\n              } else if (token[1] === 'important') {\n                var cache = tokens.slice(0);\n                var str = '';\n\n                for (var j = _i2; j > 0; j--) {\n                  var _type = cache[j][0];\n\n                  if (str.trim().indexOf('!') === 0 && _type !== 'space') {\n                    break;\n                  }\n\n                  str = cache.pop()[1] + str;\n                }\n\n                if (str.trim().indexOf('!') === 0) {\n                  node.important = true;\n                  node.raws.important = str;\n                  tokens = cache;\n                }\n              }\n\n              if (token[0] !== 'space' && token[0] !== 'comment') {\n                break;\n              }\n            }\n\n            this.raw(node, 'value', tokens);\n\n            if (node.value.indexOf(':') !== -1) {\n              this.checkMissedSemicolon(tokens);\n            }\n\n            this.current = node;\n          }\n        };\n\n        ScssParser.prototype.comment = function comment(token) {\n          if (token[6] === 'inline') {\n            var node = new Comment();\n            this.init(node, token[2], token[3]);\n            node.raws.inline = true;\n            node.source.end = {\n              line: token[4],\n              column: token[5]\n            };\n            var text = token[1].slice(2);\n\n            if (/^\\s*$/.test(text)) {\n              node.text = '';\n              node.raws.left = text;\n              node.raws.right = '';\n            } else {\n              var match = text.match(/^(\\s*)([^]*[^\\s])(\\s*)$/);\n              var fixed = match[2].replace(/(\\*\\/|\\/\\*)/g, '*//*');\n              node.text = fixed;\n              node.raws.left = match[1];\n              node.raws.right = match[3];\n              node.raws.text = match[2];\n            }\n          } else {\n            _Parser.prototype.comment.call(this, token);\n          }\n        };\n\n        ScssParser.prototype.raw = function raw(node, prop, tokens) {\n          _Parser.prototype.raw.call(this, node, prop, tokens);\n\n          if (node.raws[prop]) {\n            var scss = node.raws[prop].raw;\n            node.raws[prop].raw = tokens.reduce(function (all, i) {\n              if (i[0] === 'comment' && i[6] === 'inline') {\n                var text = i[1].slice(2).replace(/(\\*\\/|\\/\\*)/g, '*//*');\n                return all + '/*' + text + '*/';\n              } else {\n                return all + i[1];\n              }\n            }, '');\n\n            if (scss !== node.raws[prop].raw) {\n              node.raws[prop].scss = scss;\n            }\n          }\n        };\n\n        return ScssParser;\n      }(Parser);\n\n      module.exports = ScssParser;\n      /***/\n    },\n    /* 132 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = tokenizer;\n      var SINGLE_QUOTE = '\\''.charCodeAt(0);\n      var DOUBLE_QUOTE = '\"'.charCodeAt(0);\n      var BACKSLASH = '\\\\'.charCodeAt(0);\n      var SLASH = '/'.charCodeAt(0);\n      var NEWLINE = '\\n'.charCodeAt(0);\n      var SPACE = ' '.charCodeAt(0);\n      var FEED = '\\f'.charCodeAt(0);\n      var TAB = '\\t'.charCodeAt(0);\n      var CR = '\\r'.charCodeAt(0);\n      var OPEN_SQUARE = '['.charCodeAt(0);\n      var CLOSE_SQUARE = ']'.charCodeAt(0);\n      var OPEN_PARENTHESES = '('.charCodeAt(0);\n      var CLOSE_PARENTHESES = ')'.charCodeAt(0);\n      var OPEN_CURLY = '{'.charCodeAt(0);\n      var CLOSE_CURLY = '}'.charCodeAt(0);\n      var SEMICOLON = ';'.charCodeAt(0);\n      var ASTERISK = '*'.charCodeAt(0);\n      var COLON = ':'.charCodeAt(0);\n      var AT = '@'.charCodeAt(0);\n      var RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g;\n      var RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g;\n      var RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/;\n      var RE_HEX_ESCAPE = /[a-f0-9]/i;\n\n      function tokenizer(input, options) {\n        if (options === void 0) {\n          options = {};\n        }\n\n        var css = input.css.valueOf();\n        var ignore = options.ignoreErrors;\n        var code, next, quote, lines, last, content, escape;\n        var nextLine, nextOffset, escaped, escapePos, prev, n, currentToken;\n        var length = css.length;\n        var offset = -1;\n        var line = 1;\n        var pos = 0;\n        var buffer = [];\n        var returned = [];\n\n        function unclosed(what) {\n          throw input.error('Unclosed ' + what, line, pos - offset);\n        }\n\n        function endOfFile() {\n          return returned.length === 0 && pos >= length;\n        }\n\n        function nextToken(opts) {\n          if (returned.length) return returned.pop();\n          if (pos >= length) return;\n          var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n          code = css.charCodeAt(pos);\n\n          if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n            offset = pos;\n            line += 1;\n          }\n\n          switch (code) {\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n\n                if (code === NEWLINE) {\n                  offset = next;\n                  line += 1;\n                }\n              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n              currentToken = ['space', css.slice(pos, next)];\n              pos = next - 1;\n              break;\n\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n              var controlChar = String.fromCharCode(code);\n              currentToken = [controlChar, controlChar, line, pos - offset];\n              break;\n\n            case OPEN_PARENTHESES:\n              prev = buffer.length ? buffer.pop()[1] : '';\n              n = css.charCodeAt(pos + 1);\n\n              if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n                next = pos;\n\n                do {\n                  escaped = false;\n                  next = css.indexOf(')', next + 1);\n\n                  if (next === -1) {\n                    if (ignore || ignoreUnclosed) {\n                      next = pos;\n                      break;\n                    } else {\n                      unclosed('bracket');\n                    }\n                  }\n\n                  escapePos = next;\n\n                  while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n                    escapePos -= 1;\n                    escaped = !escaped;\n                  }\n                } while (escaped);\n\n                currentToken = ['brackets', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n                pos = next;\n              } else {\n                next = css.indexOf(')', pos + 1);\n                content = css.slice(pos, next + 1);\n\n                if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                  currentToken = ['(', '(', line, pos - offset];\n                } else {\n                  currentToken = ['brackets', content, line, pos - offset, line, next - offset];\n                  pos = next;\n                }\n              }\n\n              break;\n\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n              quote = code === SINGLE_QUOTE ? '\\'' : '\"';\n              next = pos;\n\n              do {\n                escaped = false;\n                next = css.indexOf(quote, next + 1);\n\n                if (next === -1) {\n                  if (ignore || ignoreUnclosed) {\n                    next = pos + 1;\n                    break;\n                  } else {\n                    unclosed('string');\n                  }\n                }\n\n                escapePos = next;\n\n                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n                  escapePos -= 1;\n                  escaped = !escaped;\n                }\n              } while (escaped);\n\n              content = css.slice(pos, next + 1);\n              lines = content.split('\\n');\n              last = lines.length - 1;\n\n              if (last > 0) {\n                nextLine = line + last;\n                nextOffset = next - lines[last].length;\n              } else {\n                nextLine = line;\n                nextOffset = offset;\n              }\n\n              currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];\n              offset = nextOffset;\n              line = nextLine;\n              pos = next;\n              break;\n\n            case AT:\n              RE_AT_END.lastIndex = pos + 1;\n              RE_AT_END.test(css);\n\n              if (RE_AT_END.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = RE_AT_END.lastIndex - 2;\n              }\n\n              currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n              pos = next;\n              break;\n\n            case BACKSLASH:\n              next = pos;\n              escape = true;\n\n              while (css.charCodeAt(next + 1) === BACKSLASH) {\n                next += 1;\n                escape = !escape;\n              }\n\n              code = css.charCodeAt(next + 1);\n\n              if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                next += 1;\n\n                if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n                    next += 1;\n                  }\n\n                  if (css.charCodeAt(next + 1) === SPACE) {\n                    next += 1;\n                  }\n                }\n              }\n\n              currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n              pos = next;\n              break;\n\n            default:\n              if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                next = css.indexOf('*/', pos + 2) + 1;\n\n                if (next === 0) {\n                  if (ignore || ignoreUnclosed) {\n                    next = css.length;\n                  } else {\n                    unclosed('comment');\n                  }\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];\n                offset = nextOffset;\n                line = nextLine;\n                pos = next;\n              } else {\n                RE_WORD_END.lastIndex = pos + 1;\n                RE_WORD_END.test(css);\n\n                if (RE_WORD_END.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = RE_WORD_END.lastIndex - 2;\n                }\n\n                currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n                buffer.push(currentToken);\n                pos = next;\n              }\n\n              break;\n          }\n\n          pos++;\n          return currentToken;\n        }\n\n        function back(token) {\n          returned.push(token);\n        }\n\n        return {\n          back: back,\n          nextToken: nextToken,\n          endOfFile: endOfFile\n        };\n      }\n\n      module.exports = exports.default;\n      /***/\n    },\n    /* 133 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n      /**\n       * Contains helpers for safely splitting lists of CSS values,\n       * preserving parentheses and quotes.\n       *\n       * @example\n       * const list = postcss.list\n       *\n       * @namespace list\n       */\n\n      var list = {\n        split: function split(string, separators, last) {\n          var array = [];\n          var current = '';\n          var split = false;\n          var func = 0;\n          var quote = false;\n          var escape = false;\n\n          for (var i = 0; i < string.length; i++) {\n            var letter = string[i];\n\n            if (quote) {\n              if (escape) {\n                escape = false;\n              } else if (letter === '\\\\') {\n                escape = true;\n              } else if (letter === quote) {\n                quote = false;\n              }\n            } else if (letter === '\"' || letter === '\\'') {\n              quote = letter;\n            } else if (letter === '(') {\n              func += 1;\n            } else if (letter === ')') {\n              if (func > 0) func -= 1;\n            } else if (func === 0) {\n              if (separators.indexOf(letter) !== -1) split = true;\n            }\n\n            if (split) {\n              if (current !== '') array.push(current.trim());\n              current = '';\n              split = false;\n            } else {\n              current += letter;\n            }\n          }\n\n          if (last || current !== '') array.push(current.trim());\n          return array;\n        },\n\n        /**\n         * Safely splits space-separated values (such as those for `background`,\n         * `border-radius`, and other shorthand properties).\n         *\n         * @param {string} string Space-separated values.\n         *\n         * @return {string[]} Split values.\n         *\n         * @example\n         * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']\n         */\n        space: function space(string) {\n          var spaces = [' ', '\\n', '\\t'];\n          return list.split(string, spaces);\n        },\n\n        /**\n         * Safely splits comma-separated values (such as those for `transition-*`\n         * and `background` properties).\n         *\n         * @param {string} string Comma-separated values.\n         *\n         * @return {string[]} Split values.\n         *\n         * @example\n         * postcss.list.comma('black, linear-gradient(white, black)')\n         * //=> ['black', 'linear-gradient(white, black)']\n         */\n        comma: function comma(string) {\n          return list.split(string, [','], true);\n        }\n      };\n      var _default = list;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 134 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _container = _interopRequireDefault(__webpack_require__(13));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n      }\n      /**\n       * Represents a CSS file and contains all its parsed nodes.\n       *\n       * @extends Container\n       *\n       * @example\n       * const root = postcss.parse('a{color:black} b{z-index:2}')\n       * root.type         //=> 'root'\n       * root.nodes.length //=> 2\n       */\n\n\n      var Root =\n      /*#__PURE__*/\n      function (_Container) {\n        _inheritsLoose(Root, _Container);\n\n        function Root(defaults) {\n          var _this;\n\n          _this = _Container.call(this, defaults) || this;\n          _this.type = 'root';\n          if (!_this.nodes) _this.nodes = [];\n          return _this;\n        }\n\n        var _proto = Root.prototype;\n\n        _proto.removeChild = function removeChild(child, ignore) {\n          var index = this.index(child);\n\n          if (!ignore && index === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index].raws.before;\n          }\n\n          return _Container.prototype.removeChild.call(this, child);\n        };\n\n        _proto.normalize = function normalize(child, sample, type) {\n          var nodes = _Container.prototype.normalize.call(this, child);\n\n          if (sample) {\n            if (type === 'prepend') {\n              if (this.nodes.length > 1) {\n                sample.raws.before = this.nodes[1].raws.before;\n              } else {\n                delete sample.raws.before;\n              }\n            } else if (this.first !== sample) {\n              for (var _iterator = nodes, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n                var _ref;\n\n                if (_isArray) {\n                  if (_i >= _iterator.length) break;\n                  _ref = _iterator[_i++];\n                } else {\n                  _i = _iterator.next();\n                  if (_i.done) break;\n                  _ref = _i.value;\n                }\n\n                var node = _ref;\n                node.raws.before = sample.raws.before;\n              }\n            }\n          }\n\n          return nodes;\n        };\n        /**\n         * Returns a {@link Result} instance representing the roots CSS.\n         *\n         * @param {processOptions} [opts] Options with only `to` and `map` keys.\n         *\n         * @return {Result} Result with current roots CSS.\n         *\n         * @example\n         * const root1 = postcss.parse(css1, { from: 'a.css' })\n         * const root2 = postcss.parse(css2, { from: 'b.css' })\n         * root1.append(root2)\n         * const result = root1.toResult({ to: 'all.css', map: true })\n         */\n\n\n        _proto.toResult = function toResult(opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          var LazyResult = __webpack_require__(71);\n\n          var Processor = __webpack_require__(139);\n\n          var lazy = new LazyResult(new Processor(), this, opts);\n          return lazy.stringify();\n        };\n        /**\n         * @memberof Root#\n         * @member {object} raws Information to generate byte-to-byte equal\n         *                       node string as it was in the origin input.\n         *\n         * Every parser saves its own properties,\n         * but the default CSS parser uses:\n         *\n         * * `after`: the space symbols after the last child to the end of file.\n         * * `semicolon`: is the last child has an (optional) semicolon.\n         *\n         * @example\n         * postcss.parse('a {}\\n').raws //=> { after: '\\n' }\n         * postcss.parse('a {}').raws   //=> { after: '' }\n         */\n\n\n        return Root;\n      }(_container.default);\n\n      var _default = Root;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 135 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (Buffer) {\n        exports.__esModule = true;\n        exports.default = void 0;\n\n        var _sourceMap = _interopRequireDefault(__webpack_require__(61));\n\n        var _path = _interopRequireDefault(__webpack_require__(6));\n\n        function _interopRequireDefault(obj) {\n          return obj && obj.__esModule ? obj : {\n            default: obj\n          };\n        }\n\n        var MapGenerator =\n        /*#__PURE__*/\n        function () {\n          function MapGenerator(stringify, root, opts) {\n            this.stringify = stringify;\n            this.mapOpts = opts.map || {};\n            this.root = root;\n            this.opts = opts;\n          }\n\n          var _proto = MapGenerator.prototype;\n\n          _proto.isMap = function isMap() {\n            if (typeof this.opts.map !== 'undefined') {\n              return !!this.opts.map;\n            }\n\n            return this.previous().length > 0;\n          };\n\n          _proto.previous = function previous() {\n            var _this = this;\n\n            if (!this.previousMaps) {\n              this.previousMaps = [];\n              this.root.walk(function (node) {\n                if (node.source && node.source.input.map) {\n                  var map = node.source.input.map;\n\n                  if (_this.previousMaps.indexOf(map) === -1) {\n                    _this.previousMaps.push(map);\n                  }\n                }\n              });\n            }\n\n            return this.previousMaps;\n          };\n\n          _proto.isInline = function isInline() {\n            if (typeof this.mapOpts.inline !== 'undefined') {\n              return this.mapOpts.inline;\n            }\n\n            var annotation = this.mapOpts.annotation;\n\n            if (typeof annotation !== 'undefined' && annotation !== true) {\n              return false;\n            }\n\n            if (this.previous().length) {\n              return this.previous().some(function (i) {\n                return i.inline;\n              });\n            }\n\n            return true;\n          };\n\n          _proto.isSourcesContent = function isSourcesContent() {\n            if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n              return this.mapOpts.sourcesContent;\n            }\n\n            if (this.previous().length) {\n              return this.previous().some(function (i) {\n                return i.withContent();\n              });\n            }\n\n            return true;\n          };\n\n          _proto.clearAnnotation = function clearAnnotation() {\n            if (this.mapOpts.annotation === false) return;\n            var node;\n\n            for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n              node = this.root.nodes[i];\n              if (node.type !== 'comment') continue;\n\n              if (node.text.indexOf('# sourceMappingURL=') === 0) {\n                this.root.removeChild(i);\n              }\n            }\n          };\n\n          _proto.setSourcesContent = function setSourcesContent() {\n            var _this2 = this;\n\n            var already = {};\n            this.root.walk(function (node) {\n              if (node.source) {\n                var from = node.source.input.from;\n\n                if (from && !already[from]) {\n                  already[from] = true;\n\n                  var relative = _this2.relative(from);\n\n                  _this2.map.setSourceContent(relative, node.source.input.css);\n                }\n              }\n            });\n          };\n\n          _proto.applyPrevMaps = function applyPrevMaps() {\n            for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n              var _ref;\n\n              if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n              } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n              }\n\n              var prev = _ref;\n              var from = this.relative(prev.file);\n\n              var root = prev.root || _path.default.dirname(prev.file);\n\n              var map = void 0;\n\n              if (this.mapOpts.sourcesContent === false) {\n                map = new _sourceMap.default.SourceMapConsumer(prev.text);\n\n                if (map.sourcesContent) {\n                  map.sourcesContent = map.sourcesContent.map(function () {\n                    return null;\n                  });\n                }\n              } else {\n                map = prev.consumer();\n              }\n\n              this.map.applySourceMap(map, from, this.relative(root));\n            }\n          };\n\n          _proto.isAnnotation = function isAnnotation() {\n            if (this.isInline()) {\n              return true;\n            }\n\n            if (typeof this.mapOpts.annotation !== 'undefined') {\n              return this.mapOpts.annotation;\n            }\n\n            if (this.previous().length) {\n              return this.previous().some(function (i) {\n                return i.annotation;\n              });\n            }\n\n            return true;\n          };\n\n          _proto.toBase64 = function toBase64(str) {\n            if (Buffer) {\n              return Buffer.from(str).toString('base64');\n            }\n\n            return window.btoa(unescape(encodeURIComponent(str)));\n          };\n\n          _proto.addAnnotation = function addAnnotation() {\n            var content;\n\n            if (this.isInline()) {\n              content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n            } else if (typeof this.mapOpts.annotation === 'string') {\n              content = this.mapOpts.annotation;\n            } else {\n              content = this.outputFile() + '.map';\n            }\n\n            var eol = '\\n';\n            if (this.css.indexOf('\\r\\n') !== -1) eol = '\\r\\n';\n            this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n          };\n\n          _proto.outputFile = function outputFile() {\n            if (this.opts.to) {\n              return this.relative(this.opts.to);\n            }\n\n            if (this.opts.from) {\n              return this.relative(this.opts.from);\n            }\n\n            return 'to.css';\n          };\n\n          _proto.generateMap = function generateMap() {\n            this.generateString();\n            if (this.isSourcesContent()) this.setSourcesContent();\n            if (this.previous().length > 0) this.applyPrevMaps();\n            if (this.isAnnotation()) this.addAnnotation();\n\n            if (this.isInline()) {\n              return [this.css];\n            }\n\n            return [this.css, this.map];\n          };\n\n          _proto.relative = function relative(file) {\n            if (file.indexOf('<') === 0) return file;\n            if (/^\\w+:\\/\\//.test(file)) return file;\n            var from = this.opts.to ? _path.default.dirname(this.opts.to) : '.';\n\n            if (typeof this.mapOpts.annotation === 'string') {\n              from = _path.default.dirname(_path.default.resolve(from, this.mapOpts.annotation));\n            }\n\n            file = _path.default.relative(from, file);\n\n            if (_path.default.sep === '\\\\') {\n              return file.replace(/\\\\/g, '/');\n            }\n\n            return file;\n          };\n\n          _proto.sourcePath = function sourcePath(node) {\n            if (this.mapOpts.from) {\n              return this.mapOpts.from;\n            }\n\n            return this.relative(node.source.input.from);\n          };\n\n          _proto.generateString = function generateString() {\n            var _this3 = this;\n\n            this.css = '';\n            this.map = new _sourceMap.default.SourceMapGenerator({\n              file: this.outputFile()\n            });\n            var line = 1;\n            var column = 1;\n            var lines, last;\n            this.stringify(this.root, function (str, node, type) {\n              _this3.css += str;\n\n              if (node && type !== 'end') {\n                if (node.source && node.source.start) {\n                  _this3.map.addMapping({\n                    source: _this3.sourcePath(node),\n                    generated: {\n                      line: line,\n                      column: column - 1\n                    },\n                    original: {\n                      line: node.source.start.line,\n                      column: node.source.start.column - 1\n                    }\n                  });\n                } else {\n                  _this3.map.addMapping({\n                    source: '<no source>',\n                    original: {\n                      line: 1,\n                      column: 0\n                    },\n                    generated: {\n                      line: line,\n                      column: column - 1\n                    }\n                  });\n                }\n              }\n\n              lines = str.match(/\\n/g);\n\n              if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf('\\n');\n                column = str.length - last;\n              } else {\n                column += str.length;\n              }\n\n              if (node && type !== 'start') {\n                if (node.source && node.source.end) {\n                  _this3.map.addMapping({\n                    source: _this3.sourcePath(node),\n                    generated: {\n                      line: line,\n                      column: column - 1\n                    },\n                    original: {\n                      line: node.source.end.line,\n                      column: node.source.end.column\n                    }\n                  });\n                } else {\n                  _this3.map.addMapping({\n                    source: '<no source>',\n                    original: {\n                      line: 1,\n                      column: 0\n                    },\n                    generated: {\n                      line: line,\n                      column: column - 1\n                    }\n                  });\n                }\n              }\n            });\n          };\n\n          _proto.generate = function generate() {\n            this.clearAnnotation();\n\n            if (this.isMap()) {\n              return this.generateMap();\n            }\n\n            var result = '';\n            this.stringify(this.root, function (i) {\n              result += i;\n            });\n            return [result];\n          };\n\n          return MapGenerator;\n        }();\n\n        var _default = MapGenerator;\n        exports.default = _default;\n        module.exports = exports.default;\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(18).Buffer);\n      /***/\n    },\n    /* 136 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = warnOnce;\n      var printed = {};\n\n      function warnOnce(message) {\n        if (printed[message]) return;\n        printed[message] = true;\n\n        if (typeof console !== 'undefined' && console.warn) {\n          console.warn(message);\n        }\n      }\n\n      module.exports = exports.default;\n      /***/\n    },\n    /* 137 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _warning = _interopRequireDefault(__webpack_require__(138));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _defineProperties(target, props) {\n        for (var i = 0; i < props.length; i++) {\n          var descriptor = props[i];\n          descriptor.enumerable = descriptor.enumerable || false;\n          descriptor.configurable = true;\n          if (\"value\" in descriptor) descriptor.writable = true;\n          Object.defineProperty(target, descriptor.key, descriptor);\n        }\n      }\n\n      function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        return Constructor;\n      }\n      /**\n       * Provides the result of the PostCSS transformations.\n       *\n       * A Result instance is returned by {@link LazyResult#then}\n       * or {@link Root#toResult} methods.\n       *\n       * @example\n       * postcss([autoprefixer]).process(css).then(result => {\n       *  console.log(result.css)\n       * })\n       *\n       * @example\n       * const result2 = postcss.parse(css).toResult()\n       */\n\n\n      var Result =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {Processor} processor Processor used for this transformation.\n         * @param {Root}      root      Root node after all transformations.\n         * @param {processOptions} opts Options from the {@link Processor#process}\n         *                              or {@link Root#toResult}.\n         */\n        function Result(processor, root, opts) {\n          /**\n           * The Processor instance used for this transformation.\n           *\n           * @type {Processor}\n           *\n           * @example\n           * for (const plugin of result.processor.plugins) {\n           *   if (plugin.postcssPlugin === 'postcss-bad') {\n           *     throw 'postcss-good is incompatible with postcss-bad'\n           *   }\n           * })\n           */\n          this.processor = processor;\n          /**\n           * Contains messages from plugins (e.g., warnings or custom messages).\n           * Each message should have type and plugin properties.\n           *\n           * @type {Message[]}\n           *\n           * @example\n           * postcss.plugin('postcss-min-browser', () => {\n           *   return (root, result) => {\n           *     const browsers = detectMinBrowsersByCanIUse(root)\n           *     result.messages.push({\n           *       type: 'min-browser',\n           *       plugin: 'postcss-min-browser',\n           *       browsers\n           *     })\n           *   }\n           * })\n           */\n\n          this.messages = [];\n          /**\n           * Root node after all transformations.\n           *\n           * @type {Root}\n           *\n           * @example\n           * root.toResult().root === root\n           */\n\n          this.root = root;\n          /**\n           * Options from the {@link Processor#process} or {@link Root#toResult} call\n           * that produced this Result instance.\n           *\n           * @type {processOptions}\n           *\n           * @example\n           * root.toResult(opts).opts === opts\n           */\n\n          this.opts = opts;\n          /**\n           * A CSS string representing of {@link Result#root}.\n           *\n           * @type {string}\n           *\n           * @example\n           * postcss.parse('a{}').toResult().css //=> \"a{}\"\n           */\n\n          this.css = undefined;\n          /**\n           * An instance of `SourceMapGenerator` class from the `source-map` library,\n           * representing changes to the {@link Result#root} instance.\n           *\n           * @type {SourceMapGenerator}\n           *\n           * @example\n           * result.map.toJSON() //=> { version: 3, file: 'a.css',  }\n           *\n           * @example\n           * if (result.map) {\n           *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())\n           * }\n           */\n\n          this.map = undefined;\n        }\n        /**\n         * Returns for @{link Result#css} content.\n         *\n         * @example\n         * result + '' === result.css\n         *\n         * @return {string} String representing of {@link Result#root}.\n         */\n\n\n        var _proto = Result.prototype;\n\n        _proto.toString = function toString() {\n          return this.css;\n        };\n        /**\n         * Creates an instance of {@link Warning} and adds it\n         * to {@link Result#messages}.\n         *\n         * @param {string} text        Warning message.\n         * @param {Object} [opts]      Warning options.\n         * @param {Node}   opts.node   CSS node that caused the warning.\n         * @param {string} opts.word   Word in CSS source that caused the warning.\n         * @param {number} opts.index  Index in CSS node string that caused\n         *                             the warning.\n         * @param {string} opts.plugin Name of the plugin that created\n         *                             this warning. {@link Result#warn} fills\n         *                             this property automatically.\n         *\n         * @return {Warning} Created warning.\n         */\n\n\n        _proto.warn = function warn(text, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n              opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n          }\n\n          var warning = new _warning.default(text, opts);\n          this.messages.push(warning);\n          return warning;\n        };\n        /**\n           * Returns warnings from plugins. Filters {@link Warning} instances\n           * from {@link Result#messages}.\n           *\n           * @example\n           * result.warnings().forEach(warn => {\n           *   console.warn(warn.toString())\n           * })\n           *\n           * @return {Warning[]} Warnings from plugins.\n           */\n\n\n        _proto.warnings = function warnings() {\n          return this.messages.filter(function (i) {\n            return i.type === 'warning';\n          });\n        };\n        /**\n         * An alias for the {@link Result#css} property.\n         * Use it with syntaxes that generate non-CSS output.\n         *\n         * @type {string}\n         *\n         * @example\n         * result.css === result.content\n         */\n\n\n        _createClass(Result, [{\n          key: \"content\",\n          get: function get() {\n            return this.css;\n          }\n        }]);\n\n        return Result;\n      }();\n\n      var _default = Result;\n      /**\n       * @typedef  {object} Message\n       * @property {string} type   Message type.\n       * @property {string} plugin Source PostCSS plugin name.\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 138 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      exports.default = void 0;\n      /**\n       * Represents a plugins warning. It can be created using {@link Node#warn}.\n       *\n       * @example\n       * if (decl.important) {\n       *   decl.warn(result, 'Avoid !important', { word: '!important' })\n       * }\n       */\n\n      var Warning =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {string} text        Warning message.\n         * @param {Object} [opts]      Warning options.\n         * @param {Node}   opts.node   CSS node that caused the warning.\n         * @param {string} opts.word   Word in CSS source that caused the warning.\n         * @param {number} opts.index  Index in CSS node string that caused\n         *                             the warning.\n         * @param {string} opts.plugin Name of the plugin that created\n         *                             this warning. {@link Result#warn} fills\n         *                             this property automatically.\n         */\n        function Warning(text, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n          /**\n           * Type to filter warnings from {@link Result#messages}.\n           * Always equal to `\"warning\"`.\n           *\n           * @type {string}\n           *\n           * @example\n           * const nonWarning = result.messages.filter(i => i.type !== 'warning')\n           */\n\n\n          this.type = 'warning';\n          /**\n           * The warning message.\n           *\n           * @type {string}\n           *\n           * @example\n           * warning.text //=> 'Try to avoid !important'\n           */\n\n          this.text = text;\n\n          if (opts.node && opts.node.source) {\n            var pos = opts.node.positionBy(opts);\n            /**\n             * Line in the input file with this warnings source.\n             * @type {number}\n             *\n             * @example\n             * warning.line //=> 5\n             */\n\n            this.line = pos.line;\n            /**\n             * Column in the input file with this warnings source.\n             *\n             * @type {number}\n             *\n             * @example\n             * warning.column //=> 6\n             */\n\n            this.column = pos.column;\n          }\n\n          for (var opt in opts) {\n            this[opt] = opts[opt];\n          }\n        }\n        /**\n         * Returns a warning position and message.\n         *\n         * @example\n         * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'\n         *\n         * @return {string} Warning position and message.\n         */\n\n\n        var _proto = Warning.prototype;\n\n        _proto.toString = function toString() {\n          if (this.node) {\n            return this.node.error(this.text, {\n              plugin: this.plugin,\n              index: this.index,\n              word: this.word\n            }).message;\n          }\n\n          if (this.plugin) {\n            return this.plugin + ': ' + this.text;\n          }\n\n          return this.text;\n        };\n        /**\n         * @memberof Warning#\n         * @member {string} plugin The name of the plugin that created\n         *                         it will fill this property automatically.\n         *                         this warning. When you call {@link Node#warn}\n         *\n         * @example\n         * warning.plugin //=> 'postcss-important'\n         */\n\n        /**\n         * @memberof Warning#\n         * @member {Node} node Contains the CSS node that caused the warning.\n         *\n         * @example\n         * warning.node.toString() //=> 'color: white !important'\n         */\n\n\n        return Warning;\n      }();\n\n      var _default = Warning;\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 139 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      exports.__esModule = true;\n      exports.default = void 0;\n\n      var _lazyResult = _interopRequireDefault(__webpack_require__(71));\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n      /**\n       * Contains plugins to process CSS. Create one `Processor` instance,\n       * initialize its plugins, and then use that instance on numerous CSS files.\n       *\n       * @example\n       * const processor = postcss([autoprefixer, precss])\n       * processor.process(css1).then(result => console.log(result.css))\n       * processor.process(css2).then(result => console.log(result.css))\n       */\n\n\n      var Processor =\n      /*#__PURE__*/\n      function () {\n        /**\n         * @param {Array.<Plugin|pluginFunction>|Processor} plugins PostCSS plugins.\n         *        See {@link Processor#use} for plugin format.\n         */\n        function Processor(plugins) {\n          if (plugins === void 0) {\n            plugins = [];\n          }\n          /**\n           * Current PostCSS version.\n           *\n           * @type {string}\n           *\n           * @example\n           * if (result.processor.version.split('.')[0] !== '6') {\n           *   throw new Error('This plugin works only with PostCSS 6')\n           * }\n           */\n\n\n          this.version = '7.0.5';\n          /**\n           * Plugins added to this processor.\n           *\n           * @type {pluginFunction[]}\n           *\n           * @example\n           * const processor = postcss([autoprefixer, precss])\n           * processor.plugins.length //=> 2\n           */\n\n          this.plugins = this.normalize(plugins);\n        }\n        /**\n         * Adds a plugin to be used as a CSS processor.\n         *\n         * PostCSS plugin can be in 4 formats:\n         * * A plugin created by {@link postcss.plugin} method.\n         * * A function. PostCSS will pass the function a @{link Root}\n         *   as the first argument and current {@link Result} instance\n         *   as the second.\n         * * An object with a `postcss` method. PostCSS will use that method\n         *   as described in #2.\n         * * Another {@link Processor} instance. PostCSS will copy plugins\n         *   from that instance into this one.\n         *\n         * Plugins can also be added by passing them as arguments when creating\n         * a `postcss` instance (see [`postcss(plugins)`]).\n         *\n         * Asynchronous plugins should return a `Promise` instance.\n         *\n         * @param {Plugin|pluginFunction|Processor} plugin PostCSS plugin\n         *                                                 or {@link Processor}\n         *                                                 with plugins.\n         *\n         * @example\n         * const processor = postcss()\n         *   .use(autoprefixer)\n         *   .use(precss)\n         *\n         * @return {Processes} Current processor to make methods chain.\n         */\n\n\n        var _proto = Processor.prototype;\n\n        _proto.use = function use(plugin) {\n          this.plugins = this.plugins.concat(this.normalize([plugin]));\n          return this;\n        };\n        /**\n         * Parses source CSS and returns a {@link LazyResult} Promise proxy.\n         * Because some plugins can be asynchronous it doesnt make\n         * any transformations. Transformations will be applied\n         * in the {@link LazyResult} methods.\n         *\n         * @param {string|toString|Result} css String with input CSS or any object\n         *                                     with a `toString()` method,\n         *                                     like a Buffer. Optionally, send\n         *                                     a {@link Result} instance\n         *                                     and the processor will take\n         *                                     the {@link Root} from it.\n         * @param {processOptions} [opts]      Options.\n         *\n         * @return {LazyResult} Promise proxy.\n         *\n         * @example\n         * processor.process(css, { from: 'a.css', to: 'a.out.css' })\n         *   .then(result => {\n         *      console.log(result.css)\n         *   })\n         */\n\n\n        _proto.process = function (_process) {\n          function process(_x) {\n            return _process.apply(this, arguments);\n          }\n\n          process.toString = function () {\n            return _process.toString();\n          };\n\n          return process;\n        }(function (css, opts) {\n          if (opts === void 0) {\n            opts = {};\n          }\n\n          if (this.plugins.length === 0 && opts.parser === opts.stringifier) {\n            if (false) {\n              if (typeof console !== 'undefined' && console.warn) {\n                console.warn('You did not set any plugins, parser, or stringifier. ' + 'Right now, PostCSS does nothing. Pick plugins for your case ' + 'on https://www.postcss.parts/ and use them in postcss.config.js.');\n              }\n            }\n          }\n\n          return new _lazyResult.default(this, css, opts);\n        });\n\n        _proto.normalize = function normalize(plugins) {\n          var normalized = [];\n\n          for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var i = _ref;\n            if (i.postcss) i = i.postcss;\n\n            if (_typeof(i) === 'object' && Array.isArray(i.plugins)) {\n              normalized = normalized.concat(i.plugins);\n            } else if (typeof i === 'function') {\n              normalized.push(i);\n            } else if (_typeof(i) === 'object' && (i.parse || i.stringify)) {\n              if (false) {\n                throw new Error('PostCSS syntaxes cannot be used as plugins. Instead, please use ' + 'one of the syntax/parser/stringifier options as outlined ' + 'in your PostCSS runner documentation.');\n              }\n            } else {\n              throw new Error(i + ' is not a PostCSS plugin');\n            }\n          }\n\n          return normalized;\n        };\n\n        return Processor;\n      }();\n\n      var _default = Processor;\n      /**\n       * @callback builder\n       * @param {string} part          Part of generated CSS connected to this node.\n       * @param {Node}   node          AST node.\n       * @param {\"start\"|\"end\"} [type] Nodes part type.\n       */\n\n      /**\n       * @callback parser\n       *\n       * @param {string|toString} css   String with input CSS or any object\n       *                                with toString() method, like a Buffer.\n       * @param {processOptions} [opts] Options with only `from` and `map` keys.\n       *\n       * @return {Root} PostCSS AST\n       */\n\n      /**\n       * @callback stringifier\n       *\n       * @param {Node} node       Start node for stringifing. Usually {@link Root}.\n       * @param {builder} builder Function to concatenate CSS from nodes parts\n       *                          or generate string and source map.\n       *\n       * @return {void}\n       */\n\n      /**\n       * @typedef {object} syntax\n       * @property {parser} parse          Function to generate AST by string.\n       * @property {stringifier} stringify Function to generate string by AST.\n       */\n\n      /**\n       * @typedef {object} toString\n       * @property {function} toString\n       */\n\n      /**\n       * @callback pluginFunction\n       * @param {Root} root     Parsed input CSS.\n       * @param {Result} result Result to set warnings or check other plugins.\n       */\n\n      /**\n       * @typedef {object} Plugin\n       * @property {function} postcss PostCSS plugin function.\n       */\n\n      /**\n       * @typedef {object} processOptions\n       * @property {string} from             The path of the CSS source file.\n       *                                     You should always set `from`,\n       *                                     because it is used in source map\n       *                                     generation and syntax error messages.\n       * @property {string} to               The path where youll put the output\n       *                                     CSS file. You should always set `to`\n       *                                     to generate correct source maps.\n       * @property {parser} parser           Function to generate AST by string.\n       * @property {stringifier} stringifier Class to generate string by AST.\n       * @property {syntax} syntax           Object with `parse` and `stringify`.\n       * @property {object} map              Source map options.\n       * @property {boolean} map.inline                    Does source map should\n       *                                                   be embedded in the output\n       *                                                   CSS as a base64-encoded\n       *                                                   comment.\n       * @property {string|object|false|function} map.prev Source map content\n       *                                                   from a previous\n       *                                                   processing step\n       *                                                   (for example, Sass).\n       *                                                   PostCSS will try to find\n       *                                                   previous map automatically,\n       *                                                   so you could disable it by\n       *                                                   `false` value.\n       * @property {boolean} map.sourcesContent            Does PostCSS should set\n       *                                                   the origin content to map.\n       * @property {string|false} map.annotation           Does PostCSS should set\n       *                                                   annotation comment to map.\n       * @property {string} map.from                       Override `from` in maps\n       *                                                   sources`.\n       */\n\n      exports.default = _default;\n      module.exports = exports.default;\n      /***/\n    },\n    /* 140 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Container = __webpack_require__(13);\n\n      var NestedDeclaration = function (_Container) {\n        _inherits(NestedDeclaration, _Container);\n\n        function NestedDeclaration(defaults) {\n          _classCallCheck(this, NestedDeclaration);\n\n          var _this = _possibleConstructorReturn(this, _Container.call(this, defaults));\n\n          _this.type = 'decl';\n          _this.isNested = true;\n          if (!_this.nodes) _this.nodes = [];\n          return _this;\n        }\n\n        return NestedDeclaration;\n      }(Container);\n\n      module.exports = NestedDeclaration;\n      /***/\n    },\n    /* 141 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var SINGLE_QUOTE = 39;\n      var DOUBLE_QUOTE = 34;\n      var BACKSLASH = 92;\n      var SLASH = 47;\n      var NEWLINE = 10;\n      var SPACE = 32;\n      var FEED = 12;\n      var TAB = 9;\n      var CR = 13;\n      var OPEN_SQUARE = 91;\n      var CLOSE_SQUARE = 93;\n      var OPEN_PARENTHESES = 40;\n      var CLOSE_PARENTHESES = 41;\n      var OPEN_CURLY = 123;\n      var CLOSE_CURLY = 125;\n      var SEMICOLON = 59;\n      var ASTERISK = 42;\n      var COLON = 58;\n      var AT = 64; // SCSS PATCH {\n\n      var COMMA = 44;\n      var HASH = 35; // } SCSS PATCH\n\n      var RE_AT_END = /[ \\n\\t\\r\\f{}()'\"\\\\;/[\\]#]/g;\n      var RE_WORD_END = /[ \\n\\t\\r\\f(){}:;@!'\"\\\\\\][#]|\\/(?=\\*)/g;\n      var RE_BAD_BRACKET = /.[\\\\/(\"'\\n]/;\n      var RE_HEX_ESCAPE = /[a-f0-9]/i;\n      var RE_NEW_LINE = /[\\r\\f\\n]/g; // SCSS PATCH\n      // SCSS PATCH function name was changed\n\n      module.exports = function scssTokenize(input) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var css = input.css.valueOf();\n        var ignore = options.ignoreErrors;\n        var code = void 0,\n            next = void 0,\n            quote = void 0,\n            lines = void 0,\n            last = void 0,\n            content = void 0,\n            escape = void 0,\n            nextLine = void 0,\n            nextOffset = void 0,\n            escaped = void 0,\n            prev = void 0,\n            n = void 0,\n            currentToken = void 0;\n        var brackets = void 0; // SCSS PATCH\n\n        var length = css.length;\n        var offset = -1;\n        var line = 1;\n        var pos = 0;\n        var buffer = [];\n        var returned = [];\n\n        function unclosed(what) {\n          throw input.error('Unclosed ' + what, line, pos - offset);\n        }\n\n        function endOfFile() {\n          return returned.length === 0 && pos >= length;\n        } // SCSS PATCH {\n\n\n        function interpolation() {\n          var deep = 1;\n          var stringQuote = false;\n          var stringEscaped = false;\n\n          while (deep > 0) {\n            next += 1;\n            if (css.length <= next) unclosed('interpolation');\n            code = css.charCodeAt(next);\n            n = css.charCodeAt(next + 1);\n\n            if (stringQuote) {\n              if (!stringEscaped && code === stringQuote) {\n                stringQuote = false;\n                stringEscaped = false;\n              } else if (code === BACKSLASH) {\n                stringEscaped = !escaped;\n              } else if (stringEscaped) {\n                stringEscaped = false;\n              }\n            } else if (code === SINGLE_QUOTE || code === DOUBLE_QUOTE) {\n              stringQuote = code;\n            } else if (code === CLOSE_CURLY) {\n              deep -= 1;\n            } else if (code === HASH && n === OPEN_CURLY) {\n              deep += 1;\n            }\n          }\n        } // } SCSS PATCH\n\n\n        function nextToken() {\n          if (returned.length) return returned.pop();\n          if (pos >= length) return;\n          code = css.charCodeAt(pos);\n\n          if (code === NEWLINE || code === FEED || code === CR && css.charCodeAt(pos + 1) !== NEWLINE) {\n            offset = pos;\n            line += 1;\n          }\n\n          switch (code) {\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n              next = pos;\n\n              do {\n                next += 1;\n                code = css.charCodeAt(next);\n\n                if (code === NEWLINE) {\n                  offset = next;\n                  line += 1;\n                }\n              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n              currentToken = ['space', css.slice(pos, next)];\n              pos = next - 1;\n              break;\n\n            case OPEN_SQUARE:\n              currentToken = ['[', '[', line, pos - offset];\n              break;\n\n            case CLOSE_SQUARE:\n              currentToken = [']', ']', line, pos - offset];\n              break;\n\n            case OPEN_CURLY:\n              currentToken = ['{', '{', line, pos - offset];\n              break;\n\n            case CLOSE_CURLY:\n              currentToken = ['}', '}', line, pos - offset];\n              break;\n            // SCSS PATCH {\n\n            case COMMA:\n              currentToken = ['word', ',', line, pos - offset, line, pos - offset + 1];\n              break;\n            // } SCSS PATCH\n\n            case COLON:\n              currentToken = [':', ':', line, pos - offset];\n              break;\n\n            case SEMICOLON:\n              currentToken = [';', ';', line, pos - offset];\n              break;\n\n            case OPEN_PARENTHESES:\n              prev = buffer.length ? buffer.pop()[1] : '';\n              n = css.charCodeAt(pos + 1); // SCSS PATCH {\n\n              if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE) {\n                brackets = 1;\n                escaped = false;\n                next = pos + 1;\n\n                while (next <= css.length - 1) {\n                  n = css.charCodeAt(next);\n\n                  if (n === BACKSLASH) {\n                    escaped = !escaped;\n                  } else if (n === OPEN_PARENTHESES) {\n                    brackets += 1;\n                  } else if (n === CLOSE_PARENTHESES) {\n                    brackets -= 1;\n                    if (brackets === 0) break;\n                  }\n\n                  next += 1;\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                currentToken = ['brackets', content, line, pos - offset, nextLine, next - nextOffset];\n                offset = nextOffset;\n                line = nextLine;\n                pos = next; // } SCSS PATCH\n              } else {\n                next = css.indexOf(')', pos + 1);\n                content = css.slice(pos, next + 1);\n\n                if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                  currentToken = ['(', '(', line, pos - offset];\n                } else {\n                  currentToken = ['brackets', content, line, pos - offset, line, next - offset];\n                  pos = next;\n                }\n              }\n\n              break;\n\n            case CLOSE_PARENTHESES:\n              currentToken = [')', ')', line, pos - offset];\n              break;\n\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n              // SCSS PATCH {\n              quote = code;\n              next = pos;\n              escaped = false;\n\n              while (next < length) {\n                next++;\n                if (next === length) unclosed('string');\n                code = css.charCodeAt(next);\n                n = css.charCodeAt(next + 1);\n\n                if (!escaped && code === quote) {\n                  break;\n                } else if (code === BACKSLASH) {\n                  escaped = !escaped;\n                } else if (escaped) {\n                  escaped = false;\n                } else if (code === HASH && n === OPEN_CURLY) {\n                  interpolation();\n                }\n              } // } SCSS PATCH\n\n\n              content = css.slice(pos, next + 1);\n              lines = content.split('\\n');\n              last = lines.length - 1;\n\n              if (last > 0) {\n                nextLine = line + last;\n                nextOffset = next - lines[last].length;\n              } else {\n                nextLine = line;\n                nextOffset = offset;\n              }\n\n              currentToken = ['string', css.slice(pos, next + 1), line, pos - offset, nextLine, next - nextOffset];\n              offset = nextOffset;\n              line = nextLine;\n              pos = next;\n              break;\n\n            case AT:\n              RE_AT_END.lastIndex = pos + 1;\n              RE_AT_END.test(css);\n\n              if (RE_AT_END.lastIndex === 0) {\n                next = css.length - 1;\n              } else {\n                next = RE_AT_END.lastIndex - 2;\n              }\n\n              currentToken = ['at-word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n              pos = next;\n              break;\n\n            case BACKSLASH:\n              next = pos;\n              escape = true;\n\n              while (css.charCodeAt(next + 1) === BACKSLASH) {\n                next += 1;\n                escape = !escape;\n              }\n\n              code = css.charCodeAt(next + 1);\n\n              if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                next += 1;\n\n                if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                  while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n                    next += 1;\n                  }\n\n                  if (css.charCodeAt(next + 1) === SPACE) {\n                    next += 1;\n                  }\n                }\n              }\n\n              currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n              pos = next;\n              break;\n\n            default:\n              // SCSS PATCH {\n              n = css.charCodeAt(pos + 1);\n\n              if (code === HASH && n === OPEN_CURLY) {\n                next = pos;\n                interpolation();\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                currentToken = ['word', content, line, pos - offset, nextLine, next - nextOffset];\n                offset = nextOffset;\n                line = nextLine;\n                pos = next;\n              } else if (code === SLASH && n === ASTERISK) {\n                // } SCSS PATCH\n                next = css.indexOf('*/', pos + 2) + 1;\n\n                if (next === 0) {\n                  if (ignore) {\n                    next = css.length;\n                  } else {\n                    unclosed('comment');\n                  }\n                }\n\n                content = css.slice(pos, next + 1);\n                lines = content.split('\\n');\n                last = lines.length - 1;\n\n                if (last > 0) {\n                  nextLine = line + last;\n                  nextOffset = next - lines[last].length;\n                } else {\n                  nextLine = line;\n                  nextOffset = offset;\n                }\n\n                currentToken = ['comment', content, line, pos - offset, nextLine, next - nextOffset];\n                offset = nextOffset;\n                line = nextLine;\n                pos = next; // SCSS PATCH {\n              } else if (code === SLASH && n === SLASH) {\n                RE_NEW_LINE.lastIndex = pos + 1;\n                RE_NEW_LINE.test(css);\n\n                if (RE_NEW_LINE.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = RE_NEW_LINE.lastIndex - 2;\n                }\n\n                content = css.slice(pos, next + 1);\n                currentToken = ['comment', content, line, pos - offset, line, next - offset, 'inline'];\n                pos = next; // } SCSS PATCH\n              } else {\n                RE_WORD_END.lastIndex = pos + 1;\n                RE_WORD_END.test(css);\n\n                if (RE_WORD_END.lastIndex === 0) {\n                  next = css.length - 1;\n                } else {\n                  next = RE_WORD_END.lastIndex - 2;\n                }\n\n                currentToken = ['word', css.slice(pos, next + 1), line, pos - offset, line, next - offset];\n                buffer.push(currentToken);\n                pos = next;\n              }\n\n              break;\n          }\n\n          pos++;\n          return currentToken;\n        }\n\n        function back(token) {\n          returned.push(token);\n        }\n\n        return {\n          back: back,\n          nextToken: nextToken,\n          endOfFile: endOfFile\n        };\n      };\n      /***/\n\n    },\n    /* 142 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      module.exports = false;\n      /***/\n    },\n    /* 143 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (module) {\n        function assembleStyles() {\n          var styles = {\n            modifiers: {\n              reset: [0, 0],\n              bold: [1, 22],\n              // 21 isn't widely supported and 22 does the same thing\n              dim: [2, 22],\n              italic: [3, 23],\n              underline: [4, 24],\n              inverse: [7, 27],\n              hidden: [8, 28],\n              strikethrough: [9, 29]\n            },\n            colors: {\n              black: [30, 39],\n              red: [31, 39],\n              green: [32, 39],\n              yellow: [33, 39],\n              blue: [34, 39],\n              magenta: [35, 39],\n              cyan: [36, 39],\n              white: [37, 39],\n              gray: [90, 39]\n            },\n            bgColors: {\n              bgBlack: [40, 49],\n              bgRed: [41, 49],\n              bgGreen: [42, 49],\n              bgYellow: [43, 49],\n              bgBlue: [44, 49],\n              bgMagenta: [45, 49],\n              bgCyan: [46, 49],\n              bgWhite: [47, 49]\n            }\n          }; // fix humans\n\n          styles.colors.grey = styles.colors.gray;\n          Object.keys(styles).forEach(function (groupName) {\n            var group = styles[groupName];\n            Object.keys(group).forEach(function (styleName) {\n              var style = group[styleName];\n              styles[styleName] = group[styleName] = {\n                open: \"\\x1B[\" + style[0] + 'm',\n                close: \"\\x1B[\" + style[1] + 'm'\n              };\n            });\n            Object.defineProperty(styles, groupName, {\n              value: group,\n              enumerable: false\n            });\n          });\n          return styles;\n        }\n\n        Object.defineProperty(module, 'exports', {\n          enumerable: true,\n          get: assembleStyles\n        });\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(144)(module));\n      /***/\n    },\n    /* 144 */\n\n    /***/\n    function (module, exports) {\n      module.exports = function (module) {\n        if (!module.webpackPolyfill) {\n          module.deprecate = function () {};\n\n          module.paths = []; // module.parent = undefined by default\n\n          if (!module.children) module.children = [];\n          Object.defineProperty(module, \"loaded\", {\n            enumerable: true,\n            get: function get() {\n              return module.l;\n            }\n          });\n          Object.defineProperty(module, \"id\", {\n            enumerable: true,\n            get: function get() {\n              return module.i;\n            }\n          });\n          module.webpackPolyfill = 1;\n        }\n\n        return module;\n      };\n      /***/\n\n    },\n    /* 145 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var ansiRegex = __webpack_require__(75)();\n\n      module.exports = function (str) {\n        return typeof str === 'string' ? str.replace(ansiRegex, '') : str;\n      };\n      /***/\n\n    },\n    /* 146 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      var ansiRegex = __webpack_require__(75);\n\n      var re = new RegExp(ansiRegex().source); // remove the `g` flag\n\n      module.exports = re.test.bind(re);\n      /***/\n    },\n    /* 147 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n      /* WEBPACK VAR INJECTION */\n\n      (function (process) {\n        var argv = process.argv;\n        var terminator = argv.indexOf('--');\n\n        var hasFlag = function hasFlag(flag) {\n          flag = '--' + flag;\n          var pos = argv.indexOf(flag);\n          return pos !== -1 && (terminator !== -1 ? pos < terminator : true);\n        };\n\n        module.exports = function () {\n          if ('FORCE_COLOR' in process.env) {\n            return true;\n          }\n\n          if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n            return false;\n          }\n\n          if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {\n            return true;\n          }\n\n          if (process.stdout && !process.stdout.isTTY) {\n            return false;\n          }\n\n          if (process.platform === 'win32') {\n            return true;\n          }\n\n          if ('COLORTERM' in process.env) {\n            return true;\n          }\n\n          if (process.env.TERM === 'dumb') {\n            return false;\n          }\n\n          if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n            return true;\n          }\n\n          return false;\n        }();\n        /* WEBPACK VAR INJECTION */\n\n      }).call(exports, __webpack_require__(12));\n      /***/\n    },\n    /* 148 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _chalk = __webpack_require__(74);\n\n      var _chalk2 = _interopRequireDefault(_chalk);\n\n      var _tokenize = __webpack_require__(76);\n\n      var _tokenize2 = _interopRequireDefault(_tokenize);\n\n      var _input = __webpack_require__(23);\n\n      var _input2 = _interopRequireDefault(_input);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      var colors = new _chalk2.default.constructor({\n        enabled: true\n      });\n      var HIGHLIGHT_THEME = {\n        'brackets': colors.cyan,\n        'at-word': colors.cyan,\n        'call': colors.cyan,\n        'comment': colors.gray,\n        'string': colors.green,\n        'class': colors.yellow,\n        'hash': colors.magenta,\n        '(': colors.cyan,\n        ')': colors.cyan,\n        '{': colors.yellow,\n        '}': colors.yellow,\n        '[': colors.yellow,\n        ']': colors.yellow,\n        ':': colors.yellow,\n        ';': colors.yellow\n      };\n\n      function getTokenType(_ref, index, tokens) {\n        var type = _ref[0],\n            value = _ref[1];\n\n        if (type === 'word') {\n          if (value[0] === '.') {\n            return 'class';\n          }\n\n          if (value[0] === '#') {\n            return 'hash';\n          }\n        }\n\n        var nextToken = tokens[index + 1];\n\n        if (nextToken && (nextToken[0] === 'brackets' || nextToken[0] === '(')) {\n          return 'call';\n        }\n\n        return type;\n      }\n\n      function terminalHighlight(css) {\n        var tokens = (0, _tokenize2.default)(new _input2.default(css), {\n          ignoreErrors: true\n        });\n        return tokens.map(function (token, index) {\n          var color = HIGHLIGHT_THEME[getTokenType(token, index, tokens)];\n\n          if (color) {\n            return token[1].split(/\\r?\\n/).map(function (i) {\n              return color(i);\n            }).join('\\n');\n          } else {\n            return token[1];\n          }\n        }).join('');\n      }\n\n      exports.default = terminalHighlight;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 149 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _jsBase = __webpack_require__(77);\n\n      var _sourceMap = __webpack_require__(78);\n\n      var _sourceMap2 = _interopRequireDefault(_sourceMap);\n\n      var _path = __webpack_require__(6);\n\n      var _path2 = _interopRequireDefault(_path);\n\n      var _fs = __webpack_require__(156);\n\n      var _fs2 = _interopRequireDefault(_fs);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Source map information from input CSS.\n       * For example, source map after Sass compiler.\n       *\n       * This class will automatically find source map in input CSS or in file system\n       * near input file (according `from` option).\n       *\n       * @example\n       * const root = postcss.parse(css, { from: 'a.sass.css' });\n       * root.input.map //=> PreviousMap\n       */\n\n\n      var PreviousMap = function () {\n        /**\n         * @param {string}         css    - input CSS source\n         * @param {processOptions} [opts] - {@link Processor#process} options\n         */\n        function PreviousMap(css, opts) {\n          _classCallCheck(this, PreviousMap);\n\n          this.loadAnnotation(css);\n          /**\n           * @member {boolean} - Was source map inlined by data-uri to input CSS.\n           */\n\n          this.inline = this.startWith(this.annotation, 'data:');\n          var prev = opts.map ? opts.map.prev : undefined;\n          var text = this.loadMap(opts.from, prev);\n          if (text) this.text = text;\n        }\n        /**\n         * Create a instance of `SourceMapGenerator` class\n         * from the `source-map` library to work with source map information.\n         *\n         * It is lazy method, so it will create object only on first call\n         * and then it will use cache.\n         *\n         * @return {SourceMapGenerator} object with source map information\n         */\n\n\n        PreviousMap.prototype.consumer = function consumer() {\n          if (!this.consumerCache) {\n            this.consumerCache = new _sourceMap2.default.SourceMapConsumer(this.text);\n          }\n\n          return this.consumerCache;\n        };\n        /**\n         * Does source map contains `sourcesContent` with input source text.\n         *\n         * @return {boolean} Is `sourcesContent` present\n         */\n\n\n        PreviousMap.prototype.withContent = function withContent() {\n          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n        };\n\n        PreviousMap.prototype.startWith = function startWith(string, start) {\n          if (!string) return false;\n          return string.substr(0, start.length) === start;\n        };\n\n        PreviousMap.prototype.loadAnnotation = function loadAnnotation(css) {\n          var match = css.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//);\n          if (match) this.annotation = match[1].trim();\n        };\n\n        PreviousMap.prototype.decodeInline = function decodeInline(text) {\n          var utfd64 = 'data:application/json;charset=utf-8;base64,';\n          var utf64 = 'data:application/json;charset=utf8;base64,';\n          var b64 = 'data:application/json;base64,';\n          var uri = 'data:application/json,';\n\n          if (this.startWith(text, uri)) {\n            return decodeURIComponent(text.substr(uri.length));\n          } else if (this.startWith(text, b64)) {\n            return _jsBase.Base64.decode(text.substr(b64.length));\n          } else if (this.startWith(text, utf64)) {\n            return _jsBase.Base64.decode(text.substr(utf64.length));\n          } else if (this.startWith(text, utfd64)) {\n            return _jsBase.Base64.decode(text.substr(utfd64.length));\n          } else {\n            var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n            throw new Error('Unsupported source map encoding ' + encoding);\n          }\n        };\n\n        PreviousMap.prototype.loadMap = function loadMap(file, prev) {\n          if (prev === false) return false;\n\n          if (prev) {\n            if (typeof prev === 'string') {\n              return prev;\n            } else if (typeof prev === 'function') {\n              var prevPath = prev(file);\n\n              if (prevPath && _fs2.default.existsSync && _fs2.default.existsSync(prevPath)) {\n                return _fs2.default.readFileSync(prevPath, 'utf-8').toString().trim();\n              } else {\n                throw new Error('Unable to load previous source map: ' + prevPath.toString());\n              }\n            } else if (prev instanceof _sourceMap2.default.SourceMapConsumer) {\n              return _sourceMap2.default.SourceMapGenerator.fromSourceMap(prev).toString();\n            } else if (prev instanceof _sourceMap2.default.SourceMapGenerator) {\n              return prev.toString();\n            } else if (this.isMap(prev)) {\n              return JSON.stringify(prev);\n            } else {\n              throw new Error('Unsupported previous source map format: ' + prev.toString());\n            }\n          } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n          } else if (this.annotation) {\n            var map = this.annotation;\n            if (file) map = _path2.default.join(_path2.default.dirname(file), map);\n            this.root = _path2.default.dirname(map);\n\n            if (_fs2.default.existsSync && _fs2.default.existsSync(map)) {\n              return _fs2.default.readFileSync(map, 'utf-8').toString().trim();\n            } else {\n              return false;\n            }\n          }\n        };\n\n        PreviousMap.prototype.isMap = function isMap(map) {\n          if ((typeof map === 'undefined' ? 'undefined' : _typeof(map)) !== 'object') return false;\n          return typeof map.mappings === 'string' || typeof map._mappings === 'string';\n        };\n\n        return PreviousMap;\n      }();\n\n      exports.default = PreviousMap;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 150 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n      /**\n       * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n       */\n\n      exports.encode = function (number) {\n        if (0 <= number && number < intToCharMap.length) {\n          return intToCharMap[number];\n        }\n\n        throw new TypeError(\"Must be between 0 and 63: \" + number);\n      };\n      /**\n       * Decode a single base 64 character code digit to an integer. Returns -1 on\n       * failure.\n       */\n\n\n      exports.decode = function (charCode) {\n        var bigA = 65; // 'A'\n\n        var bigZ = 90; // 'Z'\n\n        var littleA = 97; // 'a'\n\n        var littleZ = 122; // 'z'\n\n        var zero = 48; // '0'\n\n        var nine = 57; // '9'\n\n        var plus = 43; // '+'\n\n        var slash = 47; // '/'\n\n        var littleOffset = 26;\n        var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n        if (bigA <= charCode && charCode <= bigZ) {\n          return charCode - bigA;\n        } // 26 - 51: abcdefghijklmnopqrstuvwxyz\n\n\n        if (littleA <= charCode && charCode <= littleZ) {\n          return charCode - littleA + littleOffset;\n        } // 52 - 61: 0123456789\n\n\n        if (zero <= charCode && charCode <= nine) {\n          return charCode - zero + numberOffset;\n        } // 62: +\n\n\n        if (charCode == plus) {\n          return 62;\n        } // 63: /\n\n\n        if (charCode == slash) {\n          return 63;\n        } // Invalid base64 digit.\n\n\n        return -1;\n      };\n      /***/\n\n    },\n    /* 151 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2014 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(9);\n      /**\n       * Determine whether mappingB is after mappingA with respect to generated\n       * position.\n       */\n\n\n      function generatedPositionAfter(mappingA, mappingB) {\n        // Optimized for most common case\n        var lineA = mappingA.generatedLine;\n        var lineB = mappingB.generatedLine;\n        var columnA = mappingA.generatedColumn;\n        var columnB = mappingB.generatedColumn;\n        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n      }\n      /**\n       * A data structure to provide a sorted view of accumulated mappings in a\n       * performance conscious manner. It trades a neglibable overhead in general\n       * case for a large speedup in case of mappings being added in order.\n       */\n\n\n      function MappingList() {\n        this._array = [];\n        this._sorted = true; // Serves as infimum\n\n        this._last = {\n          generatedLine: -1,\n          generatedColumn: 0\n        };\n      }\n      /**\n       * Iterate through internal items. This method takes the same arguments that\n       * `Array.prototype.forEach` takes.\n       *\n       * NOTE: The order of the mappings is NOT guaranteed.\n       */\n\n\n      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {\n        this._array.forEach(aCallback, aThisArg);\n      };\n      /**\n       * Add the given source mapping.\n       *\n       * @param Object aMapping\n       */\n\n\n      MappingList.prototype.add = function MappingList_add(aMapping) {\n        if (generatedPositionAfter(this._last, aMapping)) {\n          this._last = aMapping;\n\n          this._array.push(aMapping);\n        } else {\n          this._sorted = false;\n\n          this._array.push(aMapping);\n        }\n      };\n      /**\n       * Returns the flat, sorted array of mappings. The mappings are sorted by\n       * generated position.\n       *\n       * WARNING: This method returns internal data without copying, for\n       * performance. The return value must NOT be mutated, and should be treated as\n       * an immutable borrow. If you want to take ownership, you must make your own\n       * copy.\n       */\n\n\n      MappingList.prototype.toArray = function MappingList_toArray() {\n        if (!this._sorted) {\n          this._array.sort(util.compareByGeneratedPositionsInflated);\n\n          this._sorted = true;\n        }\n\n        return this._array;\n      };\n\n      exports.MappingList = MappingList;\n      /***/\n    },\n    /* 152 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var util = __webpack_require__(9);\n\n      var binarySearch = __webpack_require__(153);\n\n      var ArraySet = __webpack_require__(81).ArraySet;\n\n      var base64VLQ = __webpack_require__(80);\n\n      var quickSort = __webpack_require__(154).quickSort;\n\n      function SourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);\n      }\n\n      SourceMapConsumer.fromSourceMap = function (aSourceMap) {\n        return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the\n      // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n      // are lazily instantiated, accessed via the `_generatedMappings` and\n      // `_originalMappings` getters respectively, and we only parse the mappings\n      // and create these arrays once queried for a source location. We jump through\n      // these hoops because there can be many thousands of mappings, and parsing\n      // them is expensive, so we only want to do it if we must.\n      //\n      // Each object in the arrays is of the form:\n      //\n      //     {\n      //       generatedLine: The line number in the generated code,\n      //       generatedColumn: The column number in the generated code,\n      //       source: The path to the original source file that generated this\n      //               chunk of code,\n      //       originalLine: The line number in the original source that\n      //                     corresponds to this chunk of generated code,\n      //       originalColumn: The column number in the original source that\n      //                       corresponds to this chunk of generated code,\n      //       name: The name of the original symbol which generated this chunk of\n      //             code.\n      //     }\n      //\n      // All properties except for `generatedLine` and `generatedColumn` can be\n      // `null`.\n      //\n      // `_generatedMappings` is ordered by the generated positions.\n      //\n      // `_originalMappings` is ordered by the original positions.\n\n      SourceMapConsumer.prototype.__generatedMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n        get: function get() {\n          if (!this.__generatedMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__generatedMappings;\n        }\n      });\n      SourceMapConsumer.prototype.__originalMappings = null;\n      Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n        get: function get() {\n          if (!this.__originalMappings) {\n            this._parseMappings(this._mappings, this.sourceRoot);\n          }\n\n          return this.__originalMappings;\n        }\n      });\n\n      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n        var c = aStr.charAt(index);\n        return c === \";\" || c === \",\";\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        throw new Error(\"Subclasses must implement _parseMappings\");\n      };\n\n      SourceMapConsumer.GENERATED_ORDER = 1;\n      SourceMapConsumer.ORIGINAL_ORDER = 2;\n      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;\n      SourceMapConsumer.LEAST_UPPER_BOUND = 2;\n      /**\n       * Iterate over each mapping between an original source/line/column and a\n       * generated line/column in this source map.\n       *\n       * @param Function aCallback\n       *        The function that is called with each mapping.\n       * @param Object aContext\n       *        Optional. If specified, this object will be the value of `this` every\n       *        time that `aCallback` is called.\n       * @param aOrder\n       *        Either `SourceMapConsumer.GENERATED_ORDER` or\n       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n       *        iterate over the mappings sorted by the generated file's line/column\n       *        order or the original's source/line/column order, respectively. Defaults to\n       *        `SourceMapConsumer.GENERATED_ORDER`.\n       */\n\n      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n        var context = aContext || null;\n        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n        var mappings;\n\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            mappings = this._generatedMappings;\n            break;\n\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            mappings = this._originalMappings;\n            break;\n\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n\n        var sourceRoot = this.sourceRoot;\n        mappings.map(function (mapping) {\n          var source = mapping.source === null ? null : this._sources.at(mapping.source);\n\n          if (source != null && sourceRoot != null) {\n            source = util.join(sourceRoot, source);\n          }\n\n          return {\n            source: source,\n            generatedLine: mapping.generatedLine,\n            generatedColumn: mapping.generatedColumn,\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: mapping.name === null ? null : this._names.at(mapping.name)\n          };\n        }, this).forEach(aCallback, context);\n      };\n      /**\n       * Returns all generated line and column information for the original source,\n       * line, and column provided. If no column is provided, returns all mappings\n       * corresponding to a either the line we are searching for or the next\n       * closest line that has any mappings. Otherwise, returns all mappings\n       * corresponding to the given line and either the column we are searching for\n       * or the next closest column that has any offsets.\n       *\n       * The only argument is an object with the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: Optional. the column number in the original source.\n       *\n       * and an array of objects is returned, each with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n        var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n        // returns the index of the closest mapping less than the needle. By\n        // setting needle.originalColumn to 0, we thus find the last mapping for\n        // the given line, provided such a mapping exists.\n\n        var needle = {\n          source: util.getArg(aArgs, 'source'),\n          originalLine: line,\n          originalColumn: util.getArg(aArgs, 'column', 0)\n        };\n\n        if (this.sourceRoot != null) {\n          needle.source = util.relative(this.sourceRoot, needle.source);\n        }\n\n        if (!this._sources.has(needle.source)) {\n          return [];\n        }\n\n        needle.source = this._sources.indexOf(needle.source);\n        var mappings = [];\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (aArgs.column === undefined) {\n            var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we found. Since\n            // mappings are sorted, this is guaranteed to find all mappings for\n            // the line we found.\n\n            while (mapping && mapping.originalLine === originalLine) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          } else {\n            var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into\n            // a mapping for a different line than the one we were searching for.\n            // Since mappings are sorted, this is guaranteed to find all mappings for\n            // the line we are searching for.\n\n            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n              mappings.push({\n                line: util.getArg(mapping, 'generatedLine', null),\n                column: util.getArg(mapping, 'generatedColumn', null),\n                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n              });\n              mapping = this._originalMappings[++index];\n            }\n          }\n        }\n\n        return mappings;\n      };\n\n      exports.SourceMapConsumer = SourceMapConsumer;\n      /**\n       * A BasicSourceMapConsumer instance represents a parsed source map which we can\n       * query for information about the original file positions by giving it a file\n       * position in the generated source.\n       *\n       * The only parameter is the raw source map (either as a JSON string, or\n       * already parsed to an object). According to the spec, source maps have the\n       * following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - sources: An array of URLs to the original source files.\n       *   - names: An array of identifiers which can be referrenced by individual mappings.\n       *   - sourceRoot: Optional. The URL root from which all sources are relative.\n       *   - sourcesContent: Optional. An array of contents of the original source files.\n       *   - mappings: A string of base64 VLQs which contain the actual mappings.\n       *   - file: Optional. The generated file this source map is associated with.\n       *\n       * Here is an example source map, taken from the source map spec[0]:\n       *\n       *     {\n       *       version : 3,\n       *       file: \"out.js\",\n       *       sourceRoot : \"\",\n       *       sources: [\"foo.js\", \"bar.js\"],\n       *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *       mappings: \"AA,AB;;ABCDE;\"\n       *     }\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n       */\n\n      function BasicSourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n        // requires the array) to play nice here.\n\n        var names = util.getArg(sourceMap, 'names', []);\n        var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n        var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n        var mappings = util.getArg(sourceMap, 'mappings');\n        var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a\n        // string rather than a number, so we use loose equality checking here.\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        sources = sources.map(String) // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize) // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function (source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n        }); // Pass `true` below to allow duplicate names and sources. While source maps\n        // are intended to be compressed and deduplicated, the TypeScript compiler\n        // sometimes generates source maps with duplicates in them. See Github issue\n        // #72 and bugzil.la/889492.\n\n        this._names = ArraySet.fromArray(names.map(String), true);\n        this._sources = ArraySet.fromArray(sources, true);\n        this.sourceRoot = sourceRoot;\n        this.sourcesContent = sourcesContent;\n        this._mappings = mappings;\n        this.file = file;\n      }\n\n      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n      /**\n       * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n       *\n       * @param SourceMapGenerator aSourceMap\n       *        The source map that will be consumed.\n       * @returns BasicSourceMapConsumer\n       */\n\n      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n        var smc = Object.create(BasicSourceMapConsumer.prototype);\n        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n        smc.sourceRoot = aSourceMap._sourceRoot;\n        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n        smc.file = aSourceMap._file; // Because we are modifying the entries (by converting string sources and\n        // names to indices into the sources and names ArraySets), we have to make\n        // a copy of the entry or else bad things happen. Shared mutable state\n        // strikes again! See github issue #191.\n\n        var generatedMappings = aSourceMap._mappings.toArray().slice();\n\n        var destGeneratedMappings = smc.__generatedMappings = [];\n        var destOriginalMappings = smc.__originalMappings = [];\n\n        for (var i = 0, length = generatedMappings.length; i < length; i++) {\n          var srcMapping = generatedMappings[i];\n          var destMapping = new Mapping();\n          destMapping.generatedLine = srcMapping.generatedLine;\n          destMapping.generatedColumn = srcMapping.generatedColumn;\n\n          if (srcMapping.source) {\n            destMapping.source = sources.indexOf(srcMapping.source);\n            destMapping.originalLine = srcMapping.originalLine;\n            destMapping.originalColumn = srcMapping.originalColumn;\n\n            if (srcMapping.name) {\n              destMapping.name = names.indexOf(srcMapping.name);\n            }\n\n            destOriginalMappings.push(destMapping);\n          }\n\n          destGeneratedMappings.push(destMapping);\n        }\n\n        quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n        return smc;\n      };\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n\n      BasicSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          return this._sources.toArray().map(function (s) {\n            return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n          }, this);\n        }\n      });\n      /**\n       * Provide the JIT with a nice shape / hidden class.\n       */\n\n      function Mapping() {\n        this.generatedLine = 0;\n        this.generatedColumn = 0;\n        this.source = null;\n        this.originalLine = null;\n        this.originalColumn = null;\n        this.name = null;\n      }\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        var generatedLine = 1;\n        var previousGeneratedColumn = 0;\n        var previousOriginalLine = 0;\n        var previousOriginalColumn = 0;\n        var previousSource = 0;\n        var previousName = 0;\n        var length = aStr.length;\n        var index = 0;\n        var cachedSegments = {};\n        var temp = {};\n        var originalMappings = [];\n        var generatedMappings = [];\n        var mapping, str, segment, end, value;\n\n        while (index < length) {\n          if (aStr.charAt(index) === ';') {\n            generatedLine++;\n            index++;\n            previousGeneratedColumn = 0;\n          } else if (aStr.charAt(index) === ',') {\n            index++;\n          } else {\n            mapping = new Mapping();\n            mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,\n            // many segments often have the same encoding. We can exploit this\n            // fact by caching the parsed variable length fields of each segment,\n            // allowing us to avoid a second parse if we encounter the same\n            // segment again.\n\n            for (end = index; end < length; end++) {\n              if (this._charIsMappingSeparator(aStr, end)) {\n                break;\n              }\n            }\n\n            str = aStr.slice(index, end);\n            segment = cachedSegments[str];\n\n            if (segment) {\n              index += str.length;\n            } else {\n              segment = [];\n\n              while (index < end) {\n                base64VLQ.decode(aStr, index, temp);\n                value = temp.value;\n                index = temp.rest;\n                segment.push(value);\n              }\n\n              if (segment.length === 2) {\n                throw new Error('Found a source, but no line and column');\n              }\n\n              if (segment.length === 3) {\n                throw new Error('Found a source and line, but no column');\n              }\n\n              cachedSegments[str] = segment;\n            } // Generated column.\n\n\n            mapping.generatedColumn = previousGeneratedColumn + segment[0];\n            previousGeneratedColumn = mapping.generatedColumn;\n\n            if (segment.length > 1) {\n              // Original source.\n              mapping.source = previousSource + segment[1];\n              previousSource += segment[1]; // Original line.\n\n              mapping.originalLine = previousOriginalLine + segment[2];\n              previousOriginalLine = mapping.originalLine; // Lines are stored 0-based\n\n              mapping.originalLine += 1; // Original column.\n\n              mapping.originalColumn = previousOriginalColumn + segment[3];\n              previousOriginalColumn = mapping.originalColumn;\n\n              if (segment.length > 4) {\n                // Original name.\n                mapping.name = previousName + segment[4];\n                previousName += segment[4];\n              }\n            }\n\n            generatedMappings.push(mapping);\n\n            if (typeof mapping.originalLine === 'number') {\n              originalMappings.push(mapping);\n            }\n          }\n        }\n\n        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n        this.__generatedMappings = generatedMappings;\n        quickSort(originalMappings, util.compareByOriginalPositions);\n        this.__originalMappings = originalMappings;\n      };\n      /**\n       * Find the mapping that best matches the hypothetical \"needle\" mapping that\n       * we are searching for in the given \"haystack\" of mappings.\n       */\n\n\n      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n        // To return the position we are searching for, we must first find the\n        // mapping for the given position and then return the opposite position it\n        // points to. Because the mappings are sorted, we can use binary search to\n        // find the best mapping.\n        if (aNeedle[aLineName] <= 0) {\n          throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n        }\n\n        if (aNeedle[aColumnName] < 0) {\n          throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n        }\n\n        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n      };\n      /**\n       * Compute the last column for each generated mapping. The last column is\n       * inclusive.\n       */\n\n\n      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n        for (var index = 0; index < this._generatedMappings.length; ++index) {\n          var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We\n          // can come up with an optimistic estimate, however, by assuming that\n          // mappings are contiguous (i.e. given two consecutive mappings, the\n          // first mapping ends where the second one starts).\n\n          if (index + 1 < this._generatedMappings.length) {\n            var nextMapping = this._generatedMappings[index + 1];\n\n            if (mapping.generatedLine === nextMapping.generatedLine) {\n              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n              continue;\n            }\n          } // The last mapping for each line spans the entire line.\n\n\n          mapping.lastGeneratedColumn = Infinity;\n        }\n      };\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.\n       *   - column: The column number in the generated source.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.\n       *   - column: The column number in the original source, or null.\n       *   - name: The original identifier, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._generatedMappings[index];\n\n          if (mapping.generatedLine === needle.generatedLine) {\n            var source = util.getArg(mapping, 'source', null);\n\n            if (source !== null) {\n              source = this._sources.at(source);\n\n              if (this.sourceRoot != null) {\n                source = util.join(this.sourceRoot, source);\n              }\n            }\n\n            var name = util.getArg(mapping, 'name', null);\n\n            if (name !== null) {\n              name = this._names.at(name);\n            }\n\n            return {\n              source: source,\n              line: util.getArg(mapping, 'originalLine', null),\n              column: util.getArg(mapping, 'originalColumn', null),\n              name: name\n            };\n          }\n        }\n\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {\n        if (!this.sourcesContent) {\n          return false;\n        }\n\n        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n          return sc == null;\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        if (!this.sourcesContent) {\n          return null;\n        }\n\n        if (this.sourceRoot != null) {\n          aSource = util.relative(this.sourceRoot, aSource);\n        }\n\n        if (this._sources.has(aSource)) {\n          return this.sourcesContent[this._sources.indexOf(aSource)];\n        }\n\n        var url;\n\n        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n          // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n          // many users. We can help them out when they expect file:// URIs to\n          // behave like it would if they were running a local HTTP server. See\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n          var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\n          if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n          }\n\n          if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n            return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n          }\n        } // This function is used recursively from\n        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n        // don't want to throw if we can't find the source - we just want to\n        // return null, so we provide a flag to exit gracefully.\n\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: The column number in the original source.\n       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n        var source = util.getArg(aArgs, 'source');\n\n        if (this.sourceRoot != null) {\n          source = util.relative(this.sourceRoot, source);\n        }\n\n        if (!this._sources.has(source)) {\n          return {\n            line: null,\n            column: null,\n            lastColumn: null\n          };\n        }\n\n        source = this._sources.indexOf(source);\n        var needle = {\n          source: source,\n          originalLine: util.getArg(aArgs, 'line'),\n          originalColumn: util.getArg(aArgs, 'column')\n        };\n\n        var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));\n\n        if (index >= 0) {\n          var mapping = this._originalMappings[index];\n\n          if (mapping.source === needle.source) {\n            return {\n              line: util.getArg(mapping, 'generatedLine', null),\n              column: util.getArg(mapping, 'generatedColumn', null),\n              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n            };\n          }\n        }\n\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      };\n\n      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n      /**\n       * An IndexedSourceMapConsumer instance represents a parsed source map which\n       * we can query for information. It differs from BasicSourceMapConsumer in\n       * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n       * input.\n       *\n       * The only parameter is a raw source map (either as a JSON string, or already\n       * parsed to an object). According to the spec for indexed source maps, they\n       * have the following attributes:\n       *\n       *   - version: Which version of the source map spec this map is following.\n       *   - file: Optional. The generated file this source map is associated with.\n       *   - sections: A list of section definitions.\n       *\n       * Each value under the \"sections\" field has two fields:\n       *   - offset: The offset into the original specified at which this section\n       *       begins to apply, defined as an object with a \"line\" and \"column\"\n       *       field.\n       *   - map: A source map definition. This source map could also be indexed,\n       *       but doesn't have to be.\n       *\n       * Instead of the \"map\" field, it's also possible to have a \"url\" field\n       * specifying a URL to retrieve a source map from, but that's currently\n       * unsupported.\n       *\n       * Here's an example source map, taken from the source map spec[0], but\n       * modified to omit a section which uses the \"url\" field.\n       *\n       *  {\n       *    version : 3,\n       *    file: \"app.js\",\n       *    sections: [{\n       *      offset: {line:100, column:10},\n       *      map: {\n       *        version : 3,\n       *        file: \"section.js\",\n       *        sources: [\"foo.js\", \"bar.js\"],\n       *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n       *        mappings: \"AAAA,E;;ABCDE;\"\n       *      }\n       *    }],\n       *  }\n       *\n       * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n       */\n\n      function IndexedSourceMapConsumer(aSourceMap) {\n        var sourceMap = aSourceMap;\n\n        if (typeof aSourceMap === 'string') {\n          sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n        }\n\n        var version = util.getArg(sourceMap, 'version');\n        var sections = util.getArg(sourceMap, 'sections');\n\n        if (version != this._version) {\n          throw new Error('Unsupported version: ' + version);\n        }\n\n        this._sources = new ArraySet();\n        this._names = new ArraySet();\n        var lastOffset = {\n          line: -1,\n          column: 0\n        };\n        this._sections = sections.map(function (s) {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error('Support for url field in sections not implemented.');\n          }\n\n          var offset = util.getArg(s, 'offset');\n          var offsetLine = util.getArg(offset, 'line');\n          var offsetColumn = util.getArg(offset, 'column');\n\n          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n            throw new Error('Section offsets must be ordered and non-overlapping.');\n          }\n\n          lastOffset = offset;\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n          };\n        });\n      }\n\n      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\n      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n      /**\n       * The version of the source mapping spec that we are consuming.\n       */\n\n      IndexedSourceMapConsumer.prototype._version = 3;\n      /**\n       * The list of original sources.\n       */\n\n      Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n        get: function get() {\n          var sources = [];\n\n          for (var i = 0; i < this._sections.length; i++) {\n            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n              sources.push(this._sections[i].consumer.sources[j]);\n            }\n          }\n\n          return sources;\n        }\n      });\n      /**\n       * Returns the original source, line, and column information for the generated\n       * source's line and column positions provided. The only argument is an object\n       * with the following properties:\n       *\n       *   - line: The line number in the generated source.\n       *   - column: The column number in the generated source.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - source: The original source file, or null.\n       *   - line: The line number in the original source, or null.\n       *   - column: The column number in the original source, or null.\n       *   - name: The original identifier, or null.\n       */\n\n      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n        var needle = {\n          generatedLine: util.getArg(aArgs, 'line'),\n          generatedColumn: util.getArg(aArgs, 'column')\n        }; // Find the section containing the generated position we're trying to map\n        // to an original position.\n\n        var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {\n          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n\n          if (cmp) {\n            return cmp;\n          }\n\n          return needle.generatedColumn - section.generatedOffset.generatedColumn;\n        });\n        var section = this._sections[sectionIndex];\n\n        if (!section) {\n          return {\n            source: null,\n            line: null,\n            column: null,\n            name: null\n          };\n        }\n\n        return section.consumer.originalPositionFor({\n          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n          bias: aArgs.bias\n        });\n      };\n      /**\n       * Return true if we have the source content for every source in the source\n       * map, false otherwise.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n        return this._sections.every(function (s) {\n          return s.consumer.hasContentsOfAllSources();\n        });\n      };\n      /**\n       * Returns the original source content. The only argument is the url of the\n       * original source file. Returns null if no original source content is\n       * available.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var content = section.consumer.sourceContentFor(aSource, true);\n\n          if (content) {\n            return content;\n          }\n        }\n\n        if (nullOnMissing) {\n          return null;\n        } else {\n          throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n        }\n      };\n      /**\n       * Returns the generated line and column information for the original source,\n       * line, and column positions provided. The only argument is an object with\n       * the following properties:\n       *\n       *   - source: The filename of the original source.\n       *   - line: The line number in the original source.\n       *   - column: The column number in the original source.\n       *\n       * and an object is returned with the following properties:\n       *\n       *   - line: The line number in the generated source, or null.\n       *   - column: The column number in the generated source, or null.\n       */\n\n\n      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i]; // Only consider this section if the requested source is in the list of\n          // sources of the consumer.\n\n          if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n            continue;\n          }\n\n          var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n\n          if (generatedPosition) {\n            var ret = {\n              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n            };\n            return ret;\n          }\n        }\n\n        return {\n          line: null,\n          column: null\n        };\n      };\n      /**\n       * Parse the mappings in a string in to a data structure which we can easily\n       * query (the ordered arrays in the `this.__generatedMappings` and\n       * `this.__originalMappings` properties).\n       */\n\n\n      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        for (var i = 0; i < this._sections.length; i++) {\n          var section = this._sections[i];\n          var sectionMappings = section.consumer._generatedMappings;\n\n          for (var j = 0; j < sectionMappings.length; j++) {\n            var mapping = sectionMappings[j];\n\n            var source = section.consumer._sources.at(mapping.source);\n\n            if (section.consumer.sourceRoot !== null) {\n              source = util.join(section.consumer.sourceRoot, source);\n            }\n\n            this._sources.add(source);\n\n            source = this._sources.indexOf(source);\n\n            var name = section.consumer._names.at(mapping.name);\n\n            this._names.add(name);\n\n            name = this._names.indexOf(name); // The mappings coming from the consumer for the section have\n            // generated positions relative to the start of the section, so we\n            // need to offset them to be relative to the start of the concatenated\n            // generated file.\n\n            var adjustedMapping = {\n              source: source,\n              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n              originalLine: mapping.originalLine,\n              originalColumn: mapping.originalColumn,\n              name: name\n            };\n\n            this.__generatedMappings.push(adjustedMapping);\n\n            if (typeof adjustedMapping.originalLine === 'number') {\n              this.__originalMappings.push(adjustedMapping);\n            }\n          }\n        }\n\n        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n        quickSort(this.__originalMappings, util.compareByOriginalPositions);\n      };\n\n      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n      /***/\n    },\n    /* 153 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      exports.GREATEST_LOWER_BOUND = 1;\n      exports.LEAST_UPPER_BOUND = 2;\n      /**\n       * Recursive implementation of binary search.\n       *\n       * @param aLow Indices here and lower do not contain the needle.\n       * @param aHigh Indices here and higher do not contain the needle.\n       * @param aNeedle The element being searched for.\n       * @param aHaystack The non-empty array being searched.\n       * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       */\n\n      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n        // This function terminates when one of the following is true:\n        //\n        //   1. We find the exact element we are looking for.\n        //\n        //   2. We did not find the exact element, but we can return the index of\n        //      the next-closest element.\n        //\n        //   3. We did not find the exact element, and there is no next-closest\n        //      element than the one we are searching for, so we return -1.\n        var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n        var cmp = aCompare(aNeedle, aHaystack[mid], true);\n\n        if (cmp === 0) {\n          // Found the element we are looking for.\n          return mid;\n        } else if (cmp > 0) {\n          // Our needle is greater than aHaystack[mid].\n          if (aHigh - mid > 1) {\n            // The element is in the upper half.\n            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n          } // The exact needle element was not found in this haystack. Determine if\n          // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return aHigh < aHaystack.length ? aHigh : -1;\n          } else {\n            return mid;\n          }\n        } else {\n          // Our needle is less than aHaystack[mid].\n          if (mid - aLow > 1) {\n            // The element is in the lower half.\n            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n          } // we are in termination case (3) or (2) and return the appropriate thing.\n\n\n          if (aBias == exports.LEAST_UPPER_BOUND) {\n            return mid;\n          } else {\n            return aLow < 0 ? -1 : aLow;\n          }\n        }\n      }\n      /**\n       * This is an implementation of binary search which will always try and return\n       * the index of the closest element if there is no exact hit. This is because\n       * mappings between original and generated line/col pairs are single points,\n       * and there is an implicit region between each of them, so a miss just means\n       * that you aren't on the very start of a region.\n       *\n       * @param aNeedle The element you are looking for.\n       * @param aHaystack The array that is being searched.\n       * @param aCompare A function which takes the needle and an element in the\n       *     array and returns -1, 0, or 1 depending on whether the needle is less\n       *     than, equal to, or greater than the element, respectively.\n       * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n       *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n       *     closest element that is smaller than or greater than the one we are\n       *     searching for, respectively, if the exact element cannot be found.\n       *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n       */\n\n\n      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n        if (aHaystack.length === 0) {\n          return -1;\n        }\n\n        var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n\n        if (index < 0) {\n          return -1;\n        } // We have found either the exact element, or the next-closest element than\n        // the one we are searching for. However, there may be more than one such\n        // element. Make sure we always return the smallest of these.\n\n\n        while (index - 1 >= 0) {\n          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n            break;\n          }\n\n          --index;\n        }\n\n        return index;\n      };\n      /***/\n\n    },\n    /* 154 */\n\n    /***/\n    function (module, exports) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      // It turns out that some (most?) JavaScript engines don't self-host\n      // `Array.prototype.sort`. This makes sense because C++ will likely remain\n      // faster than JS when doing raw CPU-intensive sorting. However, when using a\n      // custom comparator function, calling back and forth between the VM's C++ and\n      // JIT'd JS is rather slow *and* loses JIT type information, resulting in\n      // worse generated code for the comparator function than would be optimal. In\n      // fact, when sorting with a comparator, these costs outweigh the benefits of\n      // sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n      // a ~3500ms mean speed-up in `bench/bench.html`.\n\n      /**\n       * Swap the elements indexed by `x` and `y` in the array `ary`.\n       *\n       * @param {Array} ary\n       *        The array.\n       * @param {Number} x\n       *        The index of the first item.\n       * @param {Number} y\n       *        The index of the second item.\n       */\n      function swap(ary, x, y) {\n        var temp = ary[x];\n        ary[x] = ary[y];\n        ary[y] = temp;\n      }\n      /**\n       * Returns a random integer within the range `low .. high` inclusive.\n       *\n       * @param {Number} low\n       *        The lower bound on the range.\n       * @param {Number} high\n       *        The upper bound on the range.\n       */\n\n\n      function randomIntInRange(low, high) {\n        return Math.round(low + Math.random() * (high - low));\n      }\n      /**\n       * The Quick Sort algorithm.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       * @param {Number} p\n       *        Start index of the array\n       * @param {Number} r\n       *        End index of the array\n       */\n\n\n      function doQuickSort(ary, comparator, p, r) {\n        // If our lower bound is less than our upper bound, we (1) partition the\n        // array into two pieces and (2) recurse on each half. If it is not, this is\n        // the empty array and our base case.\n        if (p < r) {\n          // (1) Partitioning.\n          //\n          // The partitioning chooses a pivot between `p` and `r` and moves all\n          // elements that are less than or equal to the pivot to the before it, and\n          // all the elements that are greater than it after it. The effect is that\n          // once partition is done, the pivot is in the exact place it will be when\n          // the array is put in sorted order, and it will not need to be moved\n          // again. This runs in O(n) time.\n          // Always choose a random pivot so that an input array which is reverse\n          // sorted does not cause O(n^2) running time.\n          var pivotIndex = randomIntInRange(p, r);\n          var i = p - 1;\n          swap(ary, pivotIndex, r);\n          var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold\n          // true:\n          //\n          //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n          //\n          //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n\n          for (var j = p; j < r; j++) {\n            if (comparator(ary[j], pivot) <= 0) {\n              i += 1;\n              swap(ary, i, j);\n            }\n          }\n\n          swap(ary, i + 1, j);\n          var q = i + 1; // (2) Recurse on each half.\n\n          doQuickSort(ary, comparator, p, q - 1);\n          doQuickSort(ary, comparator, q + 1, r);\n        }\n      }\n      /**\n       * Sort the given array in-place with the given comparator function.\n       *\n       * @param {Array} ary\n       *        An array to sort.\n       * @param {function} comparator\n       *        Function to use to compare two items.\n       */\n\n\n      exports.quickSort = function (ary, comparator) {\n        doQuickSort(ary, comparator, 0, ary.length - 1);\n      };\n      /***/\n\n    },\n    /* 155 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* -*- Mode: js; js-indent-level: 2; -*- */\n\n      /*\n       * Copyright 2011 Mozilla Foundation and contributors\n       * Licensed under the New BSD license. See LICENSE or:\n       * http://opensource.org/licenses/BSD-3-Clause\n       */\n      var SourceMapGenerator = __webpack_require__(79).SourceMapGenerator;\n\n      var util = __webpack_require__(9); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n      // operating systems these days (capturing the result).\n\n\n      var REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\n      var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n      // the source-map library are loaded. This MUST NOT CHANGE across\n      // versions!\n\n      var isSourceNode = \"$$$isSourceNode$$$\";\n      /**\n       * SourceNodes provide a way to abstract over interpolating/concatenating\n       * snippets of generated JavaScript source code while maintaining the line and\n       * column information associated with the original source code.\n       *\n       * @param aLine The original line number.\n       * @param aColumn The original column number.\n       * @param aSource The original source's filename.\n       * @param aChunks Optional. An array of strings which are snippets of\n       *        generated JS, or other SourceNodes.\n       * @param aName The original identifier.\n       */\n\n      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n        this.children = [];\n        this.sourceContents = {};\n        this.line = aLine == null ? null : aLine;\n        this.column = aColumn == null ? null : aColumn;\n        this.source = aSource == null ? null : aSource;\n        this.name = aName == null ? null : aName;\n        this[isSourceNode] = true;\n        if (aChunks != null) this.add(aChunks);\n      }\n      /**\n       * Creates a SourceNode from generated code and a SourceMapConsumer.\n       *\n       * @param aGeneratedCode The generated code\n       * @param aSourceMapConsumer The SourceMap for the generated code\n       * @param aRelativePath Optional. The path that relative sources in the\n       *        SourceMapConsumer should be relative to.\n       */\n\n\n      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n        // The SourceNode we want to fill with the generated code\n        // and the SourceMap\n        var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n        // while all odd indices are the newlines between two adjacent lines\n        // (since `REGEX_NEWLINE` captures its match).\n        // Processed fragments are removed from this array, by calling `shiftNextLine`.\n\n        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n\n        var shiftNextLine = function shiftNextLine() {\n          var lineContents = remainingLines.shift(); // The last line of a file might not have a newline.\n\n          var newLine = remainingLines.shift() || \"\";\n          return lineContents + newLine;\n        }; // We need to remember the position of \"remainingLines\"\n\n\n        var lastGeneratedLine = 1,\n            lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n        // To extract it current and last mapping is used.\n        // Here we store the last mapping.\n\n        var lastMapping = null;\n        aSourceMapConsumer.eachMapping(function (mapping) {\n          if (lastMapping !== null) {\n            // We add the code from \"lastMapping\" to \"mapping\":\n            // First check if there is a new line in between.\n            if (lastGeneratedLine < mapping.generatedLine) {\n              // Associate first line with \"lastMapping\"\n              addMappingWithCode(lastMapping, shiftNextLine());\n              lastGeneratedLine++;\n              lastGeneratedColumn = 0; // The remaining code is added without mapping\n            } else {\n              // There is no new line in between.\n              // Associate the code between \"lastGeneratedColumn\" and\n              // \"mapping.generatedColumn\" with \"lastMapping\"\n              var nextLine = remainingLines[0];\n              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n              remainingLines[0] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n              lastGeneratedColumn = mapping.generatedColumn;\n              addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n              lastMapping = mapping;\n              return;\n            }\n          } // We add the generated code until the first mapping\n          // to the SourceNode without any mapping.\n          // Each line is added as separate string.\n\n\n          while (lastGeneratedLine < mapping.generatedLine) {\n            node.add(shiftNextLine());\n            lastGeneratedLine++;\n          }\n\n          if (lastGeneratedColumn < mapping.generatedColumn) {\n            var nextLine = remainingLines[0];\n            node.add(nextLine.substr(0, mapping.generatedColumn));\n            remainingLines[0] = nextLine.substr(mapping.generatedColumn);\n            lastGeneratedColumn = mapping.generatedColumn;\n          }\n\n          lastMapping = mapping;\n        }, this); // We have processed all mappings.\n\n        if (remainingLines.length > 0) {\n          if (lastMapping) {\n            // Associate the remaining code in the current line with \"lastMapping\"\n            addMappingWithCode(lastMapping, shiftNextLine());\n          } // and add the remaining lines without any mapping\n\n\n          node.add(remainingLines.join(\"\"));\n        } // Copy sourcesContent into SourceNode\n\n\n        aSourceMapConsumer.sources.forEach(function (sourceFile) {\n          var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n          if (content != null) {\n            if (aRelativePath != null) {\n              sourceFile = util.join(aRelativePath, sourceFile);\n            }\n\n            node.setSourceContent(sourceFile, content);\n          }\n        });\n        return node;\n\n        function addMappingWithCode(mapping, code) {\n          if (mapping === null || mapping.source === undefined) {\n            node.add(code);\n          } else {\n            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n            node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n          }\n        }\n      };\n      /**\n       * Add a chunk of generated JS to this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.add = function SourceNode_add(aChunk) {\n        if (Array.isArray(aChunk)) {\n          aChunk.forEach(function (chunk) {\n            this.add(chunk);\n          }, this);\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          if (aChunk) {\n            this.children.push(aChunk);\n          }\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Add a chunk of generated JS to the beginning of this source node.\n       *\n       * @param aChunk A string snippet of generated JS code, another instance of\n       *        SourceNode, or an array where each member is one of those things.\n       */\n\n\n      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n        if (Array.isArray(aChunk)) {\n          for (var i = aChunk.length - 1; i >= 0; i--) {\n            this.prepend(aChunk[i]);\n          }\n        } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n          this.children.unshift(aChunk);\n        } else {\n          throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n        }\n\n        return this;\n      };\n      /**\n       * Walk over the tree of JS snippets in this node and its children. The\n       * walking function is called once for each snippet of JS and is passed that\n       * snippet and the its original associated source's line/column location.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walk = function SourceNode_walk(aFn) {\n        var chunk;\n\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          chunk = this.children[i];\n\n          if (chunk[isSourceNode]) {\n            chunk.walk(aFn);\n          } else {\n            if (chunk !== '') {\n              aFn(chunk, {\n                source: this.source,\n                line: this.line,\n                column: this.column,\n                name: this.name\n              });\n            }\n          }\n        }\n      };\n      /**\n       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n       * each of `this.children`.\n       *\n       * @param aSep The separator.\n       */\n\n\n      SourceNode.prototype.join = function SourceNode_join(aSep) {\n        var newChildren;\n        var i;\n        var len = this.children.length;\n\n        if (len > 0) {\n          newChildren = [];\n\n          for (i = 0; i < len - 1; i++) {\n            newChildren.push(this.children[i]);\n            newChildren.push(aSep);\n          }\n\n          newChildren.push(this.children[i]);\n          this.children = newChildren;\n        }\n\n        return this;\n      };\n      /**\n       * Call String.prototype.replace on the very right-most source snippet. Useful\n       * for trimming whitespace from the end of a source node, etc.\n       *\n       * @param aPattern The pattern to replace.\n       * @param aReplacement The thing to replace the pattern with.\n       */\n\n\n      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n        var lastChild = this.children[this.children.length - 1];\n\n        if (lastChild[isSourceNode]) {\n          lastChild.replaceRight(aPattern, aReplacement);\n        } else if (typeof lastChild === 'string') {\n          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n        } else {\n          this.children.push(''.replace(aPattern, aReplacement));\n        }\n\n        return this;\n      };\n      /**\n       * Set the source content for a source file. This will be added to the SourceMapGenerator\n       * in the sourcesContent field.\n       *\n       * @param aSourceFile The filename of the source file\n       * @param aSourceContent The content of the source file\n       */\n\n\n      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n      };\n      /**\n       * Walk over the tree of SourceNodes. The walking function is called for each\n       * source file content and is passed the filename and source content.\n       *\n       * @param aFn The traversal function.\n       */\n\n\n      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          if (this.children[i][isSourceNode]) {\n            this.children[i].walkSourceContents(aFn);\n          }\n        }\n\n        var sources = Object.keys(this.sourceContents);\n\n        for (var i = 0, len = sources.length; i < len; i++) {\n          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n        }\n      };\n      /**\n       * Return the string representation of this source node. Walks over the tree\n       * and concatenates all the various snippets together to one string.\n       */\n\n\n      SourceNode.prototype.toString = function SourceNode_toString() {\n        var str = \"\";\n        this.walk(function (chunk) {\n          str += chunk;\n        });\n        return str;\n      };\n      /**\n       * Returns the string representation of this source node along with a source\n       * map.\n       */\n\n\n      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n        var generated = {\n          code: \"\",\n          line: 1,\n          column: 0\n        };\n        var map = new SourceMapGenerator(aArgs);\n        var sourceMappingActive = false;\n        var lastOriginalSource = null;\n        var lastOriginalLine = null;\n        var lastOriginalColumn = null;\n        var lastOriginalName = null;\n        this.walk(function (chunk, original) {\n          generated.code += chunk;\n\n          if (original.source !== null && original.line !== null && original.column !== null) {\n            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n              map.addMapping({\n                source: original.source,\n                original: {\n                  line: original.line,\n                  column: original.column\n                },\n                generated: {\n                  line: generated.line,\n                  column: generated.column\n                },\n                name: original.name\n              });\n            }\n\n            lastOriginalSource = original.source;\n            lastOriginalLine = original.line;\n            lastOriginalColumn = original.column;\n            lastOriginalName = original.name;\n            sourceMappingActive = true;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              generated: {\n                line: generated.line,\n                column: generated.column\n              }\n            });\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          }\n\n          for (var idx = 0, length = chunk.length; idx < length; idx++) {\n            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n              generated.line++;\n              generated.column = 0; // Mappings end at eol\n\n              if (idx + 1 === length) {\n                lastOriginalSource = null;\n                sourceMappingActive = false;\n              } else if (sourceMappingActive) {\n                map.addMapping({\n                  source: original.source,\n                  original: {\n                    line: original.line,\n                    column: original.column\n                  },\n                  generated: {\n                    line: generated.line,\n                    column: generated.column\n                  },\n                  name: original.name\n                });\n              }\n            } else {\n              generated.column++;\n            }\n          }\n        });\n        this.walkSourceContents(function (sourceFile, sourceContent) {\n          map.setSourceContent(sourceFile, sourceContent);\n        });\n        return {\n          code: generated.code,\n          map: map\n        };\n      };\n\n      exports.SourceNode = SourceNode;\n      /***/\n    },\n    /* 156 */\n\n    /***/\n    function (module, exports) {\n      /* (ignored) */\n\n      /***/\n    },\n    /* 157 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(object);\n\n          if (parent === null) {\n            return undefined;\n          } else {\n            return get(parent, property, receiver);\n          }\n        } else if (\"value\" in desc) {\n          return desc.value;\n        } else {\n          var getter = desc.get;\n\n          if (getter === undefined) {\n            return undefined;\n          }\n\n          return getter.call(receiver);\n        }\n      };\n\n      var _rule = __webpack_require__(10);\n\n      var _rule2 = _interopRequireDefault(_rule);\n\n      var _lessStringify = __webpack_require__(14);\n\n      var _lessStringify2 = _interopRequireDefault(_lessStringify);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Import = function (_PostCssRule) {\n        _inherits(Import, _PostCssRule);\n\n        function Import(defaults) {\n          _classCallCheck(this, Import);\n\n          var _this = _possibleConstructorReturn(this, (Import.__proto__ || Object.getPrototypeOf(Import)).call(this, defaults));\n\n          _this.type = 'import';\n          return _this;\n        }\n\n        _createClass(Import, [{\n          key: 'toString',\n          value: function toString(stringifier) {\n            if (!stringifier) {\n              stringifier = {\n                stringify: _lessStringify2.default\n              };\n            }\n\n            return _get(Import.prototype.__proto__ || Object.getPrototypeOf(Import.prototype), 'toString', this).call(this, stringifier);\n          }\n        }]);\n\n        return Import;\n      }(_rule2.default);\n\n      exports.default = Import;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 158 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _jsBase = __webpack_require__(77);\n\n      var _sourceMap = __webpack_require__(78);\n\n      var _sourceMap2 = _interopRequireDefault(_sourceMap);\n\n      var _path = __webpack_require__(6);\n\n      var _path2 = _interopRequireDefault(_path);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var MapGenerator = function () {\n        function MapGenerator(stringify, root, opts) {\n          _classCallCheck(this, MapGenerator);\n\n          this.stringify = stringify;\n          this.mapOpts = opts.map || {};\n          this.root = root;\n          this.opts = opts;\n        }\n\n        MapGenerator.prototype.isMap = function isMap() {\n          if (typeof this.opts.map !== 'undefined') {\n            return !!this.opts.map;\n          } else {\n            return this.previous().length > 0;\n          }\n        };\n\n        MapGenerator.prototype.previous = function previous() {\n          var _this = this;\n\n          if (!this.previousMaps) {\n            this.previousMaps = [];\n            this.root.walk(function (node) {\n              if (node.source && node.source.input.map) {\n                var map = node.source.input.map;\n\n                if (_this.previousMaps.indexOf(map) === -1) {\n                  _this.previousMaps.push(map);\n                }\n              }\n            });\n          }\n\n          return this.previousMaps;\n        };\n\n        MapGenerator.prototype.isInline = function isInline() {\n          if (typeof this.mapOpts.inline !== 'undefined') {\n            return this.mapOpts.inline;\n          }\n\n          var annotation = this.mapOpts.annotation;\n\n          if (typeof annotation !== 'undefined' && annotation !== true) {\n            return false;\n          }\n\n          if (this.previous().length) {\n            return this.previous().some(function (i) {\n              return i.inline;\n            });\n          } else {\n            return true;\n          }\n        };\n\n        MapGenerator.prototype.isSourcesContent = function isSourcesContent() {\n          if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n            return this.mapOpts.sourcesContent;\n          }\n\n          if (this.previous().length) {\n            return this.previous().some(function (i) {\n              return i.withContent();\n            });\n          } else {\n            return true;\n          }\n        };\n\n        MapGenerator.prototype.clearAnnotation = function clearAnnotation() {\n          if (this.mapOpts.annotation === false) return;\n          var node = void 0;\n\n          for (var i = this.root.nodes.length - 1; i >= 0; i--) {\n            node = this.root.nodes[i];\n            if (node.type !== 'comment') continue;\n\n            if (node.text.indexOf('# sourceMappingURL=') === 0) {\n              this.root.removeChild(i);\n            }\n          }\n        };\n\n        MapGenerator.prototype.setSourcesContent = function setSourcesContent() {\n          var _this2 = this;\n\n          var already = {};\n          this.root.walk(function (node) {\n            if (node.source) {\n              var from = node.source.input.from;\n\n              if (from && !already[from]) {\n                already[from] = true;\n\n                var relative = _this2.relative(from);\n\n                _this2.map.setSourceContent(relative, node.source.input.css);\n              }\n            }\n          });\n        };\n\n        MapGenerator.prototype.applyPrevMaps = function applyPrevMaps() {\n          for (var _iterator = this.previous(), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var prev = _ref;\n            var from = this.relative(prev.file);\n\n            var root = prev.root || _path2.default.dirname(prev.file);\n\n            var map = void 0;\n\n            if (this.mapOpts.sourcesContent === false) {\n              map = new _sourceMap2.default.SourceMapConsumer(prev.text);\n\n              if (map.sourcesContent) {\n                map.sourcesContent = map.sourcesContent.map(function () {\n                  return null;\n                });\n              }\n            } else {\n              map = prev.consumer();\n            }\n\n            this.map.applySourceMap(map, from, this.relative(root));\n          }\n        };\n\n        MapGenerator.prototype.isAnnotation = function isAnnotation() {\n          if (this.isInline()) {\n            return true;\n          } else if (typeof this.mapOpts.annotation !== 'undefined') {\n            return this.mapOpts.annotation;\n          } else if (this.previous().length) {\n            return this.previous().some(function (i) {\n              return i.annotation;\n            });\n          } else {\n            return true;\n          }\n        };\n\n        MapGenerator.prototype.addAnnotation = function addAnnotation() {\n          var content = void 0;\n\n          if (this.isInline()) {\n            content = 'data:application/json;base64,' + _jsBase.Base64.encode(this.map.toString());\n          } else if (typeof this.mapOpts.annotation === 'string') {\n            content = this.mapOpts.annotation;\n          } else {\n            content = this.outputFile() + '.map';\n          }\n\n          var eol = '\\n';\n          if (this.css.indexOf('\\r\\n') !== -1) eol = '\\r\\n';\n          this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n        };\n\n        MapGenerator.prototype.outputFile = function outputFile() {\n          if (this.opts.to) {\n            return this.relative(this.opts.to);\n          } else if (this.opts.from) {\n            return this.relative(this.opts.from);\n          } else {\n            return 'to.css';\n          }\n        };\n\n        MapGenerator.prototype.generateMap = function generateMap() {\n          this.generateString();\n          if (this.isSourcesContent()) this.setSourcesContent();\n          if (this.previous().length > 0) this.applyPrevMaps();\n          if (this.isAnnotation()) this.addAnnotation();\n\n          if (this.isInline()) {\n            return [this.css];\n          } else {\n            return [this.css, this.map];\n          }\n        };\n\n        MapGenerator.prototype.relative = function relative(file) {\n          if (file.indexOf('<') === 0) return file;\n          if (/^\\w+:\\/\\//.test(file)) return file;\n          var from = this.opts.to ? _path2.default.dirname(this.opts.to) : '.';\n\n          if (typeof this.mapOpts.annotation === 'string') {\n            from = _path2.default.dirname(_path2.default.resolve(from, this.mapOpts.annotation));\n          }\n\n          file = _path2.default.relative(from, file);\n\n          if (_path2.default.sep === '\\\\') {\n            return file.replace(/\\\\/g, '/');\n          } else {\n            return file;\n          }\n        };\n\n        MapGenerator.prototype.sourcePath = function sourcePath(node) {\n          if (this.mapOpts.from) {\n            return this.mapOpts.from;\n          } else {\n            return this.relative(node.source.input.from);\n          }\n        };\n\n        MapGenerator.prototype.generateString = function generateString() {\n          var _this3 = this;\n\n          this.css = '';\n          this.map = new _sourceMap2.default.SourceMapGenerator({\n            file: this.outputFile()\n          });\n          var line = 1;\n          var column = 1;\n          var lines = void 0,\n              last = void 0;\n          this.stringify(this.root, function (str, node, type) {\n            _this3.css += str;\n\n            if (node && type !== 'end') {\n              if (node.source && node.source.start) {\n                _this3.map.addMapping({\n                  source: _this3.sourcePath(node),\n                  generated: {\n                    line: line,\n                    column: column - 1\n                  },\n                  original: {\n                    line: node.source.start.line,\n                    column: node.source.start.column - 1\n                  }\n                });\n              } else {\n                _this3.map.addMapping({\n                  source: '<no source>',\n                  original: {\n                    line: 1,\n                    column: 0\n                  },\n                  generated: {\n                    line: line,\n                    column: column - 1\n                  }\n                });\n              }\n            }\n\n            lines = str.match(/\\n/g);\n\n            if (lines) {\n              line += lines.length;\n              last = str.lastIndexOf('\\n');\n              column = str.length - last;\n            } else {\n              column += str.length;\n            }\n\n            if (node && type !== 'start') {\n              if (node.source && node.source.end) {\n                _this3.map.addMapping({\n                  source: _this3.sourcePath(node),\n                  generated: {\n                    line: line,\n                    column: column - 1\n                  },\n                  original: {\n                    line: node.source.end.line,\n                    column: node.source.end.column\n                  }\n                });\n              } else {\n                _this3.map.addMapping({\n                  source: '<no source>',\n                  original: {\n                    line: 1,\n                    column: 0\n                  },\n                  generated: {\n                    line: line,\n                    column: column - 1\n                  }\n                });\n              }\n            }\n          });\n        };\n\n        MapGenerator.prototype.generate = function generate() {\n          this.clearAnnotation();\n\n          if (this.isMap()) {\n            return this.generateMap();\n          } else {\n            var result = '';\n            this.stringify(this.root, function (i) {\n              result += i;\n            });\n            return [result];\n          }\n        };\n\n        return MapGenerator;\n      }();\n\n      exports.default = MapGenerator;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 159 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _warning = __webpack_require__(160);\n\n      var _warning2 = _interopRequireDefault(_warning);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Provides the result of the PostCSS transformations.\n       *\n       * A Result instance is returned by {@link LazyResult#then}\n       * or {@link Root#toResult} methods.\n       *\n       * @example\n       * postcss([cssnext]).process(css).then(function (result) {\n       *    console.log(result.css);\n       * });\n       *\n       * @example\n       * var result2 = postcss.parse(css).toResult();\n       */\n\n\n      var Result = function () {\n        /**\n         * @param {Processor} processor - processor used for this transformation.\n         * @param {Root}      root      - Root node after all transformations.\n         * @param {processOptions} opts - options from the {@link Processor#process}\n         *                                or {@link Root#toResult}\n         */\n        function Result(processor, root, opts) {\n          _classCallCheck(this, Result);\n          /**\n           * @member {Processor} - The Processor instance used\n           *                       for this transformation.\n           *\n           * @example\n           * for ( let plugin of result.processor.plugins) {\n           *   if ( plugin.postcssPlugin === 'postcss-bad' ) {\n           *     throw 'postcss-good is incompatible with postcss-bad';\n           *   }\n           * });\n           */\n\n\n          this.processor = processor;\n          /**\n           * @member {Message[]} - Contains messages from plugins\n           *                       (e.g., warnings or custom messages).\n           *                       Each message should have type\n           *                       and plugin properties.\n           *\n           * @example\n           * postcss.plugin('postcss-min-browser', () => {\n           *   return (root, result) => {\n           *     var browsers = detectMinBrowsersByCanIUse(root);\n           *     result.messages.push({\n           *       type:    'min-browser',\n           *       plugin:  'postcss-min-browser',\n           *       browsers: browsers\n           *     });\n           *   };\n           * });\n           */\n\n          this.messages = [];\n          /**\n           * @member {Root} - Root node after all transformations.\n           *\n           * @example\n           * root.toResult().root == root;\n           */\n\n          this.root = root;\n          /**\n           * @member {processOptions} - Options from the {@link Processor#process}\n           *                            or {@link Root#toResult} call\n           *                            that produced this Result instance.\n           *\n           * @example\n           * root.toResult(opts).opts == opts;\n           */\n\n          this.opts = opts;\n          /**\n           * @member {string} - A CSS string representing of {@link Result#root}.\n           *\n           * @example\n           * postcss.parse('a{}').toResult().css //=> \"a{}\"\n           */\n\n          this.css = undefined;\n          /**\n           * @member {SourceMapGenerator} - An instance of `SourceMapGenerator`\n           *                                class from the `source-map` library,\n           *                                representing changes\n           *                                to the {@link Result#root} instance.\n           *\n           * @example\n           * result.map.toJSON() //=> { version: 3, file: 'a.css',  }\n           *\n           * @example\n           * if ( result.map ) {\n           *   fs.writeFileSync(result.opts.to + '.map', result.map.toString());\n           * }\n           */\n\n          this.map = undefined;\n        }\n        /**\n         * Returns for @{link Result#css} content.\n         *\n         * @example\n         * result + '' === result.css\n         *\n         * @return {string} string representing of {@link Result#root}\n         */\n\n\n        Result.prototype.toString = function toString() {\n          return this.css;\n        };\n        /**\n         * Creates an instance of {@link Warning} and adds it\n         * to {@link Result#messages}.\n         *\n         * @param {string} text        - warning message\n         * @param {Object} [opts]      - warning options\n         * @param {Node}   opts.node   - CSS node that caused the warning\n         * @param {string} opts.word   - word in CSS source that caused the warning\n         * @param {number} opts.index  - index in CSS node string that caused\n         *                               the warning\n         * @param {string} opts.plugin - name of the plugin that created\n         *                               this warning. {@link Result#warn} fills\n         *                               this property automatically.\n         *\n         * @return {Warning} created warning\n         */\n\n\n        Result.prototype.warn = function warn(text) {\n          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n              opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n          }\n\n          var warning = new _warning2.default(text, opts);\n          this.messages.push(warning);\n          return warning;\n        };\n        /**\n         * Returns warnings from plugins. Filters {@link Warning} instances\n         * from {@link Result#messages}.\n         *\n         * @example\n         * result.warnings().forEach(warn => {\n         *   console.warn(warn.toString());\n         * });\n         *\n         * @return {Warning[]} warnings from plugins\n         */\n\n\n        Result.prototype.warnings = function warnings() {\n          return this.messages.filter(function (i) {\n            return i.type === 'warning';\n          });\n        };\n        /**\n         * An alias for the {@link Result#css} property.\n         * Use it with syntaxes that generate non-CSS output.\n         * @type {string}\n         *\n         * @example\n         * result.css === result.content;\n         */\n\n\n        _createClass(Result, [{\n          key: 'content',\n          get: function get() {\n            return this.css;\n          }\n        }]);\n\n        return Result;\n      }();\n\n      exports.default = Result;\n      /**\n       * @typedef  {object} Message\n       * @property {string} type   - message type\n       * @property {string} plugin - source PostCSS plugin name\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 160 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Represents a plugins warning. It can be created using {@link Node#warn}.\n       *\n       * @example\n       * if ( decl.important ) {\n       *     decl.warn(result, 'Avoid !important', { word: '!important' });\n       * }\n       */\n\n\n      var Warning = function () {\n        /**\n         * @param {string} text        - warning message\n         * @param {Object} [opts]      - warning options\n         * @param {Node}   opts.node   - CSS node that caused the warning\n         * @param {string} opts.word   - word in CSS source that caused the warning\n         * @param {number} opts.index  - index in CSS node string that caused\n         *                               the warning\n         * @param {string} opts.plugin - name of the plugin that created\n         *                               this warning. {@link Result#warn} fills\n         *                               this property automatically.\n         */\n        function Warning(text) {\n          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          _classCallCheck(this, Warning);\n          /**\n           * @member {string} - Type to filter warnings from\n           *                    {@link Result#messages}. Always equal\n           *                    to `\"warning\"`.\n           *\n           * @example\n           * const nonWarning = result.messages.filter(i => i.type !== 'warning')\n           */\n\n\n          this.type = 'warning';\n          /**\n           * @member {string} - The warning message.\n           *\n           * @example\n           * warning.text //=> 'Try to avoid !important'\n           */\n\n          this.text = text;\n\n          if (opts.node && opts.node.source) {\n            var pos = opts.node.positionBy(opts);\n            /**\n             * @member {number} - Line in the input file\n             *                    with this warnings source\n             *\n             * @example\n             * warning.line //=> 5\n             */\n\n            this.line = pos.line;\n            /**\n             * @member {number} - Column in the input file\n             *                    with this warnings source.\n             *\n             * @example\n             * warning.column //=> 6\n             */\n\n            this.column = pos.column;\n          }\n\n          for (var opt in opts) {\n            this[opt] = opts[opt];\n          }\n        }\n        /**\n         * Returns a warning position and message.\n         *\n         * @example\n         * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'\n         *\n         * @return {string} warning position and message\n         */\n\n\n        Warning.prototype.toString = function toString() {\n          if (this.node) {\n            return this.node.error(this.text, {\n              plugin: this.plugin,\n              index: this.index,\n              word: this.word\n            }).message;\n          } else if (this.plugin) {\n            return this.plugin + ': ' + this.text;\n          } else {\n            return this.text;\n          }\n        };\n        /**\n         * @memberof Warning#\n         * @member {string} plugin - The name of the plugin that created\n         *                           it will fill this property automatically.\n         *                           this warning. When you call {@link Node#warn}\n         *\n         * @example\n         * warning.plugin //=> 'postcss-important'\n         */\n\n        /**\n         * @memberof Warning#\n         * @member {Node} node - Contains the CSS node that caused the warning.\n         *\n         * @example\n         * warning.node.toString() //=> 'color: white !important'\n         */\n\n\n        return Warning;\n      }();\n\n      exports.default = Warning;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 161 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof2(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof2 = function _typeof2(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof2 = function _typeof2(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof2(obj);\n      }\n\n      exports.__esModule = true;\n\n      var _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n        return _typeof2(obj);\n      } : function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : _typeof2(obj);\n      };\n\n      var _lazyResult = __webpack_require__(86);\n\n      var _lazyResult2 = _interopRequireDefault(_lazyResult);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n      /**\n       * Contains plugins to process CSS. Create one `Processor` instance,\n       * initialize its plugins, and then use that instance on numerous CSS files.\n       *\n       * @example\n       * const processor = postcss([autoprefixer, precss]);\n       * processor.process(css1).then(result => console.log(result.css));\n       * processor.process(css2).then(result => console.log(result.css));\n       */\n\n\n      var Processor = function () {\n        /**\n         * @param {Array.<Plugin|pluginFunction>|Processor} plugins - PostCSS\n         *        plugins. See {@link Processor#use} for plugin format.\n         */\n        function Processor() {\n          var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n          _classCallCheck(this, Processor);\n          /**\n           * @member {string} - Current PostCSS version.\n           *\n           * @example\n           * if ( result.processor.version.split('.')[0] !== '5' ) {\n           *   throw new Error('This plugin works only with PostCSS 5');\n           * }\n           */\n\n\n          this.version = '5.2.17';\n          /**\n           * @member {pluginFunction[]} - Plugins added to this processor.\n           *\n           * @example\n           * const processor = postcss([autoprefixer, precss]);\n           * processor.plugins.length //=> 2\n           */\n\n          this.plugins = this.normalize(plugins);\n        }\n        /**\n         * Adds a plugin to be used as a CSS processor.\n         *\n         * PostCSS plugin can be in 4 formats:\n         * * A plugin created by {@link postcss.plugin} method.\n         * * A function. PostCSS will pass the function a @{link Root}\n         *   as the first argument and current {@link Result} instance\n         *   as the second.\n         * * An object with a `postcss` method. PostCSS will use that method\n         *   as described in #2.\n         * * Another {@link Processor} instance. PostCSS will copy plugins\n         *   from that instance into this one.\n         *\n         * Plugins can also be added by passing them as arguments when creating\n         * a `postcss` instance (see [`postcss(plugins)`]).\n         *\n         * Asynchronous plugins should return a `Promise` instance.\n         *\n         * @param {Plugin|pluginFunction|Processor} plugin - PostCSS plugin\n         *                                                   or {@link Processor}\n         *                                                   with plugins\n         *\n         * @example\n         * const processor = postcss()\n         *   .use(autoprefixer)\n         *   .use(precss);\n         *\n         * @return {Processes} current processor to make methods chain\n         */\n\n\n        Processor.prototype.use = function use(plugin) {\n          this.plugins = this.plugins.concat(this.normalize([plugin]));\n          return this;\n        };\n        /**\n         * Parses source CSS and returns a {@link LazyResult} Promise proxy.\n         * Because some plugins can be asynchronous it doesnt make\n         * any transformations. Transformations will be applied\n         * in the {@link LazyResult} methods.\n         *\n         * @param {string|toString|Result} css - String with input CSS or\n         *                                       any object with a `toString()`\n         *                                       method, like a Buffer.\n         *                                       Optionally, send a {@link Result}\n         *                                       instance and the processor will\n         *                                       take the {@link Root} from it.\n         * @param {processOptions} [opts]      - options\n         *\n         * @return {LazyResult} Promise proxy\n         *\n         * @example\n         * processor.process(css, { from: 'a.css', to: 'a.out.css' })\n         *   .then(result => {\n         *      console.log(result.css);\n         *   });\n         */\n\n\n        Processor.prototype.process = function process(css) {\n          var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n          return new _lazyResult2.default(this, css, opts);\n        };\n\n        Processor.prototype.normalize = function normalize(plugins) {\n          var normalized = [];\n\n          for (var _iterator = plugins, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n            var _ref;\n\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n\n            var i = _ref;\n            if (i.postcss) i = i.postcss;\n\n            if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && Array.isArray(i.plugins)) {\n              normalized = normalized.concat(i.plugins);\n            } else if (typeof i === 'function') {\n              normalized.push(i);\n            } else if ((typeof i === 'undefined' ? 'undefined' : _typeof(i)) === 'object' && (i.parse || i.stringify)) {\n              throw new Error('PostCSS syntaxes cannot be used as plugins. ' + 'Instead, please use one of the ' + 'syntax/parser/stringifier options as ' + 'outlined in your PostCSS ' + 'runner documentation.');\n            } else {\n              throw new Error(i + ' is not a PostCSS plugin');\n            }\n          }\n\n          return normalized;\n        };\n\n        return Processor;\n      }();\n\n      exports.default = Processor;\n      /**\n       * @callback builder\n       * @param {string} part          - part of generated CSS connected to this node\n       * @param {Node}   node          - AST node\n       * @param {\"start\"|\"end\"} [type] - nodes part type\n       */\n\n      /**\n       * @callback parser\n       *\n       * @param {string|toString} css   - string with input CSS or any object\n       *                                  with toString() method, like a Buffer\n       * @param {processOptions} [opts] - options with only `from` and `map` keys\n       *\n       * @return {Root} PostCSS AST\n       */\n\n      /**\n       * @callback stringifier\n       *\n       * @param {Node} node       - start node for stringifing. Usually {@link Root}.\n       * @param {builder} builder - function to concatenate CSS from nodes parts\n       *                            or generate string and source map\n       *\n       * @return {void}\n       */\n\n      /**\n       * @typedef {object} syntax\n       * @property {parser} parse          - function to generate AST by string\n       * @property {stringifier} stringify - function to generate string by AST\n       */\n\n      /**\n       * @typedef {object} toString\n       * @property {function} toString\n       */\n\n      /**\n       * @callback pluginFunction\n       * @param {Root} root     - parsed input CSS\n       * @param {Result} result - result to set warnings or check other plugins\n       */\n\n      /**\n       * @typedef {object} Plugin\n       * @property {function} postcss - PostCSS plugin function\n       */\n\n      /**\n       * @typedef {object} processOptions\n       * @property {string} from             - the path of the CSS source file.\n       *                                       You should always set `from`,\n       *                                       because it is used in source map\n       *                                       generation and syntax error messages.\n       * @property {string} to               - the path where youll put the output\n       *                                       CSS file. You should always set `to`\n       *                                       to generate correct source maps.\n       * @property {parser} parser           - function to generate AST by string\n       * @property {stringifier} stringifier - class to generate string by AST\n       * @property {syntax} syntax           - object with `parse` and `stringify`\n       * @property {object} map              - source map options\n       * @property {boolean} map.inline                    - does source map should\n       *                                                     be embedded in the output\n       *                                                     CSS as a base64-encoded\n       *                                                     comment\n       * @property {string|object|false|function} map.prev - source map content\n       *                                                     from a previous\n       *                                                     processing step\n       *                                                     (for example, Sass).\n       *                                                     PostCSS will try to find\n       *                                                     previous map\n       *                                                     automatically, so you\n       *                                                     could disable it by\n       *                                                     `false` value.\n       * @property {boolean} map.sourcesContent            - does PostCSS should set\n       *                                                     the origin content to map\n       * @property {string|false} map.annotation           - does PostCSS should set\n       *                                                     annotation comment to map\n       * @property {string} map.from                       - override `from` in maps\n       *                                                     `sources`\n       */\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 162 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      exports.__esModule = true;\n      /**\n       * Contains helpers for safely splitting lists of CSS values,\n       * preserving parentheses and quotes.\n       *\n       * @example\n       * const list = postcss.list;\n       *\n       * @namespace list\n       */\n\n      var list = {\n        split: function split(string, separators, last) {\n          var array = [];\n          var current = '';\n          var split = false;\n          var func = 0;\n          var quote = false;\n          var escape = false;\n\n          for (var i = 0; i < string.length; i++) {\n            var letter = string[i];\n\n            if (quote) {\n              if (escape) {\n                escape = false;\n              } else if (letter === '\\\\') {\n                escape = true;\n              } else if (letter === quote) {\n                quote = false;\n              }\n            } else if (letter === '\"' || letter === '\\'') {\n              quote = letter;\n            } else if (letter === '(') {\n              func += 1;\n            } else if (letter === ')') {\n              if (func > 0) func -= 1;\n            } else if (func === 0) {\n              if (separators.indexOf(letter) !== -1) split = true;\n            }\n\n            if (split) {\n              if (current !== '') array.push(current.trim());\n              current = '';\n              split = false;\n            } else {\n              current += letter;\n            }\n          }\n\n          if (last || current !== '') array.push(current.trim());\n          return array;\n        },\n\n        /**\n         * Safely splits space-separated values (such as those for `background`,\n         * `border-radius`, and other shorthand properties).\n         *\n         * @param {string} string - space-separated values\n         *\n         * @return {string[]} split values\n         *\n         * @example\n         * postcss.list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']\n         */\n        space: function space(string) {\n          var spaces = [' ', '\\n', '\\t'];\n          return list.split(string, spaces);\n        },\n\n        /**\n         * Safely splits comma-separated values (such as those for `transition-*`\n         * and `background` properties).\n         *\n         * @param {string} string - comma-separated values\n         *\n         * @return {string[]} split values\n         *\n         * @example\n         * postcss.list.comma('black, linear-gradient(white, black)')\n         * //=> ['black', 'linear-gradient(white, black)']\n         */\n        comma: function comma(string) {\n          var comma = ',';\n          return list.split(string, [comma], true);\n        }\n      };\n      exports.default = list;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 163 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(object);\n\n          if (parent === null) {\n            return undefined;\n          } else {\n            return get(parent, property, receiver);\n          }\n        } else if (\"value\" in desc) {\n          return desc.value;\n        } else {\n          var getter = desc.get;\n\n          if (getter === undefined) {\n            return undefined;\n          }\n\n          return getter.call(receiver);\n        }\n      };\n\n      var _stringifier = __webpack_require__(24);\n\n      var _stringifier2 = _interopRequireDefault(_stringifier);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var LessStringifier = function (_Stringifier) {\n        _inherits(LessStringifier, _Stringifier);\n\n        function LessStringifier() {\n          _classCallCheck(this, LessStringifier);\n\n          return _possibleConstructorReturn(this, (LessStringifier.__proto__ || Object.getPrototypeOf(LessStringifier)).apply(this, arguments));\n        }\n\n        _createClass(LessStringifier, [{\n          key: 'comment',\n          value: function comment(node) {\n            this.builder(node.raws.content, node);\n          }\n        }, {\n          key: 'import',\n          value: function _import(node) {\n            this.builder('@' + node.name);\n            this.builder((node.raws.afterName || '') + (node.directives || '') + (node.raws.between || '') + (node.urlFunc ? 'url(' : '') + (node.raws.beforeUrl || '') + (node.importPath || '') + (node.raws.afterUrl || '') + (node.urlFunc ? ')' : '') + (node.raws.after || ''));\n\n            if (node.raws.semicolon) {\n              this.builder(';');\n            }\n          }\n        }, {\n          key: 'rule',\n          value: function rule(node) {\n            _get(LessStringifier.prototype.__proto__ || Object.getPrototypeOf(LessStringifier.prototype), 'rule', this).call(this, node);\n\n            if (node.empty && node.raws.semicolon) {\n              if (node.important) {\n                if (node.raws.important) {\n                  this.builder(node.raws.important);\n                } else {\n                  this.builder(' !important');\n                }\n              }\n\n              if (node.raws.semicolon) {\n                this.builder(';');\n              }\n            }\n          }\n        }, {\n          key: 'block',\n          value: function block(node, start) {\n            var empty = node.empty;\n            var between = this.raw(node, 'between', 'beforeOpen');\n            var after = '';\n\n            if (empty) {\n              this.builder(start + between, node, 'start');\n            } else {\n              this.builder(start + between + '{', node, 'start');\n            }\n\n            if (node.nodes && node.nodes.length) {\n              this.body(node);\n              after = this.raw(node, 'after');\n            } else {\n              after = this.raw(node, 'after', 'emptyBody');\n            }\n\n            if (after) {\n              this.builder(after);\n            }\n\n            if (!empty) {\n              this.builder('}', node, 'end');\n            }\n          }\n        }]);\n\n        return LessStringifier;\n      }(_stringifier2.default);\n\n      exports.default = LessStringifier;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 164 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(object);\n\n          if (parent === null) {\n            return undefined;\n          } else {\n            return get(parent, property, receiver);\n          }\n        } else if (\"value\" in desc) {\n          return desc.value;\n        } else {\n          var getter = desc.get;\n\n          if (getter === undefined) {\n            return undefined;\n          }\n\n          return getter.call(receiver);\n        }\n      };\n\n      var _rule = __webpack_require__(10);\n\n      var _rule2 = _interopRequireDefault(_rule);\n\n      var _lessStringify = __webpack_require__(14);\n\n      var _lessStringify2 = _interopRequireDefault(_lessStringify);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Rule = function (_PostCssRule) {\n        _inherits(Rule, _PostCssRule);\n\n        function Rule() {\n          _classCallCheck(this, Rule);\n\n          return _possibleConstructorReturn(this, (Rule.__proto__ || Object.getPrototypeOf(Rule)).apply(this, arguments));\n        }\n\n        _createClass(Rule, [{\n          key: 'toString',\n          value: function toString(stringifier) {\n            if (!stringifier) {\n              stringifier = {\n                stringify: _lessStringify2.default\n              };\n            }\n\n            return _get(Rule.prototype.__proto__ || Object.getPrototypeOf(Rule.prototype), 'toString', this).call(this, stringifier);\n          }\n        }]);\n\n        return Rule;\n      }(_rule2.default);\n\n      exports.default = Rule;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 165 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _typeof(obj) {\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n          _typeof = function _typeof(obj) {\n            return typeof obj;\n          };\n        } else {\n          _typeof = function _typeof(obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n        }\n\n        return _typeof(obj);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      var _get = function get(object, property, receiver) {\n        if (object === null) object = Function.prototype;\n        var desc = Object.getOwnPropertyDescriptor(object, property);\n\n        if (desc === undefined) {\n          var parent = Object.getPrototypeOf(object);\n\n          if (parent === null) {\n            return undefined;\n          } else {\n            return get(parent, property, receiver);\n          }\n        } else if (\"value\" in desc) {\n          return desc.value;\n        } else {\n          var getter = desc.get;\n\n          if (getter === undefined) {\n            return undefined;\n          }\n\n          return getter.call(receiver);\n        }\n      };\n\n      var _root = __webpack_require__(27);\n\n      var _root2 = _interopRequireDefault(_root);\n\n      var _lessStringify = __webpack_require__(14);\n\n      var _lessStringify2 = _interopRequireDefault(_lessStringify);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      function _possibleConstructorReturn(self, call) {\n        if (!self) {\n          throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n\n        return call && (_typeof(call) === \"object\" || typeof call === \"function\") ? call : self;\n      }\n\n      function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) {\n          throw new TypeError(\"Super expression must either be null or a function, not \" + _typeof(superClass));\n        }\n\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n      }\n\n      var Root = function (_PostCssRoot) {\n        _inherits(Root, _PostCssRoot);\n\n        function Root() {\n          _classCallCheck(this, Root);\n\n          return _possibleConstructorReturn(this, (Root.__proto__ || Object.getPrototypeOf(Root)).apply(this, arguments));\n        }\n\n        _createClass(Root, [{\n          key: 'toString',\n          value: function toString(stringifier) {\n            if (!stringifier) {\n              stringifier = {\n                stringify: _lessStringify2.default\n              };\n            }\n\n            return _get(Root.prototype.__proto__ || Object.getPrototypeOf(Root.prototype), 'toString', this).call(this, stringifier);\n          }\n        }]);\n\n        return Root;\n      }(_root2.default);\n\n      exports.default = Root;\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 166 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = findExtendRule;\n      var extendRuleKeyWords = ['&', ':', 'extend'];\n      var extendRuleKeyWordsCount = extendRuleKeyWords.length;\n\n      function findExtendRule(tokens) {\n        var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var stack = [];\n        var len = tokens.length;\n        var end = start;\n\n        while (end < len) {\n          var token = tokens[end];\n\n          if (extendRuleKeyWords.indexOf(token[1]) >= 0) {\n            stack.push(token[1]);\n          } else if (token[0] !== 'space') {\n            break;\n          }\n\n          end++;\n        }\n\n        for (var index = 0; index < extendRuleKeyWordsCount; index++) {\n          if (stack[index] !== extendRuleKeyWords[index]) {\n            return null;\n          }\n        }\n\n        return tokens.slice(start, end);\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 167 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = isMixinToken;\n\n      var _globals = __webpack_require__(2);\n\n      var unpaddedFractionalNumbersPattern = /\\.[0-9]/;\n\n      function isMixinToken(token) {\n        var symbol = token[1];\n        var firstSymbolCode = symbol ? symbol[0].charCodeAt(0) : null;\n        return (firstSymbolCode === _globals.dot || firstSymbolCode === _globals.hash) && // ignore hashes used for colors\n        _globals.hashColorPattern.test(symbol) === false && // ignore dots used for unpadded fractional numbers\n        unpaddedFractionalNumbersPattern.test(symbol) === false;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 168 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = lessTokenize;\n\n      var _globals = __webpack_require__(2);\n\n      var _tokenizeSymbol = __webpack_require__(169);\n\n      var _tokenizeSymbol2 = _interopRequireDefault(_tokenizeSymbol);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function lessTokenize(input) {\n        var state = {\n          input: input,\n          tokens: [],\n          css: input.css.valueOf(),\n          offset: -1,\n          line: 1,\n          pos: 0\n        };\n        state.length = state.css.length;\n\n        while (state.pos < state.length) {\n          state.symbolCode = state.css.charCodeAt(state.pos);\n          state.symbol = state.css[state.pos];\n          state.nextPos = null;\n          state.escaped = null;\n          state.lines = null;\n          state.lastLine = null;\n          state.cssPart = null;\n          state.escape = null;\n          state.nextLine = null;\n          state.nextOffset = null;\n          state.escapePos = null;\n          state.token = null;\n\n          if (state.symbolCode === _globals.newline) {\n            state.offset = state.pos;\n            state.line += 1;\n          }\n\n          (0, _tokenizeSymbol2.default)(state);\n          state.pos++;\n        }\n\n        return state.tokens;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 169 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeSymbol;\n\n      var _globals = __webpack_require__(2);\n\n      var _tokenizeAtRule = __webpack_require__(170);\n\n      var _tokenizeAtRule2 = _interopRequireDefault(_tokenizeAtRule);\n\n      var _tokenizeBackslash = __webpack_require__(171);\n\n      var _tokenizeBackslash2 = _interopRequireDefault(_tokenizeBackslash);\n\n      var _tokenizeBasicSymbol = __webpack_require__(172);\n\n      var _tokenizeBasicSymbol2 = _interopRequireDefault(_tokenizeBasicSymbol);\n\n      var _tokenizeComma = __webpack_require__(173);\n\n      var _tokenizeComma2 = _interopRequireDefault(_tokenizeComma);\n\n      var _tokenizeDefault = __webpack_require__(174);\n\n      var _tokenizeDefault2 = _interopRequireDefault(_tokenizeDefault);\n\n      var _tokenizeOpenedParenthesis = __webpack_require__(179);\n\n      var _tokenizeOpenedParenthesis2 = _interopRequireDefault(_tokenizeOpenedParenthesis);\n\n      var _tokenizeQuotes = __webpack_require__(180);\n\n      var _tokenizeQuotes2 = _interopRequireDefault(_tokenizeQuotes);\n\n      var _tokenizeWhitespace = __webpack_require__(181);\n\n      var _tokenizeWhitespace2 = _interopRequireDefault(_tokenizeWhitespace);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      } // we cannot reduce complexity beyond this level\n      // eslint-disable-next-line complexity\n\n\n      function tokenizeSymbol(state) {\n        switch (state.symbolCode) {\n          case _globals.newline:\n          case _globals.space:\n          case _globals.tab:\n          case _globals.carriageReturn:\n          case _globals.feed:\n            (0, _tokenizeWhitespace2.default)(state);\n            break;\n\n          case _globals.comma:\n            (0, _tokenizeComma2.default)(state);\n            break;\n\n          case _globals.colon:\n          case _globals.semicolon:\n          case _globals.openedCurlyBracket:\n          case _globals.closedCurlyBracket:\n          case _globals.closedParenthesis:\n          case _globals.openSquareBracket:\n          case _globals.closeSquareBracket:\n            (0, _tokenizeBasicSymbol2.default)(state);\n            break;\n\n          case _globals.openedParenthesis:\n            (0, _tokenizeOpenedParenthesis2.default)(state);\n            break;\n\n          case _globals.singleQuote:\n          case _globals.doubleQuote:\n            (0, _tokenizeQuotes2.default)(state);\n            break;\n\n          case _globals.atRule:\n            (0, _tokenizeAtRule2.default)(state);\n            break;\n\n          case _globals.backslash:\n            (0, _tokenizeBackslash2.default)(state);\n            break;\n\n          default:\n            (0, _tokenizeDefault2.default)(state);\n            break;\n        }\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 170 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeAtRule;\n\n      var _globals = __webpack_require__(2);\n\n      var _unclosed = __webpack_require__(11);\n\n      var _unclosed2 = _interopRequireDefault(_unclosed);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function tokenizeAtRule(state) {\n        // it's an interpolation\n        if (state.css.charCodeAt(state.pos + 1) === _globals.openedCurlyBracket) {\n          state.nextPos = state.css.indexOf('}', state.pos + 2);\n\n          if (state.nextPos === -1) {\n            (0, _unclosed2.default)(state, 'interpolation');\n          }\n\n          state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n          state.lines = state.cssPart.split('\\n');\n          state.lastLine = state.lines.length - 1;\n\n          if (state.lastLine > 0) {\n            state.nextLine = state.line + state.lastLine;\n            state.nextOffset = state.nextPos - state.lines[state.lastLine].length;\n          } else {\n            state.nextLine = state.line;\n            state.nextOffset = state.offset;\n          }\n\n          state.tokens.push(['word', state.cssPart, state.line, state.pos - state.offset, state.nextLine, state.nextPos - state.nextOffset]);\n          state.offset = state.nextOffset;\n          state.line = state.nextLine;\n        } else {\n          _globals.atEndPattern.lastIndex = state.pos + 1;\n\n          _globals.atEndPattern.test(state.css);\n\n          if (_globals.atEndPattern.lastIndex === 0) {\n            state.nextPos = state.css.length - 1;\n          } else {\n            state.nextPos = _globals.atEndPattern.lastIndex - 2;\n          }\n\n          state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n          state.token = 'at-word'; // check if it's a variable\n\n          if (_globals.variablePattern.test(state.cssPart)) {\n            _globals.wordEndPattern.lastIndex = state.pos + 1;\n\n            _globals.wordEndPattern.test(state.css);\n\n            if (_globals.wordEndPattern.lastIndex === 0) {\n              state.nextPos = state.css.length - 1;\n            } else {\n              state.nextPos = _globals.wordEndPattern.lastIndex - 2;\n            }\n\n            state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n            state.token = 'word';\n          }\n\n          state.tokens.push([state.token, state.cssPart, state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n        }\n\n        state.pos = state.nextPos;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 171 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeBackslash;\n\n      var _globals = __webpack_require__(2);\n\n      function tokenizeBackslash(state) {\n        state.nextPos = state.pos;\n        state.escape = true;\n\n        while (state.css.charCodeAt(state.nextPos + 1) === _globals.backslash) {\n          state.nextPos += 1;\n          state.escape = !state.escape;\n        }\n\n        state.symbolCode = state.css.charCodeAt(state.nextPos + 1);\n\n        if (state.escape && state.symbolCode !== _globals.slash && state.symbolCode !== _globals.space && state.symbolCode !== _globals.newline && state.symbolCode !== _globals.tab && state.symbolCode !== _globals.carriageReturn && state.symbolCode !== _globals.feed) {\n          state.nextPos += 1;\n        }\n\n        state.tokens.push(['word', state.css.slice(state.pos, state.nextPos + 1), state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n        state.pos = state.nextPos;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 172 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeBasicSymbol;\n\n      function tokenizeBasicSymbol(state) {\n        state.tokens.push([state.symbol, state.symbol, state.line, state.pos - state.offset]);\n      }\n\n      module.exports = exports[\"default\"];\n      /***/\n    },\n    /* 173 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeComma;\n\n      function tokenizeComma(state) {\n        state.tokens.push(['word', state.symbol, state.line, state.pos - state.offset, state.line, state.pos - state.offset + 1]);\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 174 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeDefault;\n\n      var _globals = __webpack_require__(2);\n\n      var _findEndOfEscaping = __webpack_require__(175);\n\n      var _findEndOfEscaping2 = _interopRequireDefault(_findEndOfEscaping);\n\n      var _isEscaping = __webpack_require__(176);\n\n      var _isEscaping2 = _interopRequireDefault(_isEscaping);\n\n      var _tokenizeInlineComment = __webpack_require__(177);\n\n      var _tokenizeInlineComment2 = _interopRequireDefault(_tokenizeInlineComment);\n\n      var _tokenizeMultilineComment = __webpack_require__(178);\n\n      var _tokenizeMultilineComment2 = _interopRequireDefault(_tokenizeMultilineComment);\n\n      var _unclosed = __webpack_require__(11);\n\n      var _unclosed2 = _interopRequireDefault(_unclosed);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function tokenizeDefault(state) {\n        var nextSymbolCode = state.css.charCodeAt(state.pos + 1);\n\n        if (state.symbolCode === _globals.slash && nextSymbolCode === _globals.asterisk) {\n          (0, _tokenizeMultilineComment2.default)(state);\n        } else if (state.symbolCode === _globals.slash && nextSymbolCode === _globals.slash) {\n          (0, _tokenizeInlineComment2.default)(state);\n        } else {\n          if ((0, _isEscaping2.default)(state)) {\n            var pos = (0, _findEndOfEscaping2.default)(state);\n\n            if (pos < 0) {\n              (0, _unclosed2.default)(state, 'escaping');\n            } else {\n              state.nextPos = pos;\n            }\n          } else {\n            _globals.wordEndPattern.lastIndex = state.pos + 1;\n\n            _globals.wordEndPattern.test(state.css);\n\n            if (_globals.wordEndPattern.lastIndex === 0) {\n              state.nextPos = state.css.length - 1;\n            } else {\n              state.nextPos = _globals.wordEndPattern.lastIndex - 2;\n            }\n          }\n\n          state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n          state.tokens.push(['word', state.cssPart, state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n          state.pos = state.nextPos;\n        }\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 175 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = findEndOfEscaping;\n\n      var _globals = __webpack_require__(2);\n      /**\n       * @param state\n       * @returns {number}\n       */\n\n\n      function findEndOfEscaping(state) {\n        var openQuotesCount = 0,\n            quoteCode = -1;\n\n        for (var i = state.pos + 1; i < state.length; i++) {\n          var symbolCode = state.css.charCodeAt(i);\n          var prevSymbolCode = state.css.charCodeAt(i - 1);\n\n          if (prevSymbolCode !== _globals.backslash && (symbolCode === _globals.singleQuote || symbolCode === _globals.doubleQuote || symbolCode === _globals.backTick)) {\n            if (quoteCode === -1) {\n              quoteCode = symbolCode;\n              openQuotesCount++;\n            } else if (symbolCode === quoteCode) {\n              openQuotesCount--;\n\n              if (!openQuotesCount) {\n                return i;\n              }\n            }\n          }\n        }\n\n        return -1;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 176 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = isEscaping;\n\n      var _globals = __webpack_require__(2);\n\n      var nextSymbolVariants = [_globals.backTick, _globals.doubleQuote, _globals.singleQuote];\n\n      function isEscaping(state) {\n        var nextSymbolCode = state.css.charCodeAt(state.pos + 1);\n        return state.symbolCode === _globals.tilde && nextSymbolVariants.indexOf(nextSymbolCode) >= 0;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 177 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeInlineComment;\n\n      function tokenizeInlineComment(state) {\n        state.nextPos = state.css.indexOf('\\n', state.pos + 2) - 1;\n\n        if (state.nextPos === -2) {\n          state.nextPos = state.css.length - 1;\n        }\n\n        state.tokens.push(['comment', state.css.slice(state.pos, state.nextPos + 1), state.line, state.pos - state.offset, state.line, state.nextPos - state.offset, 'inline']);\n        state.pos = state.nextPos;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 178 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeMultilineComment;\n\n      var _unclosed = __webpack_require__(11);\n\n      var _unclosed2 = _interopRequireDefault(_unclosed);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function tokenizeMultilineComment(state) {\n        state.nextPos = state.css.indexOf('*/', state.pos + 2) + 1;\n\n        if (state.nextPos === 0) {\n          (0, _unclosed2.default)(state, 'comment');\n        }\n\n        state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n        state.lines = state.cssPart.split('\\n');\n        state.lastLine = state.lines.length - 1;\n\n        if (state.lastLine > 0) {\n          state.nextLine = state.line + state.lastLine;\n          state.nextOffset = state.nextPos - state.lines[state.lastLine].length;\n        } else {\n          state.nextLine = state.line;\n          state.nextOffset = state.offset;\n        }\n\n        state.tokens.push(['comment', state.cssPart, state.line, state.pos - state.offset, state.nextLine, state.nextPos - state.nextOffset]);\n        state.offset = state.nextOffset;\n        state.line = state.nextLine;\n        state.pos = state.nextPos;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 179 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeOpenedParenthesis;\n\n      var _globals = __webpack_require__(2);\n\n      var _unclosed = __webpack_require__(11);\n\n      var _unclosed2 = _interopRequireDefault(_unclosed);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function findClosedParenthesisPosition(css, length, start) {\n        var openedParenthesisCount = 0;\n\n        for (var i = start; i < length; i++) {\n          var symbol = css[i];\n\n          if (symbol === '(') {\n            openedParenthesisCount++;\n          } else if (symbol === ')') {\n            openedParenthesisCount--;\n\n            if (!openedParenthesisCount) {\n              return i;\n            }\n          }\n        }\n\n        return -1;\n      } // it is not very reasonable to reduce complexity beyond this level\n      // eslint-disable-next-line complexity\n\n\n      function tokenizeOpenedParenthesis(state) {\n        var nextSymbolCode = state.css.charCodeAt(state.pos + 1);\n        var tokensCount = state.tokens.length;\n        var prevTokenCssPart = tokensCount ? state.tokens[tokensCount - 1][1] : '';\n\n        if (prevTokenCssPart === 'url' && nextSymbolCode !== _globals.singleQuote && nextSymbolCode !== _globals.doubleQuote && nextSymbolCode !== _globals.space && nextSymbolCode !== _globals.newline && nextSymbolCode !== _globals.tab && nextSymbolCode !== _globals.feed && nextSymbolCode !== _globals.carriageReturn) {\n          state.nextPos = state.pos;\n\n          do {\n            state.escaped = false;\n            state.nextPos = state.css.indexOf(')', state.nextPos + 1);\n\n            if (state.nextPos === -1) {\n              (0, _unclosed2.default)(state, 'bracket');\n            }\n\n            state.escapePos = state.nextPos;\n\n            while (state.css.charCodeAt(state.escapePos - 1) === _globals.backslash) {\n              state.escapePos -= 1;\n              state.escaped = !state.escaped;\n            }\n          } while (state.escaped);\n\n          state.tokens.push(['brackets', state.css.slice(state.pos, state.nextPos + 1), state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n          state.pos = state.nextPos;\n        } else {\n          state.nextPos = findClosedParenthesisPosition(state.css, state.length, state.pos);\n          state.cssPart = state.css.slice(state.pos, state.nextPos + 1);\n          var foundParam = state.cssPart.indexOf('@') >= 0;\n          var foundString = /['\"]/.test(state.cssPart);\n\n          if (state.cssPart.length === 0 || state.cssPart === '...' || foundParam && !foundString) {\n            // we're dealing with a mixin param block\n            if (state.nextPos === -1) {\n              (0, _unclosed2.default)(state, 'bracket');\n            }\n\n            state.tokens.push([state.symbol, state.symbol, state.line, state.pos - state.offset]);\n          } else {\n            var badBracket = _globals.badBracketPattern.test(state.cssPart);\n\n            if (state.nextPos === -1 || badBracket) {\n              state.tokens.push([state.symbol, state.symbol, state.line, state.pos - state.offset]);\n            } else {\n              state.tokens.push(['brackets', state.cssPart, state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n              state.pos = state.nextPos;\n            }\n          }\n        }\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 180 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeQuotes;\n\n      var _globals = __webpack_require__(2);\n\n      var _unclosed = __webpack_require__(11);\n\n      var _unclosed2 = _interopRequireDefault(_unclosed);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function tokenizeQuotes(state) {\n        state.nextPos = state.pos;\n\n        do {\n          state.escaped = false;\n          state.nextPos = state.css.indexOf(state.symbol, state.nextPos + 1);\n\n          if (state.nextPos === -1) {\n            (0, _unclosed2.default)(state, 'quote');\n          }\n\n          state.escapePos = state.nextPos;\n\n          while (state.css.charCodeAt(state.escapePos - 1) === _globals.backslash) {\n            state.escapePos -= 1;\n            state.escaped = !state.escaped;\n          }\n        } while (state.escaped);\n\n        state.tokens.push(['string', state.css.slice(state.pos, state.nextPos + 1), state.line, state.pos - state.offset, state.line, state.nextPos - state.offset]);\n        state.pos = state.nextPos;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 181 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = tokenizeWhitespace;\n\n      var _globals = __webpack_require__(2);\n\n      function tokenizeWhitespace(state) {\n        state.nextPos = state.pos; // collect all neighbour space symbols\n\n        do {\n          state.nextPos += 1;\n          state.symbolCode = state.css.charCodeAt(state.nextPos);\n\n          if (state.symbolCode === _globals.newline) {\n            state.offset = state.nextPos;\n            state.line += 1;\n          }\n        } while (state.symbolCode === _globals.space || state.symbolCode === _globals.newline || state.symbolCode === _globals.tab || state.symbolCode === _globals.carriageReturn || state.symbolCode === _globals.feed);\n\n        state.tokens.push(['space', state.css.slice(state.pos, state.nextPos)]);\n        state.pos = state.nextPos - 1;\n      }\n\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 182 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var _lessParse = __webpack_require__(183);\n\n      var _lessParse2 = _interopRequireDefault(_lessParse);\n\n      var _lessStringify = __webpack_require__(14);\n\n      var _lessStringify2 = _interopRequireDefault(_lessStringify);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      exports.default = {\n        parse: _lessParse2.default,\n        stringify: _lessStringify2.default\n      };\n      module.exports = exports['default'];\n      /***/\n    },\n    /* 183 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.default = lessParse;\n\n      var _input = __webpack_require__(23);\n\n      var _input2 = _interopRequireDefault(_input);\n\n      var _lessParser = __webpack_require__(72);\n\n      var _lessParser2 = _interopRequireDefault(_lessParser);\n\n      function _interopRequireDefault(obj) {\n        return obj && obj.__esModule ? obj : {\n          default: obj\n        };\n      }\n\n      function lessParse(less, opts) {\n        var input = new _input2.default(less, opts);\n        var parser = new _lessParser2.default(input, opts); // const parser = new Parser(input, opts);\n\n        parser.tokenize();\n        parser.loop();\n        return parser.root;\n      } // import Parser from 'postcss/lib/parser';\n\n\n      module.exports = exports['default'];\n      /***/\n    }])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}